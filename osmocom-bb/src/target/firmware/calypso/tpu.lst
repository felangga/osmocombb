   1              		.file	"tpu.c"
   9              	.Ltext0:
  10              		.data
  11              		.align	2
  14              	tpu_ptr:
  15 0000 0090FFFF 		.word	-28672
  16              		.section	.rodata.str1.4,"aMS",%progbits,1
  17              		.align	2
  18              	.LC0:
  19 0000 54505520 		.ascii	"TPU enqueue beyond end of TPU memory\012\000"
  19      656E7175 
  19      65756520 
  19      6265796F 
  19      6E642065 
  20              		.section	.text.tpu_enqueue,"ax",%progbits
  21              		.align	2
  22              		.global	tpu_enqueue
  24              	tpu_enqueue:
  25              	.LFB20:
  26              		.file 1 "calypso/tpu.c"
   1:calypso/tpu.c **** /* Calypso DBB internal TPU (Time Processing Unit) Driver */
   2:calypso/tpu.c **** 
   3:calypso/tpu.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:calypso/tpu.c ****  *
   5:calypso/tpu.c ****  * All Rights Reserved
   6:calypso/tpu.c ****  *
   7:calypso/tpu.c ****  * This program is free software; you can redistribute it and/or modify
   8:calypso/tpu.c ****  * it under the terms of the GNU General Public License as published by
   9:calypso/tpu.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:calypso/tpu.c ****  * (at your option) any later version.
  11:calypso/tpu.c ****  *
  12:calypso/tpu.c ****  * This program is distributed in the hope that it will be useful,
  13:calypso/tpu.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:calypso/tpu.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:calypso/tpu.c ****  * GNU General Public License for more details.
  16:calypso/tpu.c ****  *
  17:calypso/tpu.c ****  * You should have received a copy of the GNU General Public License along
  18:calypso/tpu.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:calypso/tpu.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:calypso/tpu.c ****  *
  21:calypso/tpu.c ****  */
  22:calypso/tpu.c **** 
  23:calypso/tpu.c **** #include <stdint.h>
  24:calypso/tpu.c **** #include <stdio.h>
  25:calypso/tpu.c **** 
  26:calypso/tpu.c **** #include <debug.h>
  27:calypso/tpu.c **** #include <delay.h>
  28:calypso/tpu.c **** #include <memory.h>
  29:calypso/tpu.c **** #include <calypso/tpu.h>
  30:calypso/tpu.c **** #include <calypso/tsp.h>
  31:calypso/tpu.c **** 
  32:calypso/tpu.c **** /* Using TPU_DEBUG you will send special HLDC messages to the host PC
  33:calypso/tpu.c ****  * containing the full TPU RAM content at the time you call tpu_enable() */
  34:calypso/tpu.c **** //#define TPU_DEBUG
  35:calypso/tpu.c **** 
  36:calypso/tpu.c **** #define BASE_ADDR_TPU	0xffff1000
  37:calypso/tpu.c **** #define TPU_REG(x)	(BASE_ADDR_TPU+(x))
  38:calypso/tpu.c **** 
  39:calypso/tpu.c **** #define BASE_ADDR_TPU_RAM	0xffff9000
  40:calypso/tpu.c **** #define TPU_RAM_END		0xffff97ff
  41:calypso/tpu.c **** 
  42:calypso/tpu.c **** enum tpu_reg_arm {
  43:calypso/tpu.c **** 	TPU_CTRL	= 0x0,	/* Control & Status Register */
  44:calypso/tpu.c **** 	INT_CTRL	= 0x2,	/* Interrupt Control Register */
  45:calypso/tpu.c **** 	INT_STAT	= 0x4,	/* Interrupt Status Register */
  46:calypso/tpu.c **** 	TPU_OFFSET	= 0xC,	/* Offset operand value register */
  47:calypso/tpu.c **** 	TPU_SYNCHRO	= 0xE,	/* synchro operand value register */
  48:calypso/tpu.c **** 	IT_DSP_PG	= 0x20,
  49:calypso/tpu.c **** };
  50:calypso/tpu.c **** 
  51:calypso/tpu.c **** enum tpu_ctrl_bits {
  52:calypso/tpu.c **** 	TPU_CTRL_RESET		= (1 << 0),
  53:calypso/tpu.c **** 	TPU_CTRL_PAGE		= (1 << 1),
  54:calypso/tpu.c **** 	TPU_CTRL_EN		= (1 << 2),
  55:calypso/tpu.c **** 	/* unused */
  56:calypso/tpu.c **** 	TPU_CTRL_DSP_EN		= (1 << 4),
  57:calypso/tpu.c **** 	/* unused */
  58:calypso/tpu.c **** 	TPU_CTRL_MCU_RAM_ACC	= (1 << 6),
  59:calypso/tpu.c **** 	TPU_CTRL_TSP_RESET	= (1 << 7),
  60:calypso/tpu.c **** 	TPU_CTRL_IDLE		= (1 << 8),
  61:calypso/tpu.c **** 	TPU_CTRL_WAIT		= (1 << 9),
  62:calypso/tpu.c **** 	TPU_CTRL_CK_ENABLE	= (1 << 10),
  63:calypso/tpu.c **** 	TPU_CTRL_FULL_WRITE	= (1 << 11),
  64:calypso/tpu.c **** };
  65:calypso/tpu.c **** 
  66:calypso/tpu.c **** enum tpu_int_ctrl_bits {
  67:calypso/tpu.c **** 	ICTRL_MCU_FRAME		= (1 << 0),
  68:calypso/tpu.c **** 	ICTRL_MCU_PAGE		= (1 << 1),
  69:calypso/tpu.c **** 	ICTRL_DSP_FRAME		= (1 << 2),
  70:calypso/tpu.c **** 	ICTRL_DSP_FRAME_FORCE	= (1 << 3),
  71:calypso/tpu.c **** };
  72:calypso/tpu.c **** 
  73:calypso/tpu.c **** static uint16_t *tpu_ptr = (uint16_t *)BASE_ADDR_TPU_RAM;
  74:calypso/tpu.c **** 
  75:calypso/tpu.c **** #ifdef TPU_DEBUG
  76:calypso/tpu.c **** #include <comm/sercomm.h>
  77:calypso/tpu.c **** #include <layer1/sync.h>
  78:calypso/tpu.c **** static struct msgb *tpu_debug_msg = NULL;
  79:calypso/tpu.c **** 
  80:calypso/tpu.c **** static void tpu_debug_alloc(void)
  81:calypso/tpu.c **** {
  82:calypso/tpu.c **** 	tpu_debug_msg = sercomm_alloc_msgb(sizeof(uint32_t) + 64*2);
  83:calypso/tpu.c **** 	if (!tpu_debug_msg)
  84:calypso/tpu.c **** 		printf("UNABLE TO ALLOC TPU DBG\n");
  85:calypso/tpu.c **** }
  86:calypso/tpu.c **** static void tpu_debug_flush(void)
  87:calypso/tpu.c **** {
  88:calypso/tpu.c **** 	if (tpu_debug_msg) {
  89:calypso/tpu.c **** 		sercomm_sendmsg(SC_DLCI_DEBUG, tpu_debug_msg);
  90:calypso/tpu.c **** 		tpu_debug_msg = NULL;
  91:calypso/tpu.c **** 	}
  92:calypso/tpu.c **** 	tpu_debug_alloc();
  93:calypso/tpu.c **** }
  94:calypso/tpu.c **** static void tpu_debug_enqueue(uint16_t instr)
  95:calypso/tpu.c **** {
  96:calypso/tpu.c **** 	uint16_t *u16_out;
  97:calypso/tpu.c **** 
  98:calypso/tpu.c **** 	if (!tpu_debug_msg)
  99:calypso/tpu.c **** 		return;
 100:calypso/tpu.c **** 	if (tpu_ptr == (uint16_t *) BASE_ADDR_TPU_RAM) {
 101:calypso/tpu.c **** 		/* prepend tpu memory dump with frame number */
 102:calypso/tpu.c **** 		uint32_t *fn = (uint32_t *) msgb_put(tpu_debug_msg, sizeof(fn));
 103:calypso/tpu.c **** 		*fn = l1s.current_time.fn;
 104:calypso/tpu.c **** 	}
 105:calypso/tpu.c **** 	if (msgb_tailroom(tpu_debug_msg) >= sizeof(instr)) {
 106:calypso/tpu.c **** 		/* cannot use msgb_put_u16 as host program expects little endian */
 107:calypso/tpu.c **** 		u16_out = (uint16_t *) msgb_put(tpu_debug_msg, sizeof(instr));
 108:calypso/tpu.c **** 		*u16_out = instr;
 109:calypso/tpu.c **** 	}
 110:calypso/tpu.c **** }
 111:calypso/tpu.c **** #else
 112:calypso/tpu.c **** static void tpu_debug_alloc(void) { }
 113:calypso/tpu.c **** static void tpu_debug_flush(void) { }
 114:calypso/tpu.c **** static void tpu_debug_enqueue(uint16_t instr) { }
 115:calypso/tpu.c **** #endif
 116:calypso/tpu.c **** 
 117:calypso/tpu.c **** #define BIT_SET	1
 118:calypso/tpu.c **** #define BIT_CLEAR 0
 119:calypso/tpu.c **** 
 120:calypso/tpu.c **** /* wait for a certain control bit to be set */
 121:calypso/tpu.c **** static int tpu_wait_ctrl_bit(uint16_t bit, int set)
 122:calypso/tpu.c **** {
 123:calypso/tpu.c **** 	int timeout = 10*1000;
 124:calypso/tpu.c **** 
 125:calypso/tpu.c **** 	while (1) {
 126:calypso/tpu.c **** 		uint16_t reg = readw(TPU_REG(TPU_CTRL));
 127:calypso/tpu.c **** 		if (set) {
 128:calypso/tpu.c **** 			if (reg & bit)
 129:calypso/tpu.c **** 				break;
 130:calypso/tpu.c **** 		} else {
 131:calypso/tpu.c **** 			if (!(reg & bit))
 132:calypso/tpu.c **** 				break;
 133:calypso/tpu.c **** 		}
 134:calypso/tpu.c **** 		timeout--;
 135:calypso/tpu.c **** 		if (timeout <= 0) {
 136:calypso/tpu.c **** 			puts("Timeout while waiting for TPU ctrl bit!\n");
 137:calypso/tpu.c **** 			return -1;
 138:calypso/tpu.c **** 		}
 139:calypso/tpu.c **** 	}
 140:calypso/tpu.c **** 
 141:calypso/tpu.c **** 	return 0;
 142:calypso/tpu.c **** }
 143:calypso/tpu.c **** 
 144:calypso/tpu.c **** /* assert or de-assert TPU reset */
 145:calypso/tpu.c **** void tpu_reset(int active)
 146:calypso/tpu.c **** {
 147:calypso/tpu.c **** 	uint16_t reg;
 148:calypso/tpu.c **** 
 149:calypso/tpu.c **** 	printd("tpu_reset(%u)\n", active);
 150:calypso/tpu.c **** 	reg = readw(TPU_REG(TPU_CTRL));
 151:calypso/tpu.c **** 	if (active) {
 152:calypso/tpu.c **** 		reg |= (TPU_CTRL_RESET|TPU_CTRL_TSP_RESET);
 153:calypso/tpu.c **** 		writew(reg, TPU_REG(TPU_CTRL));
 154:calypso/tpu.c **** 		tpu_wait_ctrl_bit(TPU_CTRL_RESET, BIT_SET);
 155:calypso/tpu.c **** 	} else {
 156:calypso/tpu.c **** 		reg &= ~(TPU_CTRL_RESET|TPU_CTRL_TSP_RESET);
 157:calypso/tpu.c **** 		writew(reg, TPU_REG(TPU_CTRL));
 158:calypso/tpu.c **** 		tpu_wait_ctrl_bit(TPU_CTRL_RESET, BIT_CLEAR);
 159:calypso/tpu.c **** 	}
 160:calypso/tpu.c **** }
 161:calypso/tpu.c **** 
 162:calypso/tpu.c **** /* Enable or Disable a new scenario loaded into the TPU */
 163:calypso/tpu.c **** void tpu_enable(int active)
 164:calypso/tpu.c **** {
 165:calypso/tpu.c **** 	uint16_t reg = readw(TPU_REG(TPU_CTRL));
 166:calypso/tpu.c **** 
 167:calypso/tpu.c **** 	printd("tpu_enable(%u)\n", active);
 168:calypso/tpu.c **** 
 169:calypso/tpu.c **** 	if (active)
 170:calypso/tpu.c **** 		reg |= TPU_CTRL_EN;
 171:calypso/tpu.c **** 	else
 172:calypso/tpu.c **** 		reg &= ~TPU_CTRL_EN;
 173:calypso/tpu.c **** 	writew(reg, TPU_REG(TPU_CTRL));
 174:calypso/tpu.c **** 
 175:calypso/tpu.c **** 	tpu_debug_flush();
 176:calypso/tpu.c **** 
 177:calypso/tpu.c **** 	/* After the new scenario is loaded, TPU switches the MCU-visible memory
 178:calypso/tpu.c **** 	 * page, i.e. we can write without any danger */
 179:calypso/tpu.c **** 	tpu_rewind();
 180:calypso/tpu.c **** #if 0
 181:calypso/tpu.c **** 	{
 182:calypso/tpu.c **** 		int i;
 183:calypso/tpu.c **** 		uint16_t oldreg = 0;
 184:calypso/tpu.c **** 
 185:calypso/tpu.c **** 		for (i = 0; i < 100000; i++) {
 186:calypso/tpu.c **** 			reg = readw(TPU_REG(TPU_CTRL));
 187:calypso/tpu.c **** 			if (i == 0 || oldreg != reg) {
 188:calypso/tpu.c **** 				printd("%d TPU state: 0x%04x\n", i, reg);
 189:calypso/tpu.c **** 			}
 190:calypso/tpu.c **** 			oldreg = reg;
 191:calypso/tpu.c **** 		}
 192:calypso/tpu.c **** 	}
 193:calypso/tpu.c **** #endif
 194:calypso/tpu.c **** }
 195:calypso/tpu.c **** 
 196:calypso/tpu.c **** /* Enable or Disable the clock of the TPU Module */
 197:calypso/tpu.c **** void tpu_clk_enable(int active)
 198:calypso/tpu.c **** {
 199:calypso/tpu.c **** 	uint16_t reg = readw(TPU_REG(TPU_CTRL));
 200:calypso/tpu.c **** 
 201:calypso/tpu.c **** 	printd("tpu_clk_enable(%u)\n", active);
 202:calypso/tpu.c **** 	if (active) {
 203:calypso/tpu.c **** 		reg |= TPU_CTRL_CK_ENABLE;
 204:calypso/tpu.c **** 		writew(reg, TPU_REG(TPU_CTRL));
 205:calypso/tpu.c **** 		tpu_wait_ctrl_bit(TPU_CTRL_CK_ENABLE, BIT_SET);
 206:calypso/tpu.c **** 	} else {
 207:calypso/tpu.c **** 		reg &= ~TPU_CTRL_CK_ENABLE;
 208:calypso/tpu.c **** 		writew(reg, TPU_REG(TPU_CTRL));
 209:calypso/tpu.c **** 		tpu_wait_ctrl_bit(TPU_CTRL_CK_ENABLE, BIT_CLEAR);
 210:calypso/tpu.c **** 	}
 211:calypso/tpu.c **** }
 212:calypso/tpu.c **** 
 213:calypso/tpu.c **** /* Enable Frame Interrupt generation on next frame.  DSP will reset it */
 214:calypso/tpu.c **** void tpu_dsp_frameirq_enable(void)
 215:calypso/tpu.c **** {
 216:calypso/tpu.c **** 	uint16_t reg = readw(TPU_REG(TPU_CTRL));
 217:calypso/tpu.c **** 	reg |= TPU_CTRL_DSP_EN;
 218:calypso/tpu.c **** 	writew(reg, TPU_REG(TPU_CTRL));
 219:calypso/tpu.c **** 
 220:calypso/tpu.c **** 	tpu_wait_ctrl_bit(TPU_CTRL_DSP_EN, BIT_SET);
 221:calypso/tpu.c **** }
 222:calypso/tpu.c **** 
 223:calypso/tpu.c **** /* Is a Frame interrupt still pending for the DSP ? */
 224:calypso/tpu.c **** int tpu_dsp_fameirq_pending(void)
 225:calypso/tpu.c **** {
 226:calypso/tpu.c **** 	uint16_t reg = readw(TPU_REG(TPU_CTRL));
 227:calypso/tpu.c **** 
 228:calypso/tpu.c **** 	if (reg & TPU_CTRL_DSP_EN)
 229:calypso/tpu.c **** 		return 1;
 230:calypso/tpu.c **** 
 231:calypso/tpu.c **** 	return 0;
 232:calypso/tpu.c **** }
 233:calypso/tpu.c **** 
 234:calypso/tpu.c **** void tpu_rewind(void)
 235:calypso/tpu.c **** {
 236:calypso/tpu.c **** 	dputs("tpu_rewind()\n");
 237:calypso/tpu.c **** 	tpu_ptr = (uint16_t *) BASE_ADDR_TPU_RAM;
 238:calypso/tpu.c **** }
 239:calypso/tpu.c **** 
 240:calypso/tpu.c **** void tpu_enqueue(uint16_t instr)
 241:calypso/tpu.c **** {
  27              		.loc 1 241 0
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
 242:calypso/tpu.c **** 	printd("tpu_enqueue(tpu_ptr=%p, instr=0x%04x)\n", tpu_ptr, instr);
 243:calypso/tpu.c **** 	tpu_debug_enqueue(instr);
 244:calypso/tpu.c **** 	*tpu_ptr++ = instr;
  32              		.loc 1 244 0
  33 0000 18209FE5 		ldr	r2, .L5
  34 0004 003092E5 		ldr	r3, [r2, #0]
  35 0008 B200C3E0 		strh	r0, [r3], #2	@ movhi
 245:calypso/tpu.c **** 	if (tpu_ptr > (uint16_t *) TPU_RAM_END)
  36              		.loc 1 245 0
  37 000c 1A0B73E3 		cmn	r3, #26624
  38              		.loc 1 241 0
  39              		@ lr needed for prologue
 246:calypso/tpu.c **** 		puts("TPU enqueue beyond end of TPU memory\n");
  40              		.loc 1 246 0
  41 0010 0C009FE5 		ldr	r0, .L5+4
  42              	.LVL1:
  43              		.loc 1 244 0
  44 0014 003082E5 		str	r3, [r2, #0]
  45              		.loc 1 245 0
  46 0018 1EFF2F31 		bxcc	lr
 247:calypso/tpu.c **** }
  47              		.loc 1 247 0
  48              		.loc 1 246 0
  49 001c FEFFFFEA 		b	puts
  50              	.L6:
  51              		.align	2
  52              	.L5:
  53 0020 00000000 		.word	tpu_ptr
  54 0024 00000000 		.word	.LC0
  55              	.LFE20:
  57              		.section	.text.tpu_enq_wait,"ax",%progbits
  58              		.align	2
  60              	tpu_enq_wait:
  61              	.LFB7:
  62              		.file 2 "include/calypso/tpu.h"
   1:include/calypso/tpu.h **** #ifndef _CALYPSO_TPU_H
   2:include/calypso/tpu.h **** #define _CALYPSO_TPU_H
   3:include/calypso/tpu.h **** 
   4:include/calypso/tpu.h **** #define BITS_PER_TDMA		1250
   5:include/calypso/tpu.h **** #define QBITS_PER_TDMA		(BITS_PER_TDMA * 4)	/* 5000 */
   6:include/calypso/tpu.h **** #define TPU_RANGE		QBITS_PER_TDMA
   7:include/calypso/tpu.h **** #define	SWITCH_TIME		(TPU_RANGE-10)
   8:include/calypso/tpu.h **** 
   9:include/calypso/tpu.h **** /* Assert or de-assert TPU reset */
  10:include/calypso/tpu.h **** void tpu_reset(int active);
  11:include/calypso/tpu.h **** /* Enable or Disable a new scenario loaded into the TPU */
  12:include/calypso/tpu.h **** void tpu_enable(int active);
  13:include/calypso/tpu.h **** /* Enable or Disable the clock of the TPU Module */
  14:include/calypso/tpu.h **** void tpu_clk_enable(int active);
  15:include/calypso/tpu.h **** /* Enable Frame Interrupt generation on next frame.  DSP will reset it */
  16:include/calypso/tpu.h **** void tpu_dsp_frameirq_enable(void);
  17:include/calypso/tpu.h **** /* Is a Frame interrupt still pending for the DSP ? */
  18:include/calypso/tpu.h **** int tpu_dsp_fameirq_pending(void);
  19:include/calypso/tpu.h **** /* Rewind the TPU, i.e. restart enqueueing instructions at the base addr */
  20:include/calypso/tpu.h **** void tpu_rewind(void);
  21:include/calypso/tpu.h **** /* Enqueue a raw TPU instruction */
  22:include/calypso/tpu.h **** void tpu_enqueue(uint16_t instr);
  23:include/calypso/tpu.h **** /* Initialize TPU and TPU driver */
  24:include/calypso/tpu.h **** void tpu_init(void);
  25:include/calypso/tpu.h **** /* (Busy)Wait until TPU is idle */
  26:include/calypso/tpu.h **** void tpu_wait_idle(void);
  27:include/calypso/tpu.h **** /* Enable FRAME interrupt generation */
  28:include/calypso/tpu.h **** void tpu_frame_irq_en(int mcu, int dsp);
  29:include/calypso/tpu.h **** /* Force the generation of a DSP interrupt */
  30:include/calypso/tpu.h **** void tpu_force_dsp_frame_irq(void);
  31:include/calypso/tpu.h **** 
  32:include/calypso/tpu.h **** /* Get the current TPU SYNCHRO register */
  33:include/calypso/tpu.h **** uint16_t tpu_get_synchro(void);
  34:include/calypso/tpu.h **** /* Get the current TPU OFFSET register */
  35:include/calypso/tpu.h **** uint16_t tpu_get_offset(void);
  36:include/calypso/tpu.h **** 
  37:include/calypso/tpu.h **** enum tpu_instr {
  38:include/calypso/tpu.h **** 	TPU_INSTR_AT		= (1 << 13),
  39:include/calypso/tpu.h **** 	TPU_INSTR_OFFSET	= (2 << 13),
  40:include/calypso/tpu.h **** 	TPU_INSTR_SYNCHRO	= (3 << 13),	/* Loading delta synchro value in TPU synchro register */
  41:include/calypso/tpu.h **** 	TPU_INSTR_WAIT		= (5 << 13),	/* Wait a certain period (in GSM qbits) */
  42:include/calypso/tpu.h **** 	TPU_INSTR_SLEEP		= (0 << 13),	/* Stop the sequencer by disabling TPU ENABLE bit in ctrl reg */
  43:include/calypso/tpu.h **** 	/* data processing */
  44:include/calypso/tpu.h **** 	TPU_INSTR_MOVE		= (4 << 13),
  45:include/calypso/tpu.h **** };
  46:include/calypso/tpu.h **** 
  47:include/calypso/tpu.h **** /* Addresses internal to the TPU, only accessible via MOVE */
  48:include/calypso/tpu.h **** enum tpu_reg_int {
  49:include/calypso/tpu.h **** 	TPUI_TSP_CTRL1	= 0x00,
  50:include/calypso/tpu.h **** 	TPUI_TSP_CTRL2	= 0x01,
  51:include/calypso/tpu.h **** 	TPUI_TX_1	= 0x04,
  52:include/calypso/tpu.h **** 	TPUI_TX_2	= 0x03,
  53:include/calypso/tpu.h **** 	TPUI_TX_3	= 0x02,
  54:include/calypso/tpu.h **** 	TPUI_TX_4	= 0x05,
  55:include/calypso/tpu.h **** 	TPUI_TSP_ACT_L	= 0x06,
  56:include/calypso/tpu.h **** 	TPUI_TSP_ACT_U	= 0x07,
  57:include/calypso/tpu.h **** 	TPUI_TSP_SET1	= 0x09,
  58:include/calypso/tpu.h **** 	TPUI_TSP_SET2	= 0x0a,
  59:include/calypso/tpu.h **** 	TPUI_TSP_SET3	= 0x0b,
  60:include/calypso/tpu.h **** 	TPUI_DSP_INT_PG	= 0x10,
  61:include/calypso/tpu.h **** 	TPUI_GAUGING_EN = 0x11,
  62:include/calypso/tpu.h **** };
  63:include/calypso/tpu.h **** 
  64:include/calypso/tpu.h **** enum tpui_ctrl2_bits {
  65:include/calypso/tpu.h **** 	TPUI_CTRL2_RD		= (1 << 0),
  66:include/calypso/tpu.h **** 	TPUI_CTRL2_WR		= (1 << 1),
  67:include/calypso/tpu.h **** };
  68:include/calypso/tpu.h **** 
  69:include/calypso/tpu.h **** static inline uint16_t tpu_mod5000(int16_t time)
  70:include/calypso/tpu.h **** {
  71:include/calypso/tpu.h **** 	if (time < 0)
  72:include/calypso/tpu.h **** 		return time + 5000;
  73:include/calypso/tpu.h **** 	if (time >= 5000)
  74:include/calypso/tpu.h **** 		return time - 5000;
  75:include/calypso/tpu.h **** 	return time;
  76:include/calypso/tpu.h **** }
  77:include/calypso/tpu.h **** 
  78:include/calypso/tpu.h **** /* Enqueue a SLEEP operation (stop sequencer by disabling TPU ENABLE bit) */
  79:include/calypso/tpu.h **** static inline void tpu_enq_sleep(void)
  80:include/calypso/tpu.h **** {
  81:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_SLEEP);
  82:include/calypso/tpu.h **** }
  83:include/calypso/tpu.h **** 
  84:include/calypso/tpu.h **** /* Enqueue a MOVE operation */
  85:include/calypso/tpu.h **** static inline void tpu_enq_move(uint8_t addr, uint8_t data)
  86:include/calypso/tpu.h **** {
  87:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_MOVE | (data << 5) | (addr & 0x1f));
  88:include/calypso/tpu.h **** }
  89:include/calypso/tpu.h **** 
  90:include/calypso/tpu.h **** /* Enqueue an AT operation */
  91:include/calypso/tpu.h **** static inline void tpu_enq_at(int16_t time)
  92:include/calypso/tpu.h **** {
  93:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_AT | tpu_mod5000(time));
  94:include/calypso/tpu.h **** }
  95:include/calypso/tpu.h **** 
  96:include/calypso/tpu.h **** /* Enqueue a SYNC operation */
  97:include/calypso/tpu.h **** static inline void tpu_enq_sync(int16_t time)
  98:include/calypso/tpu.h **** {
  99:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_SYNCHRO | time);
 100:include/calypso/tpu.h **** }
 101:include/calypso/tpu.h **** 
 102:include/calypso/tpu.h **** /* Enqueue a WAIT operation */
 103:include/calypso/tpu.h **** static inline void tpu_enq_wait(int16_t time)
 104:include/calypso/tpu.h **** {
  63              		.loc 2 104 0
  64              		@ args = 0, pretend = 0, frame = 0
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67              	.LVL2:
  68 0000 0008A0E1 		mov	r0, r0, asl #16
  69              	.LVL3:
 105:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_WAIT | time);
  70              		.loc 2 105 0
  71 0004 0A0280E3 		orr	r0, r0, #-1610612736
  72 0008 2008A0E1 		mov	r0, r0, lsr #16
  73              		.loc 2 104 0
  74              		@ lr needed for prologue
 106:include/calypso/tpu.h **** }
  75              		.loc 2 106 0
  76              		.loc 2 105 0
  77 000c FEFFFFEA 		b	tpu_enqueue
  78              	.LFE7:
  80              		.section	.rodata.str1.4
  81 0026 0000     		.align	2
  82              	.LC1:
  83 0028 54696D65 		.ascii	"Timeout while waiting for TPU ctrl bit!\012\000"
  83      6F757420 
  83      7768696C 
  83      65207761 
  83      6974696E 
  84              		.section	.text.tpu_wait_ctrl_bit,"ax",%progbits
  85              		.align	2
  87              	tpu_wait_ctrl_bit:
  88              	.LFB13:
  89              		.loc 1 122 0
  90              		@ args = 0, pretend = 0, frame = 0
  91              		@ frame_needed = 0, uses_anonymous_args = 0
  92              	.LVL4:
  93 0000 04E02DE5 		str	lr, [sp, #-4]!
  94              	.LCFI0:
  95              		.loc 1 122 0
  96 0004 0008A0E1 		mov	r0, r0, asl #16
  97              	.LVL5:
  98 0008 48209FE5 		ldr	r2, .L20
  99              	.LVL6:
 100 000c 2008A0E1 		mov	r0, r0, lsr #16
 101              	.LVL7:
 102              	.L10:
 103              	.LBB2:
 104              		.loc 1 126 0
 105 0010 44309FE5 		ldr	r3, .L20+4
 106 0014 B030D3E1 		ldrh	r3, [r3, #0]
 107              		.loc 1 127 0
 108 0018 000051E3 		cmp	r1, #0
 109 001c 003003E0 		and	r3, r3, r0
 110 0020 0A00000A 		beq	.L11
 111              		.loc 1 128 0
 112 0024 000053E3 		cmp	r3, #0
 113 0028 0C00000A 		beq	.L14
 114 002c 120000EA 		b	.L13
 115              	.L11:
 116              		.loc 1 131 0
 117 0030 000053E3 		cmp	r3, #0
 118 0034 1200000A 		beq	.L13
 119              	.L14:
 120              		.loc 1 135 0
 121 0038 012052E2 		subs	r2, r2, #1
 122 003c 0200001A 		bne	.L10
 123              		.loc 1 136 0
 124 0040 18009FE5 		ldr	r0, .L20+8
 125              	.LVL8:
 126 0044 FEFFFFEB 		bl	puts
 127              	.LVL9:
 128 0048 0000E0E3 		mvn	r0, #0
 129 004c 04F09DE4 		ldr	pc, [sp], #4
 130              	.LVL10:
 131              	.L13:
 132              		.loc 1 137 0
 133 0050 0000A0E3 		mov	r0, #0
 134              	.LVL11:
 135              	.LBE2:
 136              		.loc 1 142 0
 137 0054 04F09DE4 		ldr	pc, [sp], #4
 138              	.L21:
 139              		.align	2
 140              	.L20:
 141 0058 10270000 		.word	10000
 142 005c 0010FFFF 		.word	-61440
 143 0060 28000000 		.word	.LC1
 144              	.LFE13:
 146              		.section	.text.tpu_reset,"ax",%progbits
 147              		.align	2
 148              		.global	tpu_reset
 150              	tpu_reset:
 151              	.LFB14:
 152              		.loc 1 146 0
 153              		@ args = 0, pretend = 0, frame = 0
 154              		@ frame_needed = 0, uses_anonymous_args = 0
 155              		@ link register save eliminated.
 156              	.LVL12:
 157              		.loc 1 150 0
 158 0000 28C09FE5 		ldr	ip, .L28
 159              		.loc 1 156 0
 160 0004 28209FE5 		ldr	r2, .L28+4
 161              	.LVL13:
 162              		.loc 1 150 0
 163 0008 B030DCE1 		ldrh	r3, [ip, #0]
 164              		.loc 1 151 0
 165 000c 001050E2 		subs	r1, r0, #0
 166              		.loc 1 154 0
 167 0010 0100A0E3 		mov	r0, #1
 168              	.LVL14:
 169              	.LVL15:
 170              		.loc 1 156 0
 171 0014 022003E0 		and	r2, r3, r2
 172              		.loc 1 154 0
 173 0018 0010A011 		movne	r1, r0
 174              	.LVL16:
 175              		.loc 1 152 0
 176 001c 813083E3 		orr	r3, r3, #129
 177              	.LVL17:
 178              		.loc 1 158 0
 179 0020 0100A003 		moveq	r0, #1
 180              		.loc 1 146 0
 181              		@ lr needed for prologue
 182              		.loc 1 153 0
 183 0024 B030CC11 		strneh	r3, [ip, #0]	@ movhi
 184              		.loc 1 157 0
 185 0028 B020CC01 		streqh	r2, [ip, #0]	@ movhi
 186              		.loc 1 160 0
 187              		.loc 1 158 0
 188 002c FEFFFFEA 		b	tpu_wait_ctrl_bit
 189              	.LVL18:
 190              	.L29:
 191              		.align	2
 192              	.L28:
 193 0030 0010FFFF 		.word	-61440
 194 0034 7EFF0000 		.word	65406
 195              	.LFE14:
 197              		.section	.text.tpu_rewind,"ax",%progbits
 198              		.align	2
 199              		.global	tpu_rewind
 201              	tpu_rewind:
 202              	.LFB19:
 203              		.loc 1 235 0
 204              		@ args = 0, pretend = 0, frame = 0
 205              		@ frame_needed = 0, uses_anonymous_args = 0
 206              		@ link register save eliminated.
 207              	.LVL19:
 208              		.loc 1 237 0
 209 0000 08209FE5 		ldr	r2, .L32
 210 0004 08309FE5 		ldr	r3, .L32+4
 211              		.loc 1 235 0
 212              		@ lr needed for prologue
 213              		.loc 1 237 0
 214 0008 002083E5 		str	r2, [r3, #0]
 215              		.loc 1 238 0
 216 000c 1EFF2FE1 		bx	lr
 217              	.L33:
 218              		.align	2
 219              	.L32:
 220 0010 0090FFFF 		.word	-28672
 221 0014 00000000 		.word	tpu_ptr
 222              	.LFE19:
 224              		.section	.text.tpu_clk_enable,"ax",%progbits
 225              		.align	2
 226              		.global	tpu_clk_enable
 228              	tpu_clk_enable:
 229              	.LFB16:
 230              		.loc 1 198 0
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              	.LVL20:
 234 0000 04E02DE5 		str	lr, [sp, #-4]!
 235              	.LCFI1:
 236              		.loc 1 199 0
 237 0004 30209FE5 		ldr	r2, .L40
 238              		.loc 1 207 0
 239 0008 30C09FE5 		ldr	ip, .L40+4
 240              	.LVL21:
 241              		.loc 1 199 0
 242 000c B030D2E1 		ldrh	r3, [r2, #0]
 243              		.loc 1 202 0
 244 0010 00E050E2 		subs	lr, r0, #0
 245              		.loc 1 205 0
 246 0014 010BA0E3 		mov	r0, #1024
 247              	.LVL22:
 248              	.LVL23:
 249              		.loc 1 207 0
 250 0018 0CC003E0 		and	ip, r3, ip
 251              		.loc 1 205 0
 252 001c 0110A0E3 		mov	r1, #1
 253              		.loc 1 203 0
 254 0020 003083E1 		orr	r3, r3, r0
 255              	.LVL24:
 256              		.loc 1 209 0
 257 0024 0E10A001 		moveq	r1, lr
 258 0028 010BA003 		moveq	r0, #1024
 259              		.loc 1 204 0
 260 002c B030C211 		strneh	r3, [r2, #0]	@ movhi
 261              		.loc 1 208 0
 262 0030 B0C0C201 		streqh	ip, [r2, #0]	@ movhi
 263              	.LVL25:
 264              		.loc 1 211 0
 265 0034 04E09DE4 		ldr	lr, [sp], #4
 266              		.loc 1 209 0
 267 0038 FEFFFFEA 		b	tpu_wait_ctrl_bit
 268              	.LVL26:
 269              	.L41:
 270              		.align	2
 271              	.L40:
 272 003c 0010FFFF 		.word	-61440
 273 0040 FFFB0000 		.word	64511
 274              	.LFE16:
 276              		.section	.text.tpu_dsp_frameirq_enable,"ax",%progbits
 277              		.align	2
 278              		.global	tpu_dsp_frameirq_enable
 280              	tpu_dsp_frameirq_enable:
 281              	.LFB17:
 282              		.loc 1 215 0
 283              		@ args = 0, pretend = 0, frame = 0
 284              		@ frame_needed = 0, uses_anonymous_args = 0
 285              		@ link register save eliminated.
 286              	.LVL27:
 287              		.loc 1 216 0
 288 0000 14209FE5 		ldr	r2, .L44
 289 0004 B030D2E1 		ldrh	r3, [r2, #0]
 290              		.loc 1 220 0
 291 0008 1000A0E3 		mov	r0, #16
 292              		.loc 1 217 0
 293 000c 103083E3 		orr	r3, r3, #16
 294              	.LVL28:
 295              		.loc 1 220 0
 296 0010 0110A0E3 		mov	r1, #1
 297              		.loc 1 215 0
 298              		@ lr needed for prologue
 299              		.loc 1 218 0
 300 0014 B030C2E1 		strh	r3, [r2, #0]	@ movhi
 301              		.loc 1 221 0
 302              		.loc 1 220 0
 303 0018 FEFFFFEA 		b	tpu_wait_ctrl_bit
 304              	.LVL29:
 305              	.L45:
 306              		.align	2
 307              	.L44:
 308 001c 0010FFFF 		.word	-61440
 309              	.LFE17:
 311              		.section	.text.tpu_dsp_fameirq_pending,"ax",%progbits
 312              		.align	2
 313              		.global	tpu_dsp_fameirq_pending
 315              	tpu_dsp_fameirq_pending:
 316              	.LFB18:
 317              		.loc 1 225 0
 318              		@ args = 0, pretend = 0, frame = 0
 319              		@ frame_needed = 0, uses_anonymous_args = 0
 320              		@ link register save eliminated.
 321              	.LVL30:
 322              		.loc 1 226 0
 323 0000 0C309FE5 		ldr	r3, .L48
 324 0004 B000D3E1 		ldrh	r0, [r3, #0]
 325 0008 2002A0E1 		mov	r0, r0, lsr #4
 326              		.loc 1 232 0
 327 000c 010000E2 		and	r0, r0, #1
 328              		.loc 1 225 0
 329              		@ lr needed for prologue
 330              		.loc 1 232 0
 331 0010 1EFF2FE1 		bx	lr
 332              	.L49:
 333              		.align	2
 334              	.L48:
 335 0014 0010FFFF 		.word	-61440
 336              	.LFE18:
 338              		.section	.text.tpu_wait_idle,"ax",%progbits
 339              		.align	2
 340              		.global	tpu_wait_idle
 342              	tpu_wait_idle:
 343              	.LFB23:
 248:calypso/tpu.c **** 
 249:calypso/tpu.c **** void tpu_init(void)
 250:calypso/tpu.c **** {
 251:calypso/tpu.c **** 	uint16_t *ptr;
 252:calypso/tpu.c **** 
 253:calypso/tpu.c **** 	/* Put TPU into Reset and enable clock */
 254:calypso/tpu.c **** 	tpu_reset(1);
 255:calypso/tpu.c **** 	tpu_clk_enable(1);
 256:calypso/tpu.c **** 
 257:calypso/tpu.c **** 	/* set all TPU RAM to zero */
 258:calypso/tpu.c **** 	for (ptr = (uint16_t *) BASE_ADDR_TPU_RAM; ptr < (uint16_t *) TPU_RAM_END; ptr++)
 259:calypso/tpu.c **** 		*ptr = 0x0000;
 260:calypso/tpu.c **** 
 261:calypso/tpu.c **** 	/* Get TPU out of reset */
 262:calypso/tpu.c **** 	tpu_reset(0);
 263:calypso/tpu.c **** 	/* Disable all interrupts */
 264:calypso/tpu.c **** 	writeb(0x7, TPU_REG(INT_CTRL));
 265:calypso/tpu.c **** 
 266:calypso/tpu.c **** 	tpu_rewind();
 267:calypso/tpu.c **** 	tpu_enq_offset(0);
 268:calypso/tpu.c **** 	tpu_enq_sync(0);
 269:calypso/tpu.c **** }
 270:calypso/tpu.c **** 
 271:calypso/tpu.c **** void tpu_test(void)
 272:calypso/tpu.c **** {
 273:calypso/tpu.c **** 	int i;
 274:calypso/tpu.c **** 
 275:calypso/tpu.c **** 	/* program a sequence of TSPACT events into the TPU */
 276:calypso/tpu.c **** 	for (i = 0; i < 10; i++) {
 277:calypso/tpu.c **** 		puts("TSP ACT enable: ");
 278:calypso/tpu.c **** 		tsp_act_enable(0x0001);
 279:calypso/tpu.c **** 		tpu_enq_wait(10);
 280:calypso/tpu.c **** 		puts("TSP ACT disable: ");
 281:calypso/tpu.c **** 		tsp_act_disable(0x0001);
 282:calypso/tpu.c **** 		tpu_enq_wait(10);
 283:calypso/tpu.c **** 	}
 284:calypso/tpu.c **** 	tpu_enq_sleep();
 285:calypso/tpu.c **** 
 286:calypso/tpu.c **** 	/* tell the chip to execute the scenario */
 287:calypso/tpu.c **** 	tpu_enable(1);
 288:calypso/tpu.c **** }
 289:calypso/tpu.c **** 
 290:calypso/tpu.c **** void tpu_wait_idle(void)
 291:calypso/tpu.c **** {
 344              		.loc 1 291 0
 345              		@ args = 0, pretend = 0, frame = 0
 346              		@ frame_needed = 0, uses_anonymous_args = 0
 347              	.LVL31:
 348 0000 04E02DE5 		str	lr, [sp, #-4]!
 349              	.LCFI2:
 292:calypso/tpu.c **** 	dputs("Waiting for TPU Idle ");
 293:calypso/tpu.c **** 	/* Wait until TPU is doing something */
 294:calypso/tpu.c **** 	delay_us(3);
 350              		.loc 1 294 0
 351 0004 0300A0E3 		mov	r0, #3
 352 0008 FEFFFFEB 		bl	delay_us
 353              	.L51:
 295:calypso/tpu.c **** 	/* Wait until TPU is idle */
 296:calypso/tpu.c **** 	while (readw(TPU_REG(TPU_CTRL)) & TPU_CTRL_IDLE)
 354              		.loc 1 296 0
 355 000c 0C309FE5 		ldr	r3, .L56
 356 0010 B030D3E1 		ldrh	r3, [r3, #0]
 357 0014 010C13E3 		tst	r3, #256
 358 0018 0100001A 		bne	.L51
 297:calypso/tpu.c **** 		dputchar('.');
 298:calypso/tpu.c **** 	dputs("Done!\n");
 299:calypso/tpu.c **** }
 359              		.loc 1 299 0
 360 001c 04F09DE4 		ldr	pc, [sp], #4
 361              	.L57:
 362              		.align	2
 363              	.L56:
 364 0020 0010FFFF 		.word	-61440
 365              	.LFE23:
 367              		.section	.text.tpu_frame_irq_en,"ax",%progbits
 368              		.align	2
 369              		.global	tpu_frame_irq_en
 371              	tpu_frame_irq_en:
 372              	.LFB24:
 300:calypso/tpu.c **** 
 301:calypso/tpu.c **** void tpu_frame_irq_en(int mcu, int dsp)
 302:calypso/tpu.c **** {
 373              		.loc 1 302 0
 374              		@ args = 0, pretend = 0, frame = 0
 375              		@ frame_needed = 0, uses_anonymous_args = 0
 376              		@ link register save eliminated.
 377              	.LVL32:
 303:calypso/tpu.c **** 	uint8_t reg = readb(TPU_REG(INT_CTRL));
 378              		.loc 1 303 0
 379 0000 28309FE5 		ldr	r3, .L66
 380 0004 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 304:calypso/tpu.c **** 	if (mcu)
 381              		.loc 1 304 0
 382 0008 000050E3 		cmp	r0, #0
 305:calypso/tpu.c **** 		reg &= ~ICTRL_MCU_FRAME;
 383              		.loc 1 305 0
 384 000c FE2003E2 		and	r2, r3, #254
 385              	.LVL33:
 386              		.loc 1 303 0
 387 0010 FF3003E2 		and	r3, r3, #255
 388              	.LVL34:
 306:calypso/tpu.c **** 	else
 307:calypso/tpu.c **** 		reg |= ICTRL_MCU_FRAME;
 389              		.loc 1 307 0
 390 0014 01208303 		orreq	r2, r3, #1
 308:calypso/tpu.c **** 
 309:calypso/tpu.c **** 	if (dsp)
 391              		.loc 1 309 0
 392 0018 000051E3 		cmp	r1, #0
 310:calypso/tpu.c **** 		reg &= ~ICTRL_DSP_FRAME;
 311:calypso/tpu.c **** 	else
 312:calypso/tpu.c **** 		reg |= ICTRL_DSP_FRAME;
 313:calypso/tpu.c **** 
 314:calypso/tpu.c **** 	writeb(reg, TPU_REG(INT_CTRL));
 393              		.loc 1 314 0
 394 001c 0C309FE5 		ldr	r3, .L66
 395              	.LVL35:
 396              		.loc 1 310 0
 397 0020 FB1002E2 		and	r1, r2, #251
 398              	.LVL36:
 399              		.loc 1 312 0
 400 0024 04108203 		orreq	r1, r2, #4
 401              		.loc 1 302 0
 402              		@ lr needed for prologue
 403              		.loc 1 314 0
 404 0028 0010C3E5 		strb	r1, [r3, #0]
 315:calypso/tpu.c **** }
 405              		.loc 1 315 0
 406 002c 1EFF2FE1 		bx	lr
 407              	.L67:
 408              		.align	2
 409              	.L66:
 410 0030 0210FFFF 		.word	-61438
 411              	.LFE24:
 413              		.section	.text.tpu_force_dsp_frame_irq,"ax",%progbits
 414              		.align	2
 415              		.global	tpu_force_dsp_frame_irq
 417              	tpu_force_dsp_frame_irq:
 418              	.LFB25:
 316:calypso/tpu.c **** 
 317:calypso/tpu.c **** void tpu_force_dsp_frame_irq(void)
 318:calypso/tpu.c **** {
 419              		.loc 1 318 0
 420              		@ args = 0, pretend = 0, frame = 0
 421              		@ frame_needed = 0, uses_anonymous_args = 0
 422              		@ link register save eliminated.
 423              	.LVL37:
 319:calypso/tpu.c **** 	uint8_t reg = readb(TPU_REG(INT_CTRL));
 424              		.loc 1 319 0
 425 0000 0C209FE5 		ldr	r2, .L70
 426 0004 0030D2E5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 320:calypso/tpu.c **** 	reg |= ICTRL_DSP_FRAME_FORCE;
 427              		.loc 1 320 0
 428 0008 083083E3 		orr	r3, r3, #8
 429              	.LVL38:
 430              		.loc 1 318 0
 431              		@ lr needed for prologue
 321:calypso/tpu.c **** 	writeb(reg, TPU_REG(INT_CTRL));
 432              		.loc 1 321 0
 433 000c 0030C2E5 		strb	r3, [r2, #0]
 322:calypso/tpu.c **** }
 434              		.loc 1 322 0
 435 0010 1EFF2FE1 		bx	lr
 436              	.L71:
 437              		.align	2
 438              	.L70:
 439 0014 0210FFFF 		.word	-61438
 440              	.LFE25:
 442              		.section	.text.tpu_get_offset,"ax",%progbits
 443              		.align	2
 444              		.global	tpu_get_offset
 446              	tpu_get_offset:
 447              	.LFB26:
 323:calypso/tpu.c **** 
 324:calypso/tpu.c **** uint16_t tpu_get_offset(void)
 325:calypso/tpu.c **** {
 448              		.loc 1 325 0
 449              		@ args = 0, pretend = 0, frame = 0
 450              		@ frame_needed = 0, uses_anonymous_args = 0
 451              		@ link register save eliminated.
 452              	.LVL39:
 326:calypso/tpu.c **** 	return readw(TPU_REG(TPU_OFFSET));
 453              		.loc 1 326 0
 454 0000 04309FE5 		ldr	r3, .L74
 455 0004 B000D3E1 		ldrh	r0, [r3, #0]
 456              		.loc 1 325 0
 457              		@ lr needed for prologue
 327:calypso/tpu.c **** }
 458              		.loc 1 327 0
 459 0008 1EFF2FE1 		bx	lr
 460              	.L75:
 461              		.align	2
 462              	.L74:
 463 000c 0C10FFFF 		.word	-61428
 464              	.LFE26:
 466              		.section	.text.tpu_get_synchro,"ax",%progbits
 467              		.align	2
 468              		.global	tpu_get_synchro
 470              	tpu_get_synchro:
 471              	.LFB27:
 328:calypso/tpu.c **** 
 329:calypso/tpu.c **** uint16_t tpu_get_synchro(void)
 330:calypso/tpu.c **** {
 472              		.loc 1 330 0
 473              		@ args = 0, pretend = 0, frame = 0
 474              		@ frame_needed = 0, uses_anonymous_args = 0
 475              		@ link register save eliminated.
 476              	.LVL40:
 331:calypso/tpu.c **** 	return readw(TPU_REG(TPU_SYNCHRO));
 477              		.loc 1 331 0
 478 0000 04309FE5 		ldr	r3, .L78
 479 0004 B000D3E1 		ldrh	r0, [r3, #0]
 480              		.loc 1 330 0
 481              		@ lr needed for prologue
 332:calypso/tpu.c **** }
 482              		.loc 1 332 0
 483 0008 1EFF2FE1 		bx	lr
 484              	.L79:
 485              		.align	2
 486              	.L78:
 487 000c 0E10FFFF 		.word	-61426
 488              	.LFE27:
 490              		.global	__modsi3
 491              		.section	.text.add_mod5000,"ax",%progbits
 492              		.align	2
 493              		.global	add_mod5000
 495              	add_mod5000:
 496              	.LFB28:
 333:calypso/tpu.c **** 
 334:calypso/tpu.c **** /* add two numbers, modulo 5000, and ensure the result is positive */
 335:calypso/tpu.c **** uint16_t add_mod5000(int16_t a, int16_t b)
 336:calypso/tpu.c **** {
 497              		.loc 1 336 0
 498              		@ args = 0, pretend = 0, frame = 0
 499              		@ frame_needed = 0, uses_anonymous_args = 0
 500              	.LVL41:
 337:calypso/tpu.c **** 	int32_t sum = (int32_t)a + (int32_t)b;
 501              		.loc 1 337 0
 502 0000 0118A0E1 		mov	r1, r1, asl #16
 503              	.LVL42:
 504 0004 4118A0E1 		mov	r1, r1, asr #16
 505 0008 0008A0E1 		mov	r0, r0, asl #16
 506              	.LVL43:
 507              		.loc 1 336 0
 508 000c 04E02DE5 		str	lr, [sp, #-4]!
 509              	.LCFI3:
 338:calypso/tpu.c **** 
 339:calypso/tpu.c **** 	sum %= 5000;
 510              		.loc 1 339 0
 511 0010 400881E0 		add	r0, r1, r0, asr #16
 512              	.LVL44:
 513 0014 18109FE5 		ldr	r1, .L84
 514 0018 FEFFFFEB 		bl	__modsi3
 515              	.LVL45:
 340:calypso/tpu.c **** 
 341:calypso/tpu.c **** 	/* wrap around zero */
 342:calypso/tpu.c **** 	if (sum < 0)
 516              		.loc 1 342 0
 517 001c 000050E3 		cmp	r0, #0
 518              	.LVL46:
 343:calypso/tpu.c **** 		sum += 5000;
 519              		.loc 1 343 0
 520 0020 4E0D80B2 		addlt	r0, r0, #4992
 521 0024 080080B2 		addlt	r0, r0, #8
 522 0028 0008A0E1 		mov	r0, r0, asl #16
 523              	.LVL47:
 344:calypso/tpu.c **** 
 345:calypso/tpu.c **** 	return sum;
 346:calypso/tpu.c **** }
 524              		.loc 1 346 0
 525 002c 2008A0E1 		mov	r0, r0, lsr #16
 526 0030 04F09DE4 		ldr	pc, [sp], #4
 527              	.L85:
 528              		.align	2
 529              	.L84:
 530 0034 88130000 		.word	5000
 531              	.LFE28:
 533              		.section	.text.tpu_enable,"ax",%progbits
 534              		.align	2
 535              		.global	tpu_enable
 537              	tpu_enable:
 538              	.LFB15:
 539              		.loc 1 164 0
 540              		@ args = 0, pretend = 0, frame = 0
 541              		@ frame_needed = 0, uses_anonymous_args = 0
 542              		@ link register save eliminated.
 543              	.LVL48:
 544              		.loc 1 165 0
 545 0000 28309FE5 		ldr	r3, .L91
 546              		.loc 1 172 0
 547 0004 28209FE5 		ldr	r2, .L91+4
 548              	.LVL49:
 549              		.loc 1 165 0
 550 0008 B030D3E1 		ldrh	r3, [r3, #0]
 551              		.loc 1 169 0
 552 000c 000050E3 		cmp	r0, #0
 553              	.LVL50:
 554              		.loc 1 170 0
 555 0010 04208313 		orrne	r2, r3, #4
 556              		.loc 1 172 0
 557 0014 02200300 		andeq	r2, r3, r2
 558              		.loc 1 173 0
 559 0018 10309FE5 		ldr	r3, .L91
 560              	.LVL51:
 561 001c B020C3E1 		strh	r2, [r3, #0]	@ movhi
 562              	.LBB3:
 563              		.loc 1 237 0
 564 0020 10209FE5 		ldr	r2, .L91+8
 565              	.LVL52:
 566 0024 10309FE5 		ldr	r3, .L91+12
 567              	.LBE3:
 568              		.loc 1 164 0
 569              		@ lr needed for prologue
 570              	.LBB4:
 571              		.loc 1 237 0
 572 0028 002083E5 		str	r2, [r3, #0]
 573              	.LBE4:
 574              		.loc 1 194 0
 575 002c 1EFF2FE1 		bx	lr
 576              	.L92:
 577              		.align	2
 578              	.L91:
 579 0030 0010FFFF 		.word	-61440
 580 0034 FBFF0000 		.word	65531
 581 0038 0090FFFF 		.word	-28672
 582 003c 00000000 		.word	tpu_ptr
 583              	.LFE15:
 585              		.section	.rodata.str1.4
 586 0051 000000   		.align	2
 587              	.LC2:
 588 0054 54535020 		.ascii	"TSP ACT enable: \000"
 588      41435420 
 588      656E6162 
 588      6C653A20 
 588      00
 589 0065 000000   		.align	2
 590              	.LC3:
 591 0068 54535020 		.ascii	"TSP ACT disable: \000"
 591      41435420 
 591      64697361 
 591      626C653A 
 591      2000
 592 007a 0000     		.section	.text.tpu_test,"ax",%progbits
 593              		.align	2
 594              		.global	tpu_test
 596              	tpu_test:
 597              	.LFB22:
 598              		.loc 1 272 0
 599              		@ args = 0, pretend = 0, frame = 0
 600              		@ frame_needed = 0, uses_anonymous_args = 0
 601              	.LVL53:
 602 0000 10402DE9 		stmfd	sp!, {r4, lr}
 603              	.LCFI4:
 604              		.loc 1 272 0
 605 0004 0A40A0E3 		mov	r4, #10
 606              	.L94:
 607              		.loc 1 277 0
 608 0008 44009FE5 		ldr	r0, .L99
 609 000c FEFFFFEB 		bl	puts
 610              		.loc 1 278 0
 611 0010 0100A0E3 		mov	r0, #1
 612 0014 FEFFFFEB 		bl	tsp_act_enable
 613              		.loc 1 279 0
 614 0018 0A00A0E3 		mov	r0, #10
 615 001c FEFFFFEB 		bl	tpu_enq_wait
 616              		.loc 1 280 0
 617 0020 30009FE5 		ldr	r0, .L99+4
 618 0024 FEFFFFEB 		bl	puts
 619              		.loc 1 281 0
 620 0028 0100A0E3 		mov	r0, #1
 621 002c FEFFFFEB 		bl	tsp_act_disable
 622              		.loc 1 282 0
 623 0030 0A00A0E3 		mov	r0, #10
 624 0034 FEFFFFEB 		bl	tpu_enq_wait
 625              		.loc 1 276 0
 626 0038 014054E2 		subs	r4, r4, #1
 627 003c 0000001A 		bne	.L94
 628              	.LBB5:
 629              		.loc 2 81 0
 630 0040 0400A0E1 		mov	r0, r4
 631 0044 FEFFFFEB 		bl	tpu_enqueue
 632              	.LBE5:
 633              		.loc 1 287 0
 634 0048 0100A0E3 		mov	r0, #1
 635              		.loc 1 288 0
 636 004c 1040BDE8 		ldmfd	sp!, {r4, lr}
 637              		.loc 1 287 0
 638 0050 FEFFFFEA 		b	tpu_enable
 639              	.L100:
 640              		.align	2
 641              	.L99:
 642 0054 54000000 		.word	.LC2
 643 0058 68000000 		.word	.LC3
 644              	.LFE22:
 646              		.section	.text.tpu_init,"ax",%progbits
 647              		.align	2
 648              		.global	tpu_init
 650              	tpu_init:
 651              	.LFB21:
 652              		.loc 1 250 0
 653              		@ args = 0, pretend = 0, frame = 0
 654              		@ frame_needed = 0, uses_anonymous_args = 0
 655              	.LVL54:
 656 0000 04E02DE5 		str	lr, [sp, #-4]!
 657              	.LCFI5:
 658              		.loc 1 254 0
 659 0004 0100A0E3 		mov	r0, #1
 660 0008 FEFFFFEB 		bl	tpu_reset
 661              		.loc 1 255 0
 662 000c 0100A0E3 		mov	r0, #1
 663 0010 FEFFFFEB 		bl	tpu_clk_enable
 664 0014 40309FE5 		ldr	r3, .L107
 665              	.LVL55:
 666              	.L102:
 667              		.loc 1 259 0
 668 0018 0020A0E3 		mov	r2, #0	@ movhi
 669 001c B220C3E0 		strh	r2, [r3], #2	@ movhi
 670              		.loc 1 258 0
 671 0020 1A0B73E3 		cmn	r3, #26624
 672 0024 0400001A 		bne	.L102
 673              		.loc 1 262 0
 674 0028 0000A0E3 		mov	r0, #0
 675 002c FEFFFFEB 		bl	tpu_reset
 676              	.LVL56:
 677              		.loc 1 264 0
 678 0030 28309FE5 		ldr	r3, .L107+4
 679 0034 0720A0E3 		mov	r2, #7
 680 0038 0020C3E5 		strb	r2, [r3, #0]
 681              	.LBB6:
 682              		.loc 1 237 0
 683 003c 18209FE5 		ldr	r2, .L107
 684 0040 1C309FE5 		ldr	r3, .L107+8
 685              	.LBE6:
 686              	.LBB7:
 687              	.LBB8:
 107:include/calypso/tpu.h **** 
 108:include/calypso/tpu.h **** /* Enqueue an OFFSET operation */
 109:include/calypso/tpu.h **** static inline void tpu_enq_offset(int16_t time)
 110:include/calypso/tpu.h **** {
 111:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_OFFSET | time);
 688              		.loc 2 111 0
 689 0044 0109A0E3 		mov	r0, #16384
 690              	.LBE8:
 691              	.LBE7:
 692              	.LBB9:
 693              		.loc 1 237 0
 694 0048 002083E5 		str	r2, [r3, #0]
 695              	.LBE9:
 696              	.LBB10:
 697              	.LBB11:
 698              		.loc 2 111 0
 699 004c FEFFFFEB 		bl	tpu_enqueue
 700              	.LBE11:
 701              	.LBE10:
 702              	.LBB12:
 703              	.LBB13:
 704              		.loc 2 99 0
 705 0050 060AA0E3 		mov	r0, #24576
 706              	.LBE13:
 707              	.LBE12:
 708              		.loc 1 269 0
 709 0054 04E09DE4 		ldr	lr, [sp], #4
 710              	.LBB14:
 711              	.LBB15:
 712              		.loc 2 99 0
 713 0058 FEFFFFEA 		b	tpu_enqueue
 714              	.L108:
 715              		.align	2
 716              	.L107:
 717 005c 0090FFFF 		.word	-28672
 718 0060 0210FFFF 		.word	-61438
 719 0064 00000000 		.word	tpu_ptr
 720              	.LBE15:
 721              	.LBE14:
 722              	.LFE21:
 915              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tpu.c
     /tmp/ccAMpgNt.s:14     .data:0000000000000000 tpu_ptr
     /tmp/ccAMpgNt.s:15     .data:0000000000000000 $d
     /tmp/ccAMpgNt.s:24     .text.tpu_enqueue:0000000000000000 tpu_enqueue
     /tmp/ccAMpgNt.s:33     .text.tpu_enqueue:0000000000000000 $a
     /tmp/ccAMpgNt.s:53     .text.tpu_enqueue:0000000000000020 $d
     /tmp/ccAMpgNt.s:60     .text.tpu_enq_wait:0000000000000000 tpu_enq_wait
     /tmp/ccAMpgNt.s:68     .text.tpu_enq_wait:0000000000000000 $a
     /tmp/ccAMpgNt.s:87     .text.tpu_wait_ctrl_bit:0000000000000000 tpu_wait_ctrl_bit
     /tmp/ccAMpgNt.s:93     .text.tpu_wait_ctrl_bit:0000000000000000 $a
     /tmp/ccAMpgNt.s:141    .text.tpu_wait_ctrl_bit:0000000000000058 $d
     /tmp/ccAMpgNt.s:150    .text.tpu_reset:0000000000000000 tpu_reset
     /tmp/ccAMpgNt.s:158    .text.tpu_reset:0000000000000000 $a
     /tmp/ccAMpgNt.s:193    .text.tpu_reset:0000000000000030 $d
     /tmp/ccAMpgNt.s:201    .text.tpu_rewind:0000000000000000 tpu_rewind
     /tmp/ccAMpgNt.s:209    .text.tpu_rewind:0000000000000000 $a
     /tmp/ccAMpgNt.s:220    .text.tpu_rewind:0000000000000010 $d
     /tmp/ccAMpgNt.s:228    .text.tpu_clk_enable:0000000000000000 tpu_clk_enable
     /tmp/ccAMpgNt.s:234    .text.tpu_clk_enable:0000000000000000 $a
     /tmp/ccAMpgNt.s:272    .text.tpu_clk_enable:000000000000003c $d
     /tmp/ccAMpgNt.s:280    .text.tpu_dsp_frameirq_enable:0000000000000000 tpu_dsp_frameirq_enable
     /tmp/ccAMpgNt.s:288    .text.tpu_dsp_frameirq_enable:0000000000000000 $a
     /tmp/ccAMpgNt.s:308    .text.tpu_dsp_frameirq_enable:000000000000001c $d
     /tmp/ccAMpgNt.s:315    .text.tpu_dsp_fameirq_pending:0000000000000000 tpu_dsp_fameirq_pending
     /tmp/ccAMpgNt.s:323    .text.tpu_dsp_fameirq_pending:0000000000000000 $a
     /tmp/ccAMpgNt.s:335    .text.tpu_dsp_fameirq_pending:0000000000000014 $d
     /tmp/ccAMpgNt.s:342    .text.tpu_wait_idle:0000000000000000 tpu_wait_idle
     /tmp/ccAMpgNt.s:348    .text.tpu_wait_idle:0000000000000000 $a
     /tmp/ccAMpgNt.s:364    .text.tpu_wait_idle:0000000000000020 $d
     /tmp/ccAMpgNt.s:371    .text.tpu_frame_irq_en:0000000000000000 tpu_frame_irq_en
     /tmp/ccAMpgNt.s:379    .text.tpu_frame_irq_en:0000000000000000 $a
     /tmp/ccAMpgNt.s:410    .text.tpu_frame_irq_en:0000000000000030 $d
     /tmp/ccAMpgNt.s:417    .text.tpu_force_dsp_frame_irq:0000000000000000 tpu_force_dsp_frame_irq
     /tmp/ccAMpgNt.s:425    .text.tpu_force_dsp_frame_irq:0000000000000000 $a
     /tmp/ccAMpgNt.s:439    .text.tpu_force_dsp_frame_irq:0000000000000014 $d
     /tmp/ccAMpgNt.s:446    .text.tpu_get_offset:0000000000000000 tpu_get_offset
     /tmp/ccAMpgNt.s:454    .text.tpu_get_offset:0000000000000000 $a
     /tmp/ccAMpgNt.s:463    .text.tpu_get_offset:000000000000000c $d
     /tmp/ccAMpgNt.s:470    .text.tpu_get_synchro:0000000000000000 tpu_get_synchro
     /tmp/ccAMpgNt.s:478    .text.tpu_get_synchro:0000000000000000 $a
     /tmp/ccAMpgNt.s:487    .text.tpu_get_synchro:000000000000000c $d
     /tmp/ccAMpgNt.s:495    .text.add_mod5000:0000000000000000 add_mod5000
     /tmp/ccAMpgNt.s:502    .text.add_mod5000:0000000000000000 $a
     /tmp/ccAMpgNt.s:530    .text.add_mod5000:0000000000000034 $d
     /tmp/ccAMpgNt.s:537    .text.tpu_enable:0000000000000000 tpu_enable
     /tmp/ccAMpgNt.s:545    .text.tpu_enable:0000000000000000 $a
     /tmp/ccAMpgNt.s:579    .text.tpu_enable:0000000000000030 $d
     /tmp/ccAMpgNt.s:596    .text.tpu_test:0000000000000000 tpu_test
     /tmp/ccAMpgNt.s:602    .text.tpu_test:0000000000000000 $a
     /tmp/ccAMpgNt.s:642    .text.tpu_test:0000000000000054 $d
     /tmp/ccAMpgNt.s:650    .text.tpu_init:0000000000000000 tpu_init
     /tmp/ccAMpgNt.s:656    .text.tpu_init:0000000000000000 $a
     /tmp/ccAMpgNt.s:717    .text.tpu_init:000000000000005c $d

UNDEFINED SYMBOLS
puts
delay_us
__modsi3
tsp_act_enable
tsp_act_disable
