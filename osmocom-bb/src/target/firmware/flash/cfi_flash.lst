   1              		.file	"cfi_flash.c"
   9              	.Ltext0:
  10              		.section	.rodata.str1.4,"aMS",%progbits,1
  11              		.align	2
  12              	.LC0:
  13 0000 4C6F636B 		.ascii	"Locking block at 0x%08lx\012\000"
  13      696E6720 
  13      626C6F63 
  13      6B206174 
  13      20307825 
  14              		.section	.ramtext,"ax",%progbits
  15              		.align	2
  16              		.global	flash_block_lock
  18              	flash_block_lock:
  19              	.LFB7:
  20              		.file 1 "flash/cfi_flash.c"
   1:flash/cfi_flash.c **** /* NOR Flash Driver for Intel 28F160C3 NOR flash */
   2:flash/cfi_flash.c **** 
   3:flash/cfi_flash.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:flash/cfi_flash.c ****  *
   5:flash/cfi_flash.c ****  * All Rights Reserved
   6:flash/cfi_flash.c ****  *
   7:flash/cfi_flash.c ****  * This program is free software; you can redistribute it and/or modify
   8:flash/cfi_flash.c ****  * it under the terms of the GNU General Public License as published by
   9:flash/cfi_flash.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:flash/cfi_flash.c ****  * (at your option) any later version.
  11:flash/cfi_flash.c ****  *
  12:flash/cfi_flash.c ****  * This program is distributed in the hope that it will be useful,
  13:flash/cfi_flash.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:flash/cfi_flash.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:flash/cfi_flash.c ****  * GNU General Public License for more details.
  16:flash/cfi_flash.c ****  *
  17:flash/cfi_flash.c ****  * You should have received a copy of the GNU General Public License along
  18:flash/cfi_flash.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:flash/cfi_flash.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:flash/cfi_flash.c ****  *
  21:flash/cfi_flash.c ****  */
  22:flash/cfi_flash.c **** 
  23:flash/cfi_flash.c **** #include <debug.h>
  24:flash/cfi_flash.c **** #include <stdio.h>
  25:flash/cfi_flash.c **** #include <stdint.h>
  26:flash/cfi_flash.c **** #include <errno.h>
  27:flash/cfi_flash.c **** #include <memory.h>
  28:flash/cfi_flash.c **** #include <defines.h>
  29:flash/cfi_flash.c **** #include <flash/cfi_flash.h>
  30:flash/cfi_flash.c **** 
  31:flash/cfi_flash.c **** /* XXX: strings must always be in ram */
  32:flash/cfi_flash.c **** #if 0
  33:flash/cfi_flash.c **** #define puts(...)
  34:flash/cfi_flash.c **** #define printf(...)
  35:flash/cfi_flash.c **** #endif
  36:flash/cfi_flash.c **** 
  37:flash/cfi_flash.c **** /* global definitions */
  38:flash/cfi_flash.c **** #define CFI_FLASH_MAX_ERASE_REGIONS 4
  39:flash/cfi_flash.c **** 
  40:flash/cfi_flash.c **** /* structure of erase region descriptor */
  41:flash/cfi_flash.c **** struct cfi_region {
  42:flash/cfi_flash.c **** 	uint16_t b_count;
  43:flash/cfi_flash.c **** 	uint16_t b_size;
  44:flash/cfi_flash.c **** } __attribute__ ((packed));
  45:flash/cfi_flash.c **** 
  46:flash/cfi_flash.c **** /* structure of cfi query response */
  47:flash/cfi_flash.c **** struct cfi_query {
  48:flash/cfi_flash.c **** 	uint8_t qry[3];
  49:flash/cfi_flash.c **** 	uint16_t p_id;
  50:flash/cfi_flash.c **** 	uint16_t p_adr;
  51:flash/cfi_flash.c **** 	uint16_t a_id;
  52:flash/cfi_flash.c **** 	uint16_t a_adr;
  53:flash/cfi_flash.c **** 	uint8_t vcc_min;
  54:flash/cfi_flash.c **** 	uint8_t vcc_max;
  55:flash/cfi_flash.c **** 	uint8_t vpp_min;
  56:flash/cfi_flash.c **** 	uint8_t vpp_max;
  57:flash/cfi_flash.c **** 	uint8_t word_write_timeout_typ;
  58:flash/cfi_flash.c **** 	uint8_t buf_write_timeout_typ;
  59:flash/cfi_flash.c **** 	uint8_t block_erase_timeout_typ;
  60:flash/cfi_flash.c **** 	uint8_t chip_erase_timeout_typ;
  61:flash/cfi_flash.c **** 	uint8_t word_write_timeout_max;
  62:flash/cfi_flash.c **** 	uint8_t buf_write_timeout_max;
  63:flash/cfi_flash.c **** 	uint8_t block_erase_timeout_max;
  64:flash/cfi_flash.c **** 	uint8_t chip_erase_timeout_max;
  65:flash/cfi_flash.c **** 	uint8_t dev_size;
  66:flash/cfi_flash.c **** 	uint16_t interface_desc;
  67:flash/cfi_flash.c **** 	uint16_t max_buf_write_size;
  68:flash/cfi_flash.c **** 	uint8_t num_erase_regions;
  69:flash/cfi_flash.c **** 	struct cfi_region erase_regions[CFI_FLASH_MAX_ERASE_REGIONS];
  70:flash/cfi_flash.c **** } __attribute__ ((packed));
  71:flash/cfi_flash.c **** 
  72:flash/cfi_flash.c **** /* algorithm ids */
  73:flash/cfi_flash.c **** enum cfi_algo {
  74:flash/cfi_flash.c **** 	CFI_ALGO_INTEL_3 = 0x03
  75:flash/cfi_flash.c **** };
  76:flash/cfi_flash.c **** 
  77:flash/cfi_flash.c **** /* various command bytes */
  78:flash/cfi_flash.c **** enum cfi_flash_cmd {
  79:flash/cfi_flash.c **** 	CFI_CMD_RESET = 0xff,
  80:flash/cfi_flash.c **** 	CFI_CMD_RESET_TO_READ_MODE = 0xF0,
  81:flash/cfi_flash.c **** 	CFI_CMD_READ_ID = 0x90,
  82:flash/cfi_flash.c **** 	CFI_CMD_CFI = 0x98,
  83:flash/cfi_flash.c **** 	CFI_CMD_READ_STATUS = 0x70,
  84:flash/cfi_flash.c **** 	CFI_CMD_CLEAR_STATUS = 0x50,
  85:flash/cfi_flash.c **** 	CFI_CMD_WRITE = 0x40,
  86:flash/cfi_flash.c **** 	CFI_CMD_BLOCK_ERASE = 0x20,
  87:flash/cfi_flash.c **** 	CFI_CMD_ERASE_CONFIRM = 0xD0,
  88:flash/cfi_flash.c **** 	CFI_CMD_PROTECT = 0x60,
  89:flash/cfi_flash.c **** 	CFI_CMD_UNLOCK1 = 0xAA,
  90:flash/cfi_flash.c **** 	CFI_CMD_UNLOCK2 = 0x55,
  91:flash/cfi_flash.c **** };
  92:flash/cfi_flash.c **** 
  93:flash/cfi_flash.c **** /* protection commands */
  94:flash/cfi_flash.c **** enum flash_prot_cmd {
  95:flash/cfi_flash.c **** 	CFI_PROT_LOCK = 0x01,
  96:flash/cfi_flash.c **** 	CFI_PROT_UNLOCK = 0xD0,
  97:flash/cfi_flash.c **** 	CFI_PROT_LOCKDOWN = 0x2F
  98:flash/cfi_flash.c **** };
  99:flash/cfi_flash.c **** 
 100:flash/cfi_flash.c **** /* offsets from base */
 101:flash/cfi_flash.c **** enum flash_offset {
 102:flash/cfi_flash.c **** 	CFI_OFFSET_MANUFACTURER_ID = 0x00,
 103:flash/cfi_flash.c **** 	CFI_OFFSET_DEVICE_ID = 0x01,
 104:flash/cfi_flash.c **** 	CFI_OFFSET_EXT_DEVICE_ID1 = 0x0E,
 105:flash/cfi_flash.c **** 	CFI_OFFSET_EXT_DEVICE_ID2 = 0x0F,
 106:flash/cfi_flash.c **** 	CFI_OFFSET_INTEL_PROTECTION = 0x81,
 107:flash/cfi_flash.c **** 	CFI_OFFSET_CFI_RESP = 0x10
 108:flash/cfi_flash.c **** };
 109:flash/cfi_flash.c **** 
 110:flash/cfi_flash.c **** /* offsets from block base */
 111:flash/cfi_flash.c **** enum flash_block_offset {
 112:flash/cfi_flash.c **** 	CFI_OFFSET_BLOCK_LOCKSTATE = 0x02
 113:flash/cfi_flash.c **** };
 114:flash/cfi_flash.c **** 
 115:flash/cfi_flash.c **** /* status masks */
 116:flash/cfi_flash.c **** enum flash_status {
 117:flash/cfi_flash.c **** 	CFI_STATUS_READY = 0x80,
 118:flash/cfi_flash.c **** 	CFI_STATUS_ERASE_SUSPENDED = 0x40,
 119:flash/cfi_flash.c **** 	CFI_STATUS_ERASE_ERROR = 0x20,
 120:flash/cfi_flash.c **** 	CFI_STATUS_PROGRAM_ERROR = 0x10,
 121:flash/cfi_flash.c **** 	CFI_STATUS_VPP_LOW = 0x08,
 122:flash/cfi_flash.c **** 	CFI_STATUS_PROGRAM_SUSPENDED = 0x04,
 123:flash/cfi_flash.c **** 	CFI_STATUS_LOCKED_ERROR = 0x02,
 124:flash/cfi_flash.c **** 	CFI_STATUS_RESERVED = 0x01
 125:flash/cfi_flash.c **** };
 126:flash/cfi_flash.c **** 
 127:flash/cfi_flash.c **** #define CFI_CMD_ADDR1			0xAAA
 128:flash/cfi_flash.c **** #define CFI_CMD_ADDR2			0x555
 129:flash/cfi_flash.c **** 
 130:flash/cfi_flash.c **** __ramtext
 131:flash/cfi_flash.c **** static inline void flash_write_cmd(const void *base_addr, uint16_t cmd)
 132:flash/cfi_flash.c **** {
 133:flash/cfi_flash.c **** 	writew(cmd, base_addr);
 134:flash/cfi_flash.c **** }
 135:flash/cfi_flash.c **** 
 136:flash/cfi_flash.c **** __ramtext
 137:flash/cfi_flash.c **** static inline uint16_t flash_read16(const void *base_addr, uint32_t offset)
 138:flash/cfi_flash.c **** {
 139:flash/cfi_flash.c **** 	return readw(base_addr + (offset << 1));
 140:flash/cfi_flash.c **** }
 141:flash/cfi_flash.c **** 
 142:flash/cfi_flash.c **** __ramtext
 143:flash/cfi_flash.c **** static char flash_protected(uint32_t block_offset)
 144:flash/cfi_flash.c **** {
 145:flash/cfi_flash.c **** #ifdef CONFIG_FLASH_WRITE
 146:flash/cfi_flash.c **** #  ifdef CONFIG_FLASH_WRITE_LOADER
 147:flash/cfi_flash.c **** 	return 0;
 148:flash/cfi_flash.c **** #  else
 149:flash/cfi_flash.c **** 	return block_offset <= 0xFFFF;
 150:flash/cfi_flash.c **** #  endif
 151:flash/cfi_flash.c **** #else
 152:flash/cfi_flash.c **** 	return 1;
 153:flash/cfi_flash.c **** #endif
 154:flash/cfi_flash.c **** }
 155:flash/cfi_flash.c **** 
 156:flash/cfi_flash.c **** __ramtext
 157:flash/cfi_flash.c **** flash_lock_t flash_block_getlock(flash_t * flash, uint32_t block_offset)
 158:flash/cfi_flash.c **** {
 159:flash/cfi_flash.c **** 	const void *base_addr = flash->f_base;
 160:flash/cfi_flash.c **** 
 161:flash/cfi_flash.c **** 	uint8_t lockstate;
 162:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_READ_ID);
 163:flash/cfi_flash.c **** 	lockstate =
 164:flash/cfi_flash.c **** 		flash_read16(base_addr,
 165:flash/cfi_flash.c **** 			     (block_offset >> 1) + CFI_OFFSET_BLOCK_LOCKSTATE);
 166:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 167:flash/cfi_flash.c **** 
 168:flash/cfi_flash.c **** 	if (lockstate & 0x2) {
 169:flash/cfi_flash.c **** 		return FLASH_LOCKED_DOWN;
 170:flash/cfi_flash.c **** 	} else if (lockstate & 0x01) {
 171:flash/cfi_flash.c **** 		return FLASH_LOCKED;
 172:flash/cfi_flash.c **** 	} else {
 173:flash/cfi_flash.c **** 		return FLASH_UNLOCKED;
 174:flash/cfi_flash.c **** 	}
 175:flash/cfi_flash.c **** }
 176:flash/cfi_flash.c **** 
 177:flash/cfi_flash.c **** __ramtext
 178:flash/cfi_flash.c **** int flash_block_unlock(flash_t * flash, uint32_t block_offset)
 179:flash/cfi_flash.c **** {
 180:flash/cfi_flash.c **** 	const void *base_addr = flash->f_base;
 181:flash/cfi_flash.c **** 
 182:flash/cfi_flash.c **** 	if (block_offset >= flash->f_size) {
 183:flash/cfi_flash.c **** 		return -EINVAL;
 184:flash/cfi_flash.c **** 	}
 185:flash/cfi_flash.c **** 
 186:flash/cfi_flash.c **** 	if (flash_protected(block_offset)) {
 187:flash/cfi_flash.c **** 		return -EPERM;
 188:flash/cfi_flash.c **** 	}
 189:flash/cfi_flash.c **** 
 190:flash/cfi_flash.c **** 	printf("Unlocking block at 0x%08lx, meaning %p\n",
 191:flash/cfi_flash.c **** 		   block_offset, base_addr + block_offset);
 192:flash/cfi_flash.c **** 
 193:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_PROTECT);
 194:flash/cfi_flash.c **** 	flash_write_cmd(base_addr + block_offset, CFI_PROT_UNLOCK);
 195:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 196:flash/cfi_flash.c **** 
 197:flash/cfi_flash.c **** 	return 0;
 198:flash/cfi_flash.c **** }
 199:flash/cfi_flash.c **** 
 200:flash/cfi_flash.c **** __ramtext
 201:flash/cfi_flash.c **** int flash_block_lock(flash_t * flash, uint32_t block_offset)
 202:flash/cfi_flash.c **** {
  21              		.loc 1 202 0
  22              		@ args = 0, pretend = 0, frame = 0
  23              		@ frame_needed = 0, uses_anonymous_args = 0
  24              	.LVL0:
  25 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
  26              	.LCFI0:
 203:flash/cfi_flash.c **** 	const void *base_addr = flash->f_base;
 204:flash/cfi_flash.c **** 
 205:flash/cfi_flash.c **** 	if (block_offset >= flash->f_size) {
  27              		.loc 1 205 0
  28 0004 043090E5 		ldr	r3, [r0, #4]
  29              		.loc 1 202 0
  30 0008 0020A0E1 		mov	r2, r0
  31              		.loc 1 205 0
  32 000c 030051E1 		cmp	r1, r3
  33              		.loc 1 202 0
  34 0010 0150A0E1 		mov	r5, r1
 206:flash/cfi_flash.c **** 		return -EINVAL;
 207:flash/cfi_flash.c **** 	}
 208:flash/cfi_flash.c **** 
 209:flash/cfi_flash.c **** 	printf("Locking block at 0x%08lx\n", block_offset);
  35              		.loc 1 209 0
  36 0014 30009FE5 		ldr	r0, .L6
  37              	.LVL1:
  38              		.loc 1 205 0
  39 0018 1530E0E3 		mvn	r3, #21
  40              		.loc 1 203 0
  41 001c 004092E5 		ldr	r4, [r2, #0]
  42              	.LVL2:
  43              		.loc 1 205 0
  44 0020 0F00002A 		bcs	.L4
  45              	.LVL3:
  46              		.loc 1 209 0
  47 0024 FEFFFFEB 		bl	printf
  48              	.LVL4:
  49              	.LBB2:
  50              	.LBB3:
  51              		.loc 1 133 0
  52 0028 6030A0E3 		mov	r3, #96	@ movhi
  53 002c B030C4E1 		strh	r3, [r4, #0]	@ movhi
  54              	.LBE3:
  55              	.LBE2:
  56              	.LBB4:
  57              	.LBB5:
  58 0030 0130A0E3 		mov	r3, #1	@ movhi
  59 0034 B53084E1 		strh	r3, [r4, r5]	@ movhi
  60              	.LBE5:
  61              	.LBE4:
  62              	.LBB6:
  63              	.LBB7:
  64 0038 FF30A0E3 		mov	r3, #255	@ movhi
  65 003c B030C4E1 		strh	r3, [r4, #0]	@ movhi
  66 0040 0030A0E3 		mov	r3, #0
  67              	.LVL5:
  68              	.L4:
  69              	.LBE7:
  70              	.LBE6:
 210:flash/cfi_flash.c **** 
 211:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_PROTECT);
 212:flash/cfi_flash.c **** 	flash_write_cmd(base_addr + block_offset, CFI_PROT_LOCK);
 213:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 214:flash/cfi_flash.c **** 
 215:flash/cfi_flash.c **** 	return 0;
 216:flash/cfi_flash.c **** }
  71              		.loc 1 216 0
  72 0044 0300A0E1 		mov	r0, r3
  73 0048 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
  74              	.L7:
  75              		.align	2
  76              	.L6:
  77 004c 00000000 		.word	.LC0
  78              	.LFE7:
  80              		.section	.rodata.str1.4
  81 001a 0000     		.align	2
  82              	.LC1:
  83 001c 4C6F636B 		.ascii	"Locking down block at 0x%08lx\012\000"
  83      696E6720 
  83      646F776E 
  83      20626C6F 
  83      636B2061 
  84 003b 00       		.section	.ramtext
  85              		.align	2
  86              		.global	flash_block_lockdown
  88              	flash_block_lockdown:
  89              	.LFB8:
 217:flash/cfi_flash.c **** 
 218:flash/cfi_flash.c **** __ramtext
 219:flash/cfi_flash.c **** int flash_block_lockdown(flash_t * flash, uint32_t block_offset)
 220:flash/cfi_flash.c **** {
  90              		.loc 1 220 0
  91              		@ args = 0, pretend = 0, frame = 0
  92              		@ frame_needed = 0, uses_anonymous_args = 0
  93              	.LVL6:
  94 0050 30402DE9 		stmfd	sp!, {r4, r5, lr}
  95              	.LCFI1:
 221:flash/cfi_flash.c **** 	const void *base_addr = flash->f_base;
 222:flash/cfi_flash.c **** 
 223:flash/cfi_flash.c **** 	if (block_offset >= flash->f_size) {
  96              		.loc 1 223 0
  97 0054 043090E5 		ldr	r3, [r0, #4]
  98              		.loc 1 220 0
  99 0058 0020A0E1 		mov	r2, r0
 100              		.loc 1 223 0
 101 005c 030051E1 		cmp	r1, r3
 102              		.loc 1 220 0
 103 0060 0150A0E1 		mov	r5, r1
 224:flash/cfi_flash.c **** 		return -EINVAL;
 225:flash/cfi_flash.c **** 	}
 226:flash/cfi_flash.c **** 
 227:flash/cfi_flash.c **** 	printf("Locking down block at 0x%08lx\n", block_offset);
 104              		.loc 1 227 0
 105 0064 30009FE5 		ldr	r0, .L13
 106              	.LVL7:
 107              		.loc 1 223 0
 108 0068 1530E0E3 		mvn	r3, #21
 109              		.loc 1 221 0
 110 006c 004092E5 		ldr	r4, [r2, #0]
 111              	.LVL8:
 112              		.loc 1 223 0
 113 0070 2300002A 		bcs	.L11
 114              	.LVL9:
 115              		.loc 1 227 0
 116 0074 FEFFFFEB 		bl	printf
 117              	.LVL10:
 118              	.LBB8:
 119              	.LBB9:
 120              		.loc 1 133 0
 121 0078 6030A0E3 		mov	r3, #96	@ movhi
 122 007c B030C4E1 		strh	r3, [r4, #0]	@ movhi
 123              	.LBE9:
 124              	.LBE8:
 125              	.LBB10:
 126              	.LBB11:
 127 0080 2F30A0E3 		mov	r3, #47	@ movhi
 128 0084 B53084E1 		strh	r3, [r4, r5]	@ movhi
 129              	.LBE11:
 130              	.LBE10:
 131              	.LBB12:
 132              	.LBB13:
 133 0088 FF30A0E3 		mov	r3, #255	@ movhi
 134 008c B030C4E1 		strh	r3, [r4, #0]	@ movhi
 135 0090 0030A0E3 		mov	r3, #0
 136              	.LVL11:
 137              	.L11:
 138              	.LBE13:
 139              	.LBE12:
 228:flash/cfi_flash.c **** 
 229:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_PROTECT);
 230:flash/cfi_flash.c **** 	flash_write_cmd(base_addr + block_offset, CFI_PROT_LOCKDOWN);
 231:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 232:flash/cfi_flash.c **** 
 233:flash/cfi_flash.c **** 	return 0;
 234:flash/cfi_flash.c **** }
 140              		.loc 1 234 0
 141 0094 0300A0E1 		mov	r0, r3
 142 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 143              	.L14:
 144              		.align	2
 145              	.L13:
 146 009c 1C000000 		.word	.LC1
 147              	.LFE8:
 149              		.align	2
 150              		.global	flash_block_getlock
 152              	flash_block_getlock:
 153              	.LFB5:
 154              		.loc 1 158 0
 155              		@ args = 0, pretend = 0, frame = 0
 156              		@ frame_needed = 0, uses_anonymous_args = 0
 157              		@ link register save eliminated.
 158              	.LVL12:
 159              		.loc 1 159 0
 160 00a0 003090E5 		ldr	r3, [r0, #0]
 161              	.LVL13:
 162              	.LBB14:
 163              	.LBB15:
 164              		.loc 1 133 0
 165 00a4 9020A0E3 		mov	r2, #144	@ movhi
 166 00a8 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 167              	.LBE15:
 168              	.LBE14:
 169              	.LBB16:
 170              	.LBB17:
 171              		.loc 1 139 0
 172 00ac 0110C1E3 		bic	r1, r1, #1
 173              	.LVL14:
 174 00b0 041081E2 		add	r1, r1, #4
 175 00b4 B12093E1 		ldrh	r2, [r3, r1]
 176              	.LBE17:
 177              	.LBE16:
 178              		.loc 1 168 0
 179 00b8 020012E3 		tst	r2, #2
 180 00bc 0200A0E3 		mov	r0, #2
 181              	.LVL15:
 182              	.LBB18:
 183              	.LBB19:
 184              		.loc 1 133 0
 185 00c0 FF10A0E3 		mov	r1, #255	@ movhi
 186              	.LBE19:
 187              	.LBE18:
 188              		.loc 1 170 0
 189 00c4 01000202 		andeq	r0, r2, #1
 190              		.loc 1 158 0
 191              		@ lr needed for prologue
 192              	.LBB20:
 193              	.LBB21:
 194              		.loc 1 133 0
 195 00c8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
 196              	.LBE21:
 197              	.LBE20:
 198              		.loc 1 175 0
 199 00cc 1EFF2FE1 		bx	lr
 200              	.LFE5:
 202              		.align	2
 203              		.global	flash_program
 205              	flash_program:
 206              	.LFB10:
 235:flash/cfi_flash.c **** 
 236:flash/cfi_flash.c **** __ramtext
 237:flash/cfi_flash.c **** int flash_block_erase(flash_t * flash, uint32_t block_offset)
 238:flash/cfi_flash.c **** {
 239:flash/cfi_flash.c **** 	const void *base_addr = flash->f_base;
 240:flash/cfi_flash.c **** 
 241:flash/cfi_flash.c **** 	if (block_offset >= flash->f_size) {
 242:flash/cfi_flash.c **** 		return -EINVAL;
 243:flash/cfi_flash.c **** 	}
 244:flash/cfi_flash.c **** 
 245:flash/cfi_flash.c **** 	if (flash_protected(block_offset)) {
 246:flash/cfi_flash.c **** 		return -EPERM;
 247:flash/cfi_flash.c **** 	}
 248:flash/cfi_flash.c **** 
 249:flash/cfi_flash.c **** 	printf("Erasing block 0x%08lx...", block_offset);
 250:flash/cfi_flash.c **** 
 251:flash/cfi_flash.c **** 	void *block_addr = ((uint8_t *) base_addr) + block_offset;
 252:flash/cfi_flash.c **** 
 253:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_CLEAR_STATUS);
 254:flash/cfi_flash.c **** 
 255:flash/cfi_flash.c **** 	flash_write_cmd(block_addr, CFI_CMD_BLOCK_ERASE);
 256:flash/cfi_flash.c **** 	flash_write_cmd(block_addr, CFI_CMD_ERASE_CONFIRM);
 257:flash/cfi_flash.c **** 
 258:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_READ_STATUS);
 259:flash/cfi_flash.c **** 	uint16_t status;
 260:flash/cfi_flash.c **** 	do {
 261:flash/cfi_flash.c **** 		status = flash_read16(base_addr, 0);
 262:flash/cfi_flash.c **** 	} while (!(status & CFI_STATUS_READY));
 263:flash/cfi_flash.c **** 
 264:flash/cfi_flash.c **** 	int res = 0;
 265:flash/cfi_flash.c **** 	if (status & CFI_STATUS_ERASE_ERROR) {
 266:flash/cfi_flash.c **** 		puts("error: ");
 267:flash/cfi_flash.c **** 		if (status & CFI_STATUS_VPP_LOW) {
 268:flash/cfi_flash.c **** 			puts("vpp insufficient\n");
 269:flash/cfi_flash.c **** 			res = -EFAULT;
 270:flash/cfi_flash.c **** 		} else if (status & CFI_STATUS_LOCKED_ERROR) {
 271:flash/cfi_flash.c **** 			puts("block is lock-protected\n");
 272:flash/cfi_flash.c **** 			res = -EPERM;
 273:flash/cfi_flash.c **** 		} else {
 274:flash/cfi_flash.c **** 			puts("unknown fault\n");
 275:flash/cfi_flash.c **** 			res = -EFAULT;
 276:flash/cfi_flash.c **** 		}
 277:flash/cfi_flash.c **** 	} else {
 278:flash/cfi_flash.c **** 		puts("done\n");
 279:flash/cfi_flash.c **** 	}
 280:flash/cfi_flash.c **** 
 281:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 282:flash/cfi_flash.c **** 
 283:flash/cfi_flash.c **** 	return res;
 284:flash/cfi_flash.c **** 
 285:flash/cfi_flash.c **** }
 286:flash/cfi_flash.c **** 
 287:flash/cfi_flash.c **** __ramtext
 288:flash/cfi_flash.c **** int flash_program(flash_t * flash, uint32_t dst, void *src, uint32_t nbytes)
 289:flash/cfi_flash.c **** {
 207              		.loc 1 289 0
 208              		@ args = 0, pretend = 0, frame = 0
 209              		@ frame_needed = 0, uses_anonymous_args = 0
 210              		@ link register save eliminated.
 211              	.LVL16:
 290:flash/cfi_flash.c **** 	const void *base_addr = flash->f_base;
 291:flash/cfi_flash.c **** 	int res = 0;
 292:flash/cfi_flash.c **** 	uint32_t i;
 293:flash/cfi_flash.c **** 
 294:flash/cfi_flash.c **** 	/* check destination bounds */
 295:flash/cfi_flash.c **** 	if (dst >= flash->f_size) {
 212              		.loc 1 295 0
 213 00d0 04C090E5 		ldr	ip, [r0, #4]
 214 00d4 0C0051E1 		cmp	r1, ip
 215              		.loc 1 289 0
 216              		@ lr needed for prologue
 296:flash/cfi_flash.c **** 		return -EINVAL;
 297:flash/cfi_flash.c **** 	}
 298:flash/cfi_flash.c **** 	if (dst + nbytes > flash->f_size) {
 217              		.loc 1 298 0
 218 00d8 030081E0 		add	r0, r1, r3
 219              	.LVL17:
 220              		.loc 1 295 0
 221 00dc 3F00002A 		bcs	.L23
 222              		.loc 1 298 0
 223 00e0 0C0050E1 		cmp	r0, ip
 224 00e4 3F00008A 		bhi	.L23
 299:flash/cfi_flash.c **** 		return -EINVAL;
 300:flash/cfi_flash.c **** 	}
 301:flash/cfi_flash.c **** 
 302:flash/cfi_flash.c **** 	/* check alignments */
 303:flash/cfi_flash.c **** 	if (((uint32_t) src) % 2) {
 225              		.loc 1 303 0
 226 00e8 010012E3 		tst	r2, #1
 227 00ec 3F00001A 		bne	.L23
 304:flash/cfi_flash.c **** 		return -EINVAL;
 305:flash/cfi_flash.c **** 	}
 306:flash/cfi_flash.c **** 	if (dst % 2) {
 228              		.loc 1 306 0
 229 00f0 010011E3 		tst	r1, #1
 230 00f4 3F00001A 		bne	.L23
 307:flash/cfi_flash.c **** 		return -EINVAL;
 308:flash/cfi_flash.c **** 	}
 309:flash/cfi_flash.c **** 	if (nbytes % 2) {
 231              		.loc 1 309 0
 232 00f8 010013E3 		tst	r3, #1
 233 00fc 0000E0E3 		mvn	r0, #0
 234              	.LVL18:
 235 0100 1EFF2F01 		bxeq	lr
 236              	.L23:
 237 0104 1500E0E3 		mvn	r0, #21
 238              	.LVL19:
 310:flash/cfi_flash.c **** 		return -EINVAL;
 311:flash/cfi_flash.c **** 	}
 312:flash/cfi_flash.c **** 
 313:flash/cfi_flash.c **** 	/* check permissions */
 314:flash/cfi_flash.c **** 	if (flash_protected(dst)) {
 315:flash/cfi_flash.c **** 		return -EPERM;
 316:flash/cfi_flash.c **** 	}
 317:flash/cfi_flash.c **** 
 318:flash/cfi_flash.c **** 	/* say something */
 319:flash/cfi_flash.c **** 	printf("Programming %lu bytes to 0x%08lx from 0x%p...", nbytes, dst, src);
 320:flash/cfi_flash.c **** 
 321:flash/cfi_flash.c **** 	/* clear status register */
 322:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_CLEAR_STATUS);
 323:flash/cfi_flash.c **** 
 324:flash/cfi_flash.c **** 	/* write the words */
 325:flash/cfi_flash.c **** 	puts("writing...");
 326:flash/cfi_flash.c **** 	for (i = 0; i < nbytes; i += 2) {
 327:flash/cfi_flash.c **** 		uint16_t *src_addr = (uint16_t *) (src + i);
 328:flash/cfi_flash.c **** 		uint16_t *dst_addr = (uint16_t *) (base_addr + dst + i);
 329:flash/cfi_flash.c **** 
 330:flash/cfi_flash.c **** 		uint16_t data = *src_addr;
 331:flash/cfi_flash.c **** 
 332:flash/cfi_flash.c **** 		flash_write_cmd(dst_addr, CFI_CMD_WRITE);
 333:flash/cfi_flash.c **** 		flash_write_cmd(dst_addr, data);
 334:flash/cfi_flash.c **** 
 335:flash/cfi_flash.c **** 		flash_write_cmd(base_addr, CFI_CMD_READ_STATUS);
 336:flash/cfi_flash.c **** 		uint16_t status;
 337:flash/cfi_flash.c **** 		do {
 338:flash/cfi_flash.c **** 			status = flash_read16(base_addr, 0);
 339:flash/cfi_flash.c **** 		} while (!(status & CFI_STATUS_READY));
 340:flash/cfi_flash.c **** 
 341:flash/cfi_flash.c **** 		if (status & CFI_STATUS_PROGRAM_ERROR) {
 342:flash/cfi_flash.c **** 			puts("error: ");
 343:flash/cfi_flash.c **** 			if (status & CFI_STATUS_VPP_LOW) {
 344:flash/cfi_flash.c **** 				puts("vpp insufficient");
 345:flash/cfi_flash.c **** 				res = -EFAULT;
 346:flash/cfi_flash.c **** 			} else if (status & CFI_STATUS_LOCKED_ERROR) {
 347:flash/cfi_flash.c **** 				puts("block is lock-protected");
 348:flash/cfi_flash.c **** 				res = -EPERM;
 349:flash/cfi_flash.c **** 			} else {
 350:flash/cfi_flash.c **** 				puts("unknown fault");
 351:flash/cfi_flash.c **** 				res = -EFAULT;
 352:flash/cfi_flash.c **** 			}
 353:flash/cfi_flash.c **** 			goto err_reset;
 354:flash/cfi_flash.c **** 		}
 355:flash/cfi_flash.c **** 	}
 356:flash/cfi_flash.c **** 
 357:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 358:flash/cfi_flash.c **** 
 359:flash/cfi_flash.c **** 	/* verify the result */
 360:flash/cfi_flash.c **** 	puts("verifying...");
 361:flash/cfi_flash.c **** 	for (i = 0; i < nbytes; i += 2) {
 362:flash/cfi_flash.c **** 		uint16_t *src_addr = (uint16_t *) (src + i);
 363:flash/cfi_flash.c **** 		uint16_t *dst_addr = (uint16_t *) (base_addr + dst + i);
 364:flash/cfi_flash.c **** 		if (*src_addr != *dst_addr) {
 365:flash/cfi_flash.c **** 			puts("error: verification failed");
 366:flash/cfi_flash.c **** 			res = -EFAULT;
 367:flash/cfi_flash.c **** 			goto err;
 368:flash/cfi_flash.c **** 		}
 369:flash/cfi_flash.c **** 	}
 370:flash/cfi_flash.c **** 
 371:flash/cfi_flash.c **** 	puts("done\n");
 372:flash/cfi_flash.c **** 
 373:flash/cfi_flash.c **** 	return res;
 374:flash/cfi_flash.c **** 
 375:flash/cfi_flash.c ****  err_reset:
 376:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 377:flash/cfi_flash.c **** 
 378:flash/cfi_flash.c ****  err:
 379:flash/cfi_flash.c **** 	printf(" at offset 0x%lx\n", i);
 380:flash/cfi_flash.c **** 
 381:flash/cfi_flash.c **** 	return res;
 382:flash/cfi_flash.c **** }
 239              		.loc 1 382 0
 240 0108 1EFF2FE1 		bx	lr
 241              	.LFE10:
 243              		.align	2
 244              		.global	flash_get_id
 246              	flash_get_id:
 247              	.LFB11:
 383:flash/cfi_flash.c **** 
 384:flash/cfi_flash.c **** /* retrieve manufacturer and extended device id from id space */
 385:flash/cfi_flash.c **** __ramtext
 386:flash/cfi_flash.c **** int flash_get_id(void *base_addr,
 387:flash/cfi_flash.c **** 		  uint16_t * manufacturer_id, uint16_t * device_id)
 388:flash/cfi_flash.c **** {
 248              		.loc 1 388 0
 249              		@ args = 0, pretend = 0, frame = 0
 250              		@ frame_needed = 0, uses_anonymous_args = 0
 251              	.LVL20:
 389:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET_TO_READ_MODE);
 390:flash/cfi_flash.c **** 
 391:flash/cfi_flash.c **** 	flash_write_cmd(base_addr + CFI_CMD_ADDR1, CFI_CMD_UNLOCK1);
 252              		.loc 1 391 0
 253 010c 60C09FE5 		ldr	ip, .L37
 254              	.LBB22:
 255              	.LBB23:
 256              		.loc 1 133 0
 257 0110 F030A0E3 		mov	r3, #240	@ movhi
 258              	.LBE23:
 259              	.LBE22:
 260              		.loc 1 388 0
 261 0114 04E02DE5 		str	lr, [sp, #-4]!
 262              	.LCFI2:
 263              	.LBB24:
 264              	.LBB25:
 265              		.loc 1 133 0
 266 0118 B030C0E1 		strh	r3, [r0, #0]	@ movhi
 267              	.LBE25:
 268              	.LBE24:
 269              	.LBB26:
 270              	.LBB27:
 271 011c AAE0A0E3 		mov	lr, #170	@ movhi
 272              	.LBE27:
 273              	.LBE26:
 274              	.LBB28:
 275              	.LBB29:
 276 0120 50309FE5 		ldr	r3, .L37+4
 277              	.LBE29:
 278              	.LBE28:
 279              	.LBB30:
 280              	.LBB31:
 281 0124 BCE080E1 		strh	lr, [r0, ip]	@ movhi
 282              	.LBE31:
 283              	.LBE30:
 284              	.LBB32:
 285              	.LBB33:
 286 0128 55E0A0E3 		mov	lr, #85	@ movhi
 287 012c B3E080E1 		strh	lr, [r0, r3]	@ movhi
 288              	.LBE33:
 289              	.LBE32:
 290              	.LBB34:
 291              	.LBB35:
 292 0130 9030A0E3 		mov	r3, #144	@ movhi
 293 0134 BC3080E1 		strh	r3, [r0, ip]	@ movhi
 294              	.LBE35:
 295              	.LBE34:
 392:flash/cfi_flash.c **** 	flash_write_cmd(base_addr + CFI_CMD_ADDR2, CFI_CMD_UNLOCK2);
 393:flash/cfi_flash.c **** 	flash_write_cmd(base_addr + CFI_CMD_ADDR1, CFI_CMD_READ_ID);
 394:flash/cfi_flash.c **** 
 395:flash/cfi_flash.c **** 	if (manufacturer_id)
 296              		.loc 1 395 0
 297 0138 000051E3 		cmp	r1, #0
 298              	.LBB36:
 299              	.LBB37:
 300              		.loc 1 139 0
 301 013c B030D011 		ldrneh	r3, [r0, #0]
 302              	.LBE37:
 303              	.LBE36:
 396:flash/cfi_flash.c **** 		*manufacturer_id = flash_read16(base_addr, CFI_OFFSET_MANUFACTURER_ID);
 304              		.loc 1 396 0
 305 0140 B030C111 		strneh	r3, [r1, #0]	@ movhi
 397:flash/cfi_flash.c **** 
 398:flash/cfi_flash.c **** 	if (device_id) {
 306              		.loc 1 398 0
 307 0144 000052E3 		cmp	r2, #0
 308 0148 5700000A 		beq	.L34
 309              	.LBB38:
 310              	.LBB39:
 311              		.loc 1 139 0
 312 014c B230D0E1 		ldrh	r3, [r0, #2]
 313              	.LBE39:
 314              	.LBE38:
 399:flash/cfi_flash.c **** 		device_id[0] = flash_read16(base_addr, CFI_OFFSET_DEVICE_ID);
 315              		.loc 1 399 0
 316 0150 B030C2E1 		strh	r3, [r2, #0]	@ movhi
 317              	.LBB40:
 318              	.LBB41:
 319              		.loc 1 139 0
 320 0154 BC31D0E1 		ldrh	r3, [r0, #28]
 321              	.LBE41:
 322              	.LBE40:
 400:flash/cfi_flash.c **** 		device_id[1] = flash_read16(base_addr, CFI_OFFSET_EXT_DEVICE_ID1);
 323              		.loc 1 400 0
 324 0158 B230C2E1 		strh	r3, [r2, #2]	@ movhi
 325              	.LBB42:
 326              	.LBB43:
 327              		.loc 1 139 0
 328 015c BE31D0E1 		ldrh	r3, [r0, #30]
 329              	.LBE43:
 330              	.LBE42:
 401:flash/cfi_flash.c **** 		device_id[2] = flash_read16(base_addr, CFI_OFFSET_EXT_DEVICE_ID2);
 331              		.loc 1 401 0
 332 0160 B430C2E1 		strh	r3, [r2, #4]	@ movhi
 333              	.L34:
 334              	.LBB44:
 335              	.LBB45:
 336              		.loc 1 133 0
 337 0164 F0E0A0E3 		mov	lr, #240	@ movhi
 338 0168 B0E0C0E1 		strh	lr, [r0, #0]	@ movhi
 339              	.LBE45:
 340              	.LBE44:
 402:flash/cfi_flash.c **** 	}
 403:flash/cfi_flash.c **** 
 404:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET_TO_READ_MODE);
 405:flash/cfi_flash.c **** 
 406:flash/cfi_flash.c **** 	return 0;
 407:flash/cfi_flash.c **** }
 341              		.loc 1 407 0
 342 016c 0000A0E3 		mov	r0, #0
 343              	.LVL21:
 344 0170 04F09DE4 		ldr	pc, [sp], #4
 345              	.L38:
 346              		.align	2
 347              	.L37:
 348 0174 AA0A0000 		.word	2730
 349 0178 55050000 		.word	1365
 350              	.LFE11:
 352              		.align	2
 353              		.global	flash_init
 355              	flash_init:
 356              	.LFB13:
 408:flash/cfi_flash.c **** 
 409:flash/cfi_flash.c **** /* Internal: retrieve cfi query response data */
 410:flash/cfi_flash.c **** __ramtext
 411:flash/cfi_flash.c **** static int get_query(void *base_addr, struct cfi_query *query)
 412:flash/cfi_flash.c **** {
 413:flash/cfi_flash.c **** 	int res = 0;
 414:flash/cfi_flash.c **** 	unsigned int i;
 415:flash/cfi_flash.c **** 
 416:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_CFI);
 417:flash/cfi_flash.c **** 
 418:flash/cfi_flash.c **** 	for (i = 0; i < sizeof(struct cfi_query); i++) {
 419:flash/cfi_flash.c **** 		uint16_t byte =
 420:flash/cfi_flash.c **** 			flash_read16(base_addr, CFI_OFFSET_CFI_RESP + i);
 421:flash/cfi_flash.c **** 		*(((volatile unsigned char *)query) + i) = byte;
 422:flash/cfi_flash.c **** 	}
 423:flash/cfi_flash.c **** 
 424:flash/cfi_flash.c **** 	if (query->qry[0] != 'Q' || query->qry[1] != 'R' || query->qry[2] != 'Y') {
 425:flash/cfi_flash.c **** 		res = -ENOENT;
 426:flash/cfi_flash.c **** 	}
 427:flash/cfi_flash.c **** 
 428:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 429:flash/cfi_flash.c **** 
 430:flash/cfi_flash.c **** 	return res;
 431:flash/cfi_flash.c **** }
 432:flash/cfi_flash.c **** 
 433:flash/cfi_flash.c **** #if 0
 434:flash/cfi_flash.c **** 
 435:flash/cfi_flash.c **** /* Internal: retrieve intel protection data */
 436:flash/cfi_flash.c **** __ramtext
 437:flash/cfi_flash.c **** static int get_intel_protection(void *base_addr,
 438:flash/cfi_flash.c **** 				uint16_t * lockp, uint8_t protp[8])
 439:flash/cfi_flash.c **** {
 440:flash/cfi_flash.c **** 	int i;
 441:flash/cfi_flash.c **** 
 442:flash/cfi_flash.c **** 	/* check args */
 443:flash/cfi_flash.c **** 	if (!lockp) {
 444:flash/cfi_flash.c **** 		return -EINVAL;
 445:flash/cfi_flash.c **** 	}
 446:flash/cfi_flash.c **** 	if (!protp) {
 447:flash/cfi_flash.c **** 		return -EINVAL;
 448:flash/cfi_flash.c **** 	}
 449:flash/cfi_flash.c **** 
 450:flash/cfi_flash.c **** 	/* enter read id mode */
 451:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_READ_ID);
 452:flash/cfi_flash.c **** 
 453:flash/cfi_flash.c **** 	/* get lock */
 454:flash/cfi_flash.c **** 	*lockp = flash_read16(base_addr, CFI_OFFSET_INTEL_PROTECTION);
 455:flash/cfi_flash.c **** 
 456:flash/cfi_flash.c **** 	/* get data */
 457:flash/cfi_flash.c **** 	for (i = 0; i < 8; i++) {
 458:flash/cfi_flash.c **** 		protp[i] = flash_read16(base_addr, CFI_OFFSET_INTEL_PROTECTION + 1 + i);
 459:flash/cfi_flash.c **** 	}
 460:flash/cfi_flash.c **** 
 461:flash/cfi_flash.c **** 	/* leave read id mode */
 462:flash/cfi_flash.c **** 	flash_write_cmd(base_addr, CFI_CMD_RESET);
 463:flash/cfi_flash.c **** 
 464:flash/cfi_flash.c **** 	return 0;
 465:flash/cfi_flash.c **** }
 466:flash/cfi_flash.c **** 
 467:flash/cfi_flash.c **** static void dump_intel_protection(uint16_t lock, uint8_t data[8])
 468:flash/cfi_flash.c **** {
 469:flash/cfi_flash.c **** 	printf
 470:flash/cfi_flash.c **** 		("  protection lock 0x%4.4x data 0x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\n",
 471:flash/cfi_flash.c **** 		 lock, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]);
 472:flash/cfi_flash.c **** }
 473:flash/cfi_flash.c **** 
 474:flash/cfi_flash.c **** static void dump_query_algorithms(struct cfi_query *qry)
 475:flash/cfi_flash.c **** {
 476:flash/cfi_flash.c **** 	printf("  primary algorithm 0x%4.4x\n", qry->p_id);
 477:flash/cfi_flash.c **** 	printf("  primary extended query 0x%4.4x\n", qry->p_adr);
 478:flash/cfi_flash.c **** 	printf("  alternate algorithm 0x%4.4x\n", qry->a_id);
 479:flash/cfi_flash.c **** 	printf("  alternate extended query 0x%4.4x\n", qry->a_adr);
 480:flash/cfi_flash.c **** }
 481:flash/cfi_flash.c **** 
 482:flash/cfi_flash.c **** static void dump_query_timing(struct cfi_query *qry)
 483:flash/cfi_flash.c **** {
 484:flash/cfi_flash.c **** 	uint32_t block_erase_typ = 1 << qry->block_erase_timeout_typ;
 485:flash/cfi_flash.c **** 	uint32_t block_erase_max =
 486:flash/cfi_flash.c **** 		(1 << qry->block_erase_timeout_max) * block_erase_typ;
 487:flash/cfi_flash.c **** 	uint32_t word_program_typ = 1 << qry->word_write_timeout_typ;
 488:flash/cfi_flash.c **** 	uint32_t word_program_max =
 489:flash/cfi_flash.c **** 		(1 << qry->word_write_timeout_max) * word_program_typ;
 490:flash/cfi_flash.c **** 	printf("  block erase typ %u ms\n", block_erase_typ);
 491:flash/cfi_flash.c **** 	printf("  block erase max %u ms\n", block_erase_max);
 492:flash/cfi_flash.c **** 	printf("  word program typ %u us\n", word_program_typ);
 493:flash/cfi_flash.c **** 	printf("  word program max %u us\n", word_program_max);
 494:flash/cfi_flash.c **** }
 495:flash/cfi_flash.c **** 
 496:flash/cfi_flash.c **** void flash_dump_info(flash_t * flash)
 497:flash/cfi_flash.c **** {
 498:flash/cfi_flash.c **** 	int i;
 499:flash/cfi_flash.c **** 	printf("flash at 0x%p of %d bytes with %d regions\n",
 500:flash/cfi_flash.c **** 		   flash->f_base, flash->f_size, flash->f_nregions);
 501:flash/cfi_flash.c **** 
 502:flash/cfi_flash.c **** 	uint16_t m_id, d_id;
 503:flash/cfi_flash.c **** 	if (get_id(flash->f_base, &m_id, &d_id)) {
 504:flash/cfi_flash.c **** 		puts("  failed to get id\n");
 505:flash/cfi_flash.c **** 	} else {
 506:flash/cfi_flash.c **** 		printf("  manufacturer 0x%4.4x device 0x%4.4x\n", m_id, d_id);
 507:flash/cfi_flash.c **** 	}
 508:flash/cfi_flash.c **** 
 509:flash/cfi_flash.c **** 	uint16_t plock;
 510:flash/cfi_flash.c **** 	uint8_t pdata[8];
 511:flash/cfi_flash.c **** 	if (get_intel_protection(flash->f_base, &plock, pdata)) {
 512:flash/cfi_flash.c **** 		puts("  failed to get protection data\n");
 513:flash/cfi_flash.c **** 	} else {
 514:flash/cfi_flash.c **** 		dump_intel_protection(plock, pdata);
 515:flash/cfi_flash.c **** 	}
 516:flash/cfi_flash.c **** 
 517:flash/cfi_flash.c **** 	struct cfi_query qry;
 518:flash/cfi_flash.c **** 	if (get_query(flash->f_base, &qry)) {
 519:flash/cfi_flash.c **** 		puts("  failed to get cfi query response\n");
 520:flash/cfi_flash.c **** 	} else {
 521:flash/cfi_flash.c **** 		dump_query_algorithms(&qry);
 522:flash/cfi_flash.c **** 		dump_query_timing(&qry);
 523:flash/cfi_flash.c **** 	}
 524:flash/cfi_flash.c **** 
 525:flash/cfi_flash.c **** 	for (i = 0; i < flash->f_nregions; i++) {
 526:flash/cfi_flash.c **** 		flash_region_t *fr = &flash->f_regions[i];
 527:flash/cfi_flash.c **** 		printf("  region %d: %d blocks of %d bytes at 0x%p\n",
 528:flash/cfi_flash.c **** 			   i, fr->fr_bnum, fr->fr_bsize, fr->fr_base);
 529:flash/cfi_flash.c **** 	}
 530:flash/cfi_flash.c **** }
 531:flash/cfi_flash.c **** 
 532:flash/cfi_flash.c **** #endif
 533:flash/cfi_flash.c **** 
 534:flash/cfi_flash.c **** __ramtext
 535:flash/cfi_flash.c **** int flash_init(flash_t * flash, void *base_addr)
 536:flash/cfi_flash.c **** {
 357              		.loc 1 536 0
 358              		@ args = 0, pretend = 0, frame = 56
 359              		@ frame_needed = 0, uses_anonymous_args = 0
 360              	.LVL22:
 361 017c F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 362              	.LCFI3:
 363 0180 0140A0E1 		mov	r4, r1
 364 0184 38D04DE2 		sub	sp, sp, #56
 365              	.LCFI4:
 366              	.LVL23:
 367              		.loc 1 536 0
 368 0188 0070A0E1 		mov	r7, r0
 537:flash/cfi_flash.c **** 	int res;
 538:flash/cfi_flash.c **** 	unsigned u;
 539:flash/cfi_flash.c **** 	uint16_t m_id, d_id[3];
 540:flash/cfi_flash.c **** 	uint32_t base;
 541:flash/cfi_flash.c **** 	struct cfi_query qry;
 542:flash/cfi_flash.c **** 
 543:flash/cfi_flash.c **** 	/* retrieve and check manufacturer and device id */
 544:flash/cfi_flash.c **** 	res = flash_get_id(base_addr, &m_id, d_id);
 369              		.loc 1 544 0
 370 018c 36108DE2 		add	r1, sp, #54
 371              	.LVL24:
 372 0190 0400A0E1 		mov	r0, r4
 373              	.LVL25:
 374 0194 30208DE2 		add	r2, sp, #48
 375 0198 FEFFFFEB 		bl	flash_get_id
 545:flash/cfi_flash.c **** 	if (res) {
 376              		.loc 1 545 0
 377 019c 000050E3 		cmp	r0, #0
 378              	.LVL26:
 379 01a0 AE00001A 		bne	.L40
 380              	.LVL27:
 546:flash/cfi_flash.c **** 		return res;
 547:flash/cfi_flash.c **** 	}
 548:flash/cfi_flash.c **** 	if (m_id != CFI_MANUF_INTEL && m_id != CFI_MANUF_ST) {
 381              		.loc 1 548 0
 382 01a4 B633DDE1 		ldrh	r3, [sp, #54]
 383 01a8 890053E3 		cmp	r3, #137
 384 01ac 20005313 		cmpne	r3, #32
 385 01b0 AD00001A 		bne	.L42
 386              	.LBB46:
 387              	.LBB47:
 388              	.LBB48:
 389              	.LBB49:
 390              		.loc 1 133 0
 391 01b4 9830A0E3 		mov	r3, #152	@ movhi
 392 01b8 B030C4E1 		strh	r3, [r4, #0]	@ movhi
 393 01bc 2010A0E3 		mov	r1, #32
 394              	.L44:
 395              	.LBE49:
 396              	.LBE48:
 397              	.LBB50:
 398              	.LBB51:
 399              	.LBB52:
 400              		.loc 1 139 0
 401 01c0 B13094E1 		ldrh	r3, [r4, r1]
 402              	.LBE52:
 403              	.LBE51:
 404              		.loc 1 421 0
 405 01c4 03208DE2 		add	r2, sp, #3
 406 01c8 FF3003E2 		and	r3, r3, #255
 407              	.LVL28:
 408 01cc 0230C0E7 		strb	r3, [r0, r2]
 409              	.LBE50:
 410              		.loc 1 418 0
 411 01d0 010080E2 		add	r0, r0, #1
 412 01d4 2D0050E3 		cmp	r0, #45
 413 01d8 021081E2 		add	r1, r1, #2
 414 01dc 6E00001A 		bne	.L44
 415              		.loc 1 424 0
 416 01e0 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 417 01e4 510053E3 		cmp	r3, #81
 418 01e8 8000001A 		bne	.L46
 419 01ec 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 420 01f0 520053E3 		cmp	r3, #82
 421 01f4 8000001A 		bne	.L46
 422 01f8 0530DDE5 		ldrb	r3, [sp, #5]	@ zero_extendqisi2
 423 01fc 590053E3 		cmp	r3, #89
 424 0200 0000A003 		moveq	r0, #0
 425              	.LVL29:
 426 0204 8100000A 		beq	.L50
 427              	.LVL30:
 428              	.L46:
 429 0208 0100E0E3 		mvn	r0, #1
 430              	.LVL31:
 431              	.L50:
 432              	.LBB53:
 433              	.LBB54:
 434              		.loc 1 133 0
 435 020c FF30A0E3 		mov	r3, #255	@ movhi
 436              	.LBE54:
 437              	.LBE53:
 438              	.LBE47:
 439              	.LBE46:
 549:flash/cfi_flash.c **** 		return -ENOTSUP;
 550:flash/cfi_flash.c **** 	}
 551:flash/cfi_flash.c **** 
 552:flash/cfi_flash.c **** 	/* retrieve and check query response */
 553:flash/cfi_flash.c **** 	res = get_query(base_addr, &qry);
 554:flash/cfi_flash.c **** 	if (res) {
 440              		.loc 1 554 0
 441 0210 000050E3 		cmp	r0, #0
 442              	.LBB55:
 443              	.LBB56:
 444              	.LBB57:
 445              	.LBB58:
 446              		.loc 1 133 0
 447 0214 B030C4E1 		strh	r3, [r4, #0]	@ movhi
 448              	.LBE58:
 449              	.LBE57:
 450              	.LBE56:
 451              	.LBE55:
 452              		.loc 1 554 0
 453 0218 AE00001A 		bne	.L40
 555:flash/cfi_flash.c **** 		return res;
 556:flash/cfi_flash.c **** 	}
 557:flash/cfi_flash.c **** 	if (qry.p_id != CFI_ALGO_INTEL_3) {
 454              		.loc 1 557 0
 455 021c 0630DDE5 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 456 0220 0720DDE5 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
 457 0224 023483E1 		orr	r3, r3, r2, asl #8
 458 0228 030053E3 		cmp	r3, #3
 459 022c AD00001A 		bne	.L42
 558:flash/cfi_flash.c **** 		/* we only support algo 3 */
 559:flash/cfi_flash.c **** 		return -ENOTSUP;
 560:flash/cfi_flash.c **** 	}
 561:flash/cfi_flash.c **** 	if (qry.num_erase_regions > FLASH_MAX_REGIONS) {
 460              		.loc 1 561 0
 461 0230 1F10DDE5 		ldrb	r1, [sp, #31]	@ zero_extendqisi2
 462 0234 040051E3 		cmp	r1, #4
 463 0238 AD00008A 		bhi	.L42
 562:flash/cfi_flash.c **** 		/* we have a hard limit on the number of regions */
 563:flash/cfi_flash.c **** 		return -ENOTSUP;
 564:flash/cfi_flash.c **** 	}
 565:flash/cfi_flash.c **** 
 566:flash/cfi_flash.c **** 	/* fill in basic information */
 567:flash/cfi_flash.c **** 	flash->f_base = base_addr;
 568:flash/cfi_flash.c **** 	flash->f_size = 1 << qry.dev_size;
 464              		.loc 1 568 0
 465 023c 1A20DDE5 		ldrb	r2, [sp, #26]	@ zero_extendqisi2
 466 0240 0130A0E3 		mov	r3, #1
 467 0244 1332A0E1 		mov	r3, r3, asl r2
 569:flash/cfi_flash.c **** 
 570:flash/cfi_flash.c **** 	/* determine number of erase regions */
 571:flash/cfi_flash.c **** 	flash->f_nregions = qry.num_erase_regions;
 468              		.loc 1 571 0
 469 0248 00E0A0E1 		mov	lr, r0
 470              	.LVL32:
 471 024c 0080A0E1 		mov	r8, r0
 472              	.LVL33:
 473 0250 0060A0E1 		mov	r6, r0
 474 0254 38C08DE2 		add	ip, sp, #56
 475              		.loc 1 567 0
 476 0258 004087E5 		str	r4, [r7, #0]
 477              		.loc 1 568 0
 478 025c 043087E5 		str	r3, [r7, #4]
 479              		.loc 1 571 0
 480 0260 081087E5 		str	r1, [r7, #8]
 481 0264 A50000EA 		b	.L54
 482              	.LVL34:
 483              	.L55:
 484              	.LBB59:
 572:flash/cfi_flash.c **** 
 573:flash/cfi_flash.c **** 	/* compute actual erase region info from cfi junk */
 574:flash/cfi_flash.c **** 	base = 0;
 575:flash/cfi_flash.c **** 	for (u = 0; u < flash->f_nregions; u++) {
 576:flash/cfi_flash.c **** 		flash_region_t *fr = &flash->f_regions[u];
 577:flash/cfi_flash.c **** 
 578:flash/cfi_flash.c **** 		fr->fr_base = (void *)base;
 579:flash/cfi_flash.c **** 		fr->fr_bnum = qry.erase_regions[u].b_count + 1;
 485              		.loc 1 579 0
 486 0268 18205CE5 		ldrb	r2, [ip, #-24]	@ zero_extendqisi2
 487 026c 17005CE5 		ldrb	r0, [ip, #-23]	@ zero_extendqisi2
 488              	.LVL35:
 580:flash/cfi_flash.c **** 		fr->fr_bsize = qry.erase_regions[u].b_size * 256;
 489              		.loc 1 580 0
 490 0270 16305CE5 		ldrb	r3, [ip, #-22]	@ zero_extendqisi2
 491 0274 15105CE5 		ldrb	r1, [ip, #-21]	@ zero_extendqisi2
 492              		.loc 1 579 0
 493 0278 002482E1 		orr	r2, r2, r0, asl #8
 494              		.loc 1 580 0
 495 027c 013483E1 		orr	r3, r3, r1, asl #8
 496              		.loc 1 579 0
 497 0280 012082E2 		add	r2, r2, #1
 498              		.loc 1 580 0
 499 0284 0334A0E1 		mov	r3, r3, asl #8
 500              		.loc 1 578 0
 501 0288 06E084E7 		str	lr, [r4, r6]
 581:flash/cfi_flash.c **** 
 582:flash/cfi_flash.c **** 		base += fr->fr_bnum * fr->fr_bsize;
 502              		.loc 1 582 0
 503 028c 93E22EE0 		mla	lr, r3, r2, lr
 504              		.loc 1 580 0
 505 0290 0C0085E9 		stmib	r5, {r2, r3}	@ phole stm
 506              	.LBE59:
 507              		.loc 1 575 0
 508 0294 04C08CE2 		add	ip, ip, #4
 509 0298 0C6086E2 		add	r6, r6, #12
 510              	.LVL36:
 511              	.L54:
 512 029c 083097E5 		ldr	r3, [r7, #8]
 513              	.LBB60:
 514              		.loc 1 576 0
 515 02a0 0C4087E2 		add	r4, r7, #12
 516              	.LVL37:
 517              	.LBE60:
 518              		.loc 1 575 0
 519 02a4 030058E1 		cmp	r8, r3
 520              	.LBB61:
 521              		.loc 1 576 0
 522 02a8 065084E0 		add	r5, r4, r6
 523              	.LBE61:
 524              		.loc 1 575 0
 525 02ac 018088E2 		add	r8, r8, #1
 526 02b0 9800003A 		bcc	.L55
 527              	.LVL38:
 528 02b4 0000A0E3 		mov	r0, #0
 529              	.LVL39:
 530 02b8 AE0000EA 		b	.L40
 531              	.LVL40:
 532              	.L42:
 533 02bc 8500E0E3 		mvn	r0, #133
 534              	.LVL41:
 535              	.L40:
 536              	.LVL42:
 583:flash/cfi_flash.c **** 	}
 584:flash/cfi_flash.c **** 
 585:flash/cfi_flash.c **** 	return 0;
 586:flash/cfi_flash.c **** }
 537              		.loc 1 586 0
 538 02c0 38D08DE2 		add	sp, sp, #56
 539 02c4 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 540              	.LFE13:
 542              		.align	2
 543              		.global	flash_block_unlock
 545              	flash_block_unlock:
 546              	.LFB6:
 547              		.loc 1 179 0
 548              		@ args = 0, pretend = 0, frame = 0
 549              		@ frame_needed = 0, uses_anonymous_args = 0
 550              		@ link register save eliminated.
 551              	.LVL43:
 552              		.loc 1 182 0
 553 02c8 043090E5 		ldr	r3, [r0, #4]
 554 02cc 030051E1 		cmp	r1, r3
 555              		.loc 1 198 0
 556 02d0 0000E033 		mvncc	r0, #0
 557 02d4 1500E023 		mvncs	r0, #21
 558              	.LVL44:
 559              		.loc 1 179 0
 560              		@ lr needed for prologue
 561              		.loc 1 198 0
 562 02d8 1EFF2FE1 		bx	lr
 563              	.LFE6:
 565              		.align	2
 566              		.global	flash_block_erase
 568              	flash_block_erase:
 569              	.LFB9:
 570              		.loc 1 238 0
 571              		@ args = 0, pretend = 0, frame = 0
 572              		@ frame_needed = 0, uses_anonymous_args = 0
 573              		@ link register save eliminated.
 574              	.LVL45:
 575              		.loc 1 241 0
 576 02dc 043090E5 		ldr	r3, [r0, #4]
 577 02e0 030051E1 		cmp	r1, r3
 578              		.loc 1 285 0
 579 02e4 0000E033 		mvncc	r0, #0
 580 02e8 1500E023 		mvncs	r0, #21
 581              	.LVL46:
 582              		.loc 1 238 0
 583              		@ lr needed for prologue
 584              		.loc 1 285 0
 585 02ec 1EFF2FE1 		bx	lr
 586              	.LFE9:
 717              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 cfi_flash.c
     /tmp/cctsLEig.s:18     .ramtext:0000000000000000 flash_block_lock
     /tmp/cctsLEig.s:25     .ramtext:0000000000000000 $a
     /tmp/cctsLEig.s:77     .ramtext:000000000000004c $d
     /tmp/cctsLEig.s:88     .ramtext:0000000000000050 flash_block_lockdown
     /tmp/cctsLEig.s:94     .ramtext:0000000000000050 $a
     /tmp/cctsLEig.s:146    .ramtext:000000000000009c $d
     /tmp/cctsLEig.s:152    .ramtext:00000000000000a0 flash_block_getlock
     /tmp/cctsLEig.s:160    .ramtext:00000000000000a0 $a
     /tmp/cctsLEig.s:205    .ramtext:00000000000000d0 flash_program
     /tmp/cctsLEig.s:246    .ramtext:000000000000010c flash_get_id
     /tmp/cctsLEig.s:348    .ramtext:0000000000000174 $d
     /tmp/cctsLEig.s:355    .ramtext:000000000000017c flash_init
     /tmp/cctsLEig.s:361    .ramtext:000000000000017c $a
     /tmp/cctsLEig.s:545    .ramtext:00000000000002c8 flash_block_unlock
     /tmp/cctsLEig.s:568    .ramtext:00000000000002dc flash_block_erase

UNDEFINED SYMBOLS
printf
