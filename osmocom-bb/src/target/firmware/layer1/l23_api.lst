   1              		.file	"l23_api.c"
   9              	.Ltext0:
  10              		.global	l1a_l23_tx_cb
  11              		.bss
  12              		.align	2
  15              	l1a_l23_tx_cb:
  16 0000 00000000 		.space	4
  17              		.data
  18              		.align	2
  21              	l23_rx_queue:
  22 0000 00000000 		.word	l23_rx_queue
  23 0004 00000000 		.word	l23_rx_queue
  24              		.section	.text.__fswab16,"ax",%progbits
  25              		.align	2
  27              	__fswab16:
  28              	.LFB3:
  29              		.file 1 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
  30              		.loc 1 47 0
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34              	.LVL0:
  35 0000 0008A0E1 		mov	r0, r0, asl #16
  36              	.LVL1:
  37 0004 2008A0E1 		mov	r0, r0, lsr #16
  38              	.LVL2:
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
  39              		.loc 1 51 0
  40 0008 2034A0E1 		mov	r3, r0, lsr #8
  41 000c FF0000E2 		and	r0, r0, #255
  42              	.LVL3:
  52:include/swab.h **** #endif
  53:include/swab.h **** }
  43              		.loc 1 53 0
  44 0010 000483E1 		orr	r0, r3, r0, asl #8
  45              		.loc 1 47 0
  46              		@ lr needed for prologue
  47              		.loc 1 53 0
  48 0014 1EFF2FE1 		bx	lr
  49              	.LFE3:
  51              		.section	.text.msgb_tailroom,"ax",%progbits
  52              		.align	2
  54              	msgb_tailroom:
  55              	.LFB35:
  56              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
  57              		.loc 2 151 0
  58              		@ args = 0, pretend = 0, frame = 0
  59              		@ frame_needed = 0, uses_anonymous_args = 0
  60              		@ link register save eliminated.
  61              	.LVL4:
  62 0000 B423D0E1 		ldrh	r2, [r0, #52]
  63 0004 383090E5 		ldr	r3, [r0, #56]
  64 0008 3C0090E5 		ldr	r0, [r0, #60]
  65              	.LVL5:
  66 000c 023083E0 		add	r3, r3, r2
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
  67              		.loc 2 153 0
  68 0010 030060E0 		rsb	r0, r0, r3
  69              		.loc 2 151 0
  70              		@ lr needed for prologue
  71              		.loc 2 153 0
  72 0014 1EFF2FE1 		bx	lr
  73              	.LFE35:
  75              		.section	.rodata.str1.4,"aMS",%progbits,1
  76              		.align	2
  77              	.LC0:
  78 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
  78      28257029 
  78      3A204E6F 
  78      7420656E 
  78      6F756768 
  79 0032 00       		.ascii	"\000"
  80              		.section	.text.msgb_put,"ax",%progbits
  81              		.align	2
  83              	msgb_put:
  84              	.LFB37:
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
  85              		.loc 2 180 0
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  88              	.LVL6:
  89 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  90              	.LCFI0:
  91              		.loc 2 180 0
  92 0004 0150A0E1 		mov	r5, r1
  93 0008 0040A0E1 		mov	r4, r0
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
  94              		.loc 2 182 0
  95 000c FEFFFFEB 		bl	msgb_tailroom
  96              	.LVL7:
  97 0010 050050E1 		cmp	r0, r5
  98 0014 0020A0E1 		mov	r2, r0
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
  99              		.loc 2 183 0
 100 0018 0410A0E1 		mov	r1, r4
 101 001c 28009FE5 		ldr	r0, .L9
 102 0020 0530A0E1 		mov	r3, r5
 103              		.loc 2 181 0
 104 0024 3C6094E5 		ldr	r6, [r4, #60]
 105              	.LVL8:
 106              		.loc 2 182 0
 107              	.LVL9:
 108              		.loc 2 183 0
 109 0028 FEFFFFBB 		bllt	osmo_panic
 110              	.LVL10:
 111              	.L6:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 112              		.loc 2 185 0
 113 002c 3C2094E5 		ldr	r2, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 114              		.loc 2 186 0
 115 0030 B633D4E1 		ldrh	r3, [r4, #54]
 116              		.loc 2 185 0
 117 0034 052082E0 		add	r2, r2, r5
 118              		.loc 2 186 0
 119 0038 053083E0 		add	r3, r3, r5
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 120              		.loc 2 188 0
 121 003c 0600A0E1 		mov	r0, r6
 122              		.loc 2 186 0
 123 0040 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 124              		.loc 2 185 0
 125 0044 3C2084E5 		str	r2, [r4, #60]
 126              		.loc 2 188 0
 127 0048 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 128              	.L10:
 129              		.align	2
 130              	.L9:
 131 004c 00000000 		.word	.LC0
 132              	.LFE37:
 134              		.section	.text.l1_queue_for_l2,"ax",%progbits
 135              		.align	2
 136              		.global	l1_queue_for_l2
 138              	l1_queue_for_l2:
 139              	.LFB59:
 140              		.file 3 "layer1/l23_api.c"
   1:layer1/l23_api.c **** /* Synchronous part of GSM Layer 1: API to Layer2+ */
   2:layer1/l23_api.c **** 
   3:layer1/l23_api.c **** /* (C) 2010 by Holger Hans Peter Freyther <zecke@selfish.org>
   4:layer1/l23_api.c ****  *
   5:layer1/l23_api.c ****  * All Rights Reserved
   6:layer1/l23_api.c ****  *
   7:layer1/l23_api.c ****  * This program is free software; you can redistribute it and/or modify
   8:layer1/l23_api.c ****  * it under the terms of the GNU General Public License as published by
   9:layer1/l23_api.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:layer1/l23_api.c ****  * (at your option) any later version.
  11:layer1/l23_api.c ****  *
  12:layer1/l23_api.c ****  * This program is distributed in the hope that it will be useful,
  13:layer1/l23_api.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:layer1/l23_api.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:layer1/l23_api.c ****  * GNU General Public License for more details.
  16:layer1/l23_api.c ****  *
  17:layer1/l23_api.c ****  * You should have received a copy of the GNU General Public License along
  18:layer1/l23_api.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:layer1/l23_api.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:layer1/l23_api.c ****  *
  21:layer1/l23_api.c ****  */
  22:layer1/l23_api.c **** 
  23:layer1/l23_api.c **** #define DEBUG
  24:layer1/l23_api.c **** 
  25:layer1/l23_api.c **** #include <stdint.h>
  26:layer1/l23_api.c **** #include <stdio.h>
  27:layer1/l23_api.c **** #include <string.h>
  28:layer1/l23_api.c **** 
  29:layer1/l23_api.c **** #include <debug.h>
  30:layer1/l23_api.c **** #include <byteorder.h>
  31:layer1/l23_api.c **** 
  32:layer1/l23_api.c **** #include <asm/system.h>
  33:layer1/l23_api.c **** 
  34:layer1/l23_api.c **** #include <osmocom/core/msgb.h>
  35:layer1/l23_api.c **** #include <osmocom/gsm/protocol/gsm_04_08.h>
  36:layer1/l23_api.c **** #include <comm/sercomm.h>
  37:layer1/l23_api.c **** 
  38:layer1/l23_api.c **** #include <layer1/sync.h>
  39:layer1/l23_api.c **** #include <layer1/async.h>
  40:layer1/l23_api.c **** #include <layer1/mframe_sched.h>
  41:layer1/l23_api.c **** #include <layer1/prim.h>
  42:layer1/l23_api.c **** #include <layer1/tpu_window.h>
  43:layer1/l23_api.c **** #include <layer1/sched_gsmtime.h>
  44:layer1/l23_api.c **** 
  45:layer1/l23_api.c **** #include <abb/twl3025.h>
  46:layer1/l23_api.c **** #include <rf/trf6151.h>
  47:layer1/l23_api.c **** #include <calypso/sim.h>
  48:layer1/l23_api.c **** #include <calypso/dsp.h>
  49:layer1/l23_api.c **** 
  50:layer1/l23_api.c **** #include <l1ctl_proto.h>
  51:layer1/l23_api.c **** 
  52:layer1/l23_api.c **** /* the size we will allocate struct msgb* for HDLC */
  53:layer1/l23_api.c **** #define L3_MSG_HEAD 4
  54:layer1/l23_api.c **** #define L3_MSG_DATA 200
  55:layer1/l23_api.c **** #define L3_MSG_SIZE (L3_MSG_HEAD + sizeof(struct l1ctl_hdr) + L3_MSG_DATA)
  56:layer1/l23_api.c **** 
  57:layer1/l23_api.c **** void (*l1a_l23_tx_cb)(struct msgb *msg) = NULL;
  58:layer1/l23_api.c **** 
  59:layer1/l23_api.c **** void l1_queue_for_l2(struct msgb *msg)
  60:layer1/l23_api.c **** {
 141              		.loc 3 60 0
 142              		@ args = 0, pretend = 0, frame = 0
 143              		@ frame_needed = 0, uses_anonymous_args = 0
 144              	.LVL11:
 145 0000 04E02DE5 		str	lr, [sp, #-4]!
 146              	.LCFI1:
  61:layer1/l23_api.c **** 	if (l1a_l23_tx_cb) {
 147              		.loc 3 61 0
 148 0004 24309FE5 		ldr	r3, .L16
 149 0008 003093E5 		ldr	r3, [r3, #0]
 150 000c 000053E3 		cmp	r3, #0
 151              		.loc 3 60 0
 152 0010 0010A0E1 		mov	r1, r0
 153              		.loc 3 61 0
 154 0014 0700000A 		beq	.L12
 155              	.LVL12:
  62:layer1/l23_api.c **** 		l1a_l23_tx_cb(msg);
 156              		.loc 3 62 0
 157 0018 0FE0A0E1 		mov	lr, pc
 158 001c 13FF2FE1 		bx	r3
 159              	.LVL13:
  63:layer1/l23_api.c **** 		return;
  64:layer1/l23_api.c **** 	}
  65:layer1/l23_api.c **** 	/* forward via serial for now */
  66:layer1/l23_api.c **** 	sercomm_sendmsg(SC_DLCI_L1A_L23, msg);
  67:layer1/l23_api.c **** }
 160              		.loc 3 67 0
 161 0020 04F09DE4 		ldr	pc, [sp], #4
 162              	.LVL14:
 163              	.L12:
 164              		.loc 3 66 0
 165 0024 0500A0E3 		mov	r0, #5
 166              		.loc 3 67 0
 167 0028 04E09DE4 		ldr	lr, [sp], #4
 168              		.loc 3 66 0
 169 002c FEFFFFEA 		b	sercomm_sendmsg
 170              	.LVL15:
 171              	.L17:
 172              		.align	2
 173              	.L16:
 174 0030 00000000 		.word	l1a_l23_tx_cb
 175              	.LFE59:
 177              		.section	.text.audio_set_enabled,"ax",%progbits
 178              		.align	2
 180              	audio_set_enabled:
 181              	.LFB63:
  68:layer1/l23_api.c **** 
  69:layer1/l23_api.c **** enum mf_type {
  70:layer1/l23_api.c **** 	MFNONE,
  71:layer1/l23_api.c **** 	MF51,
  72:layer1/l23_api.c **** 	MF26ODD,
  73:layer1/l23_api.c **** 	MF26EVEN
  74:layer1/l23_api.c **** };
  75:layer1/l23_api.c **** static uint32_t chan_nr2mf_task_mask(uint8_t chan_nr, uint8_t neigh_mode)
  76:layer1/l23_api.c **** {
  77:layer1/l23_api.c **** 	uint8_t cbits = chan_nr >> 3;
  78:layer1/l23_api.c **** 	uint8_t tn = chan_nr & 0x7;
  79:layer1/l23_api.c **** 	uint8_t lch_idx;
  80:layer1/l23_api.c **** 	enum mframe_task master_task = MF_TASK_BCCH_NORM;
  81:layer1/l23_api.c **** 	enum mframe_task second_task = -1; /* optional */
  82:layer1/l23_api.c **** 	enum mf_type multiframe = 0;
  83:layer1/l23_api.c **** 	uint32_t task_mask = 0x00;
  84:layer1/l23_api.c **** 
  85:layer1/l23_api.c **** 	if (cbits == 0x01) {
  86:layer1/l23_api.c **** 		lch_idx = 0;
  87:layer1/l23_api.c **** 		master_task = (tn & 1) ? MF_TASK_TCH_F_ODD : MF_TASK_TCH_F_EVEN;
  88:layer1/l23_api.c **** 		multiframe = (tn & 1) ? MF26ODD : MF26EVEN;
  89:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
  90:layer1/l23_api.c **** 		lch_idx = cbits & 0x1;
  91:layer1/l23_api.c **** 		master_task = MF_TASK_TCH_H_0 + lch_idx;
  92:layer1/l23_api.c **** 		multiframe = (lch_idx & 1) ? MF26ODD : MF26EVEN;
  93:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
  94:layer1/l23_api.c **** 		lch_idx = cbits & 0x3;
  95:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH4_0 + lch_idx;
  96:layer1/l23_api.c **** 		multiframe = MF51;
  97:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
  98:layer1/l23_api.c **** 		lch_idx = cbits & 0x7;
  99:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH8_0 + lch_idx;
 100:layer1/l23_api.c **** 		multiframe = MF51;
 101:layer1/l23_api.c **** 	} else if ((cbits & 0x1f) == 0x18) {
 102:layer1/l23_api.c **** 		/* Osmocom specific extension for PDTCH and PTCCH */
 103:layer1/l23_api.c **** 		master_task = MF_TASK_GPRS_PDTCH;
 104:layer1/l23_api.c **** 		second_task = MF_TASK_GPRS_PTCCH;
 105:layer1/l23_api.c **** 		/* FIXME: PDCH has different multiframe structure */
 106:layer1/l23_api.c **** 		multiframe = MFNONE;
 107:layer1/l23_api.c **** 	} else if ((cbits & 0x1f) == 0x19) {
 108:layer1/l23_api.c **** 		/* Osmocom specific extension for CBCH on SDCCH/4 */
 109:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH4_CBCH;
 110:layer1/l23_api.c **** 		multiframe = MF51;
 111:layer1/l23_api.c **** 	} else if ((cbits & 0x1f) == 0x1a) {
 112:layer1/l23_api.c **** 		/* Osmocom specific extension for CBCH on SDCCH/8 */
 113:layer1/l23_api.c **** 		master_task = MF_TASK_SDCCH8_CBCH;
 114:layer1/l23_api.c **** 		multiframe = MF51;
 115:layer1/l23_api.c **** #if 0
 116:layer1/l23_api.c **** 	} else if (cbits == 0x10) {
 117:layer1/l23_api.c **** 		/* FIXME: when to do extended BCCH? */
 118:layer1/l23_api.c **** 		master_task = MF_TASK_BCCH_NORM;
 119:layer1/l23_api.c **** 	} else if (cbits == 0x11 || cbits == 0x12) {
 120:layer1/l23_api.c **** 		/* FIXME: how to decide CCCH norm/extd? */
 121:layer1/l23_api.c **** 		master_task = MF_TASK_BCCH_CCCH;
 122:layer1/l23_api.c **** #endif
 123:layer1/l23_api.c **** 	}
 124:layer1/l23_api.c **** 
 125:layer1/l23_api.c **** 	/* Primary and secondary tasks */
 126:layer1/l23_api.c **** 	task_mask |= (1 << master_task);
 127:layer1/l23_api.c **** 	if (second_task >= 0) /* optional */
 128:layer1/l23_api.c **** 		task_mask |= (1 << second_task);
 129:layer1/l23_api.c **** 
 130:layer1/l23_api.c **** 	switch (neigh_mode) {
 131:layer1/l23_api.c **** 	case NEIGH_MODE_PM:
 132:layer1/l23_api.c **** 		switch (multiframe) {
 133:layer1/l23_api.c **** 		case MF51:
 134:layer1/l23_api.c **** 			task_mask |= (1 << MF_TASK_NEIGH_PM51);
 135:layer1/l23_api.c **** 			break;
 136:layer1/l23_api.c **** 		case MF26EVEN:
 137:layer1/l23_api.c **** 			task_mask |= (1 << MF_TASK_NEIGH_PM26E);
 138:layer1/l23_api.c **** 			break;
 139:layer1/l23_api.c **** 		case MF26ODD:
 140:layer1/l23_api.c **** 			task_mask |= (1 << MF_TASK_NEIGH_PM26O);
 141:layer1/l23_api.c **** 			break;
 142:layer1/l23_api.c **** 		}
 143:layer1/l23_api.c **** 		break;
 144:layer1/l23_api.c **** 	}
 145:layer1/l23_api.c **** 
 146:layer1/l23_api.c **** 	return task_mask;
 147:layer1/l23_api.c **** }
 148:layer1/l23_api.c **** 
 149:layer1/l23_api.c **** static int  chan_nr2dchan_type(uint8_t chan_nr)
 150:layer1/l23_api.c **** {
 151:layer1/l23_api.c **** 	uint8_t cbits = chan_nr >> 3;
 152:layer1/l23_api.c **** 
 153:layer1/l23_api.c **** 	if (cbits == 0x01) {
 154:layer1/l23_api.c **** 		return GSM_DCHAN_TCH_F;
 155:layer1/l23_api.c **** 	} else if ((cbits & 0x1e) == 0x02) {
 156:layer1/l23_api.c **** 		return GSM_DCHAN_TCH_H;
 157:layer1/l23_api.c **** 	} else if ((cbits & 0x1c) == 0x04) {
 158:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_4;
 159:layer1/l23_api.c **** 	} else if ((cbits & 0x18) == 0x08) {
 160:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_8;
 161:layer1/l23_api.c **** 	} else if ((cbits & 0x1f) == 0x18) {
 162:layer1/l23_api.c **** 		/* Osmocom-specific extension for PDCH */
 163:layer1/l23_api.c **** 		return GSM_DCHAN_PDCH;
 164:layer1/l23_api.c **** 	} else if ((cbits & 0x1f) == 0x19) {
 165:layer1/l23_api.c **** 		/* Osmocom-specific extension for CBCH on SDCCH/4 */
 166:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_4_CBCH;
 167:layer1/l23_api.c **** 	} else if ((cbits & 0x1f) == 0x1a) {
 168:layer1/l23_api.c **** 		/* Osmocom-specific extension for CBCH on SDCCH/8 */
 169:layer1/l23_api.c **** 		return GSM_DCHAN_SDCCH_8_CBCH;
 170:layer1/l23_api.c **** 	}
 171:layer1/l23_api.c **** 
 172:layer1/l23_api.c **** 	return GSM_DCHAN_UNKNOWN;
 173:layer1/l23_api.c **** }
 174:layer1/l23_api.c **** 
 175:layer1/l23_api.c **** static int chan_nr_is_tch(uint8_t chan_nr)
 176:layer1/l23_api.c **** {
 177:layer1/l23_api.c **** 	return ((chan_nr >> 3) == 0x01 ||		/* TCH/F */
 178:layer1/l23_api.c **** 		((chan_nr >> 3) & 0x1e) == 0x02);	/* TCH/H */
 179:layer1/l23_api.c **** }
 180:layer1/l23_api.c **** 
 181:layer1/l23_api.c **** static void audio_set_enabled(uint8_t tch_mode, uint8_t audio_mode)
 182:layer1/l23_api.c **** {
 182              		.loc 3 182 0
 183              		@ args = 0, pretend = 0, frame = 0
 184              		@ frame_needed = 0, uses_anonymous_args = 0
 185              	.LVL16:
 186 0000 0030A0E1 		mov	r3, r0
 187 0004 30402DE9 		stmfd	sp!, {r4, r5, lr}
 188              	.LCFI2:
 183:layer1/l23_api.c **** 	if (tch_mode == GSM48_CMODE_SIGN) {
 189              		.loc 3 183 0
 190 0008 FF5013E2 		ands	r5, r3, #255
 191              		.loc 3 182 0
 192 000c 0130A0E1 		mov	r3, r1
 184:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VUL, 0);
 185:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VDL, 0);
 186:layer1/l23_api.c **** 	} else {
 187:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VUL,
 193              		.loc 3 187 0
 194 0010 0400A0E3 		mov	r0, #4
 195              	.LVL17:
 196 0014 011001E2 		and	r1, r1, #1
 197              	.LVL18:
 198              		.loc 3 182 0
 199 0018 FF4003E2 		and	r4, r3, #255
 200              		.loc 3 183 0
 201 001c 0A00001A 		bne	.L19
 202              	.LVL19:
 203              		.loc 3 184 0
 204 0020 0510A0E1 		mov	r1, r5
 205 0024 FEFFFFEB 		bl	twl3025_unit_enable
 206              		.loc 3 185 0
 207 0028 0510A0E1 		mov	r1, r5
 208 002c 0D0000EA 		b	.L23
 209              	.LVL20:
 210              	.L19:
 211              		.loc 3 187 0
 212 0030 FEFFFFEB 		bl	twl3025_unit_enable
 188:layer1/l23_api.c **** 		                    !!(audio_mode & AUDIO_TX_MICROPHONE));
 189:layer1/l23_api.c **** 		twl3025_unit_enable(TWL3025_UNIT_VDL,
 213              		.loc 3 189 0
 214 0034 2411A0E1 		mov	r1, r4, lsr #2
 215 0038 011001E2 		and	r1, r1, #1
 216              	.LVL21:
 217              	.L23:
 218 003c 0300A0E3 		mov	r0, #3
 190:layer1/l23_api.c **** 		                    !!(audio_mode & AUDIO_RX_SPEAKER));
 191:layer1/l23_api.c **** 	}
 192:layer1/l23_api.c **** }
 219              		.loc 3 192 0
 220 0040 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 221              		.loc 3 189 0
 222 0044 FEFFFFEA 		b	twl3025_unit_enable
 223              	.LFE63:
 225              		.section	.rodata.str1.4
 226 0033 00       		.align	2
 227              	.LC1:
 228 0034 6C316374 		.ascii	"l1ctl\000"
 228      6C00
 229 003a 0000     		.align	2
 230              	.LC2:
 231 003c 4F4F5053 		.ascii	"OOPS. Out of buffers...\012\000"
 231      2E204F75 
 231      74206F66 
 231      20627566 
 231      66657273 
 232              		.section	.text.l1ctl_msgb_alloc,"ax",%progbits
 233              		.align	2
 234              		.global	l1ctl_msgb_alloc
 236              	l1ctl_msgb_alloc:
 237              	.LFB64:
 193:layer1/l23_api.c **** 
 194:layer1/l23_api.c **** struct msgb *l1ctl_msgb_alloc(uint8_t msg_type)
 195:layer1/l23_api.c **** {
 238              		.loc 3 195 0
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241              	.LVL22:
 242 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 243              	.LCFI3:
 244              		.loc 3 195 0
 245 0004 0030A0E1 		mov	r3, r0
 246              	.LBB2:
 247              	.LBB3:
 189:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 190:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint8 value to the end of the message
 191:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 192:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 8bit byte to be appended
 193:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 194:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u8(struct msgb *msgb, uint8_t word)
 195:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 196:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 1);
 197:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word & 0xFF;
 198:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 199:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 200:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint16 value to the end of the message
 201:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 202:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 16bit byte to be appended
 203:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 204:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u16(struct msgb *msgb, uint16_t word)
 205:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 206:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 2);
 207:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 8 & 0xFF;
 208:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word & 0xFF;
 209:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 210:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 211:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint32 value to the end of the message
 212:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 213:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 32bit byte to be appended
 214:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 215:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u32(struct msgb *msgb, uint32_t word)
 216:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 217:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 4);
 218:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 24 & 0xFF;
 219:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word >> 16 & 0xFF;
 220:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[2] = word >> 8 & 0xFF;
 221:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[3] = word & 0xFF;
 222:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 223:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 224:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove data from end of message
 225:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 226:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to remove from end
 227:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 228:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_get(struct msgb *msgb, unsigned int len)
 229:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 230:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->data - len;
 231:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_length(msgb) < len)
 232:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "msgb too small to get %u (len %u)\n",
 233:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   len, msgb_length(msgb));
 234:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail -= len;
 235:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 236:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 237:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 238:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from end of message
 239:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 240:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 241:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 242:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_get_u8(struct msgb *msgb)
 243:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 244:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 1);
 245:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 246:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 247:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from end of message
 248:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 249:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 250:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 251:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_get_u16(struct msgb *msgb)
 252:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 253:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 2);
 254:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 255:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 256:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from end of message
 257:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 258:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 259:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 260:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_get_u32(struct msgb *msgb)
 261:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 262:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 4);
 263:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 264:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 265:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 266:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief prepend (push) some data to start of message
 267:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 268:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to pre-pend
 269:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to newly added portion at start of \a msgb
 270:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 271:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further
 272:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * to the front (by \a len bytes), thereby enlarging the message by \a
 273:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes.
 274:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 275:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to the newly added section in the
 276:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * beginning of the message.  It can be used to fill/copy data into it.
 277:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 278:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_push(struct msgb *msgb, unsigned int len)
 279:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 280:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_headroom(msgb) < (int) len)
 281:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough headroom msgb_push (%u < %u)\n",
 282:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_headroom(msgb), len);
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
 284:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 285:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data;
 286:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 287:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove (pull) a header from the front of the message buffer
 288:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 289:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of octets to be pulled
 290:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to new start of msgb
 291:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 292:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further back
 293:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * in the message, thereby shrinking the size of the message by \a len
 294:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * bytes.
 295:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 296:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_pull(struct msgb *msgb, unsigned int len)
 297:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 300:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 301:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 302:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from front of message
 303:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 304:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 305:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 306:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_pull_u8(struct msgb *msgb)
 307:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 308:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 1) - 1;
 309:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 310:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 311:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from front of message
 312:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 313:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 314:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 315:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_pull_u16(struct msgb *msgb)
 316:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 317:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 2) - 2;
 318:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 319:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 320:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from front of message
 321:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 322:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 323:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 324:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_pull_u32(struct msgb *msgb)
 325:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 326:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 4) - 4;
 327:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 328:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 329:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 330:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Increase headroom of empty msgb, reducing the tailroom
 331:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 332:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len amount of extra octets to be reserved as headroom
 333:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 334:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function reserves some memory at the beginning of the underlying
 335:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer.  The idea is to reserve space in case further headers
 336:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * have to be pushed to the \ref msgb during further processing.
 337:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 338:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * Calling this function leads to undefined reusults if it is called on
 339:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * a non-empty \ref msgb.
 340:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 341:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_reserve(struct msgb *msg, int len)
 342:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 343:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 344:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 345:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 346:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 347:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given absolute length
 348:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 349:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len new total length of buffer
 350:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 351:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 352:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_trim(struct msgb *msg, int len)
 353:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 354:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (len > msg->data_len)
 355:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		return -1;
 356:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 357:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->len = len;
 358:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail = msg->data + len;
 359:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 360:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return 0;
 361:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 362:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 363:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given layer3 length
 364:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \pram[in] msg message buffer
 365:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] l3len new layer3 length
 366:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 367:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 368:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_l3trim(struct msgb *msg, int l3len)
 369:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 370:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb_trim(msg, (msg->l3h - msg->data) + l3len);
 371:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 372:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 373:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Allocate message buffer with specified headroom
 374:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] size size in bytes, including headroom
 375:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] headroom headroom in bytes
 376:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] name human-readable name
 377:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns allocated message buffer with specified headroom
 378:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 379:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function is a convenience wrapper around \ref msgb_alloc
 380:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * followed by \ref msgb_reserve in order to create a new \ref msgb with
 381:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * user-specified amount of headroom.
 382:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 383:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline struct msgb *msgb_alloc_headroom(int size, int headroom,
 384:../../shared/libosmocore/include/osmocom/core/msgb.h **** 						const char *name)
 385:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 386:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_static_assert(size > headroom, headroom_bigger);
 387:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 388:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct msgb *msg = msgb_alloc(size, name);
 248              		.loc 2 388 0
 249 0008 54109FE5 		ldr	r1, .L30
 250 000c D000A0E3 		mov	r0, #208
 251              	.LVL23:
 252              	.LBE3:
 253              	.LBE2:
 254              		.loc 3 195 0
 255 0010 FF5003E2 		and	r5, r3, #255
 256              	.LBB4:
 257              	.LBB5:
 258              		.loc 2 388 0
 259 0014 FEFFFFEB 		bl	msgb_alloc
 260              	.LVL24:
 389:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msg)
 261              		.loc 2 389 0
 262 0018 004050E2 		subs	r4, r0, #0
 263              	.LVL25:
 264 001c 0900001A 		bne	.L28
 265              	.L29:
 266              	.LBE5:
 267              	.LBE4:
 196:layer1/l23_api.c **** 	struct msgb *msg;
 197:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h;
 198:layer1/l23_api.c **** 
 199:layer1/l23_api.c **** 	msg = msgb_alloc_headroom(L3_MSG_SIZE, L3_MSG_HEAD, "l1ctl");
 200:layer1/l23_api.c **** 	if (!msg) {
 201:layer1/l23_api.c **** 		while (1) {
 202:layer1/l23_api.c **** 			puts("OOPS. Out of buffers...\n");
 268              		.loc 3 202 0
 269 0020 40009FE5 		ldr	r0, .L30+4
 270 0024 FEFFFFEB 		bl	puts
 271 0028 060000EA 		b	.L29
 272              	.L28:
 273              	.LBB6:
 274              	.LBB7:
 275              	.LBB8:
 276              	.LBB9:
 277              		.loc 2 343 0
 278 002c 3C2084E2 		add	r2, r4, #60
 279 0030 0C0092E8 		ldmia	r2, {r2, r3}	@ phole ldm
 280 0034 043083E2 		add	r3, r3, #4
 281              		.loc 2 344 0
 282 0038 042082E2 		add	r2, r2, #4
 283              		.loc 2 343 0
 284 003c 403084E5 		str	r3, [r4, #64]
 285              		.loc 2 344 0
 286 0040 3C2084E5 		str	r2, [r4, #60]
 287              	.LBE9:
 288              	.LBE8:
 289              	.LBE7:
 290              	.LBE6:
 203:layer1/l23_api.c **** 		}
 204:layer1/l23_api.c **** 
 205:layer1/l23_api.c **** 		return NULL;
 206:layer1/l23_api.c **** 	}
 207:layer1/l23_api.c **** 	l1h = (struct l1ctl_hdr *) msgb_put(msg, sizeof(*l1h));
 291              		.loc 3 207 0
 292 0044 0410A0E3 		mov	r1, #4
 293 0048 FEFFFFEB 		bl	msgb_put
 208:layer1/l23_api.c **** 	l1h->msg_type = msg_type;
 209:layer1/l23_api.c **** 	l1h->flags = 0;
 294              		.loc 3 209 0
 295 004c 0030A0E3 		mov	r3, #0
 296              		.loc 3 208 0
 297 0050 0050C0E5 		strb	r5, [r0, #0]
 298              		.loc 3 209 0
 299 0054 0130C0E5 		strb	r3, [r0, #1]
 210:layer1/l23_api.c **** 
 211:layer1/l23_api.c **** 	msg->l1h = (uint8_t *)l1h;
 300              		.loc 3 211 0
 301 0058 100084E5 		str	r0, [r4, #16]
 212:layer1/l23_api.c **** 
 213:layer1/l23_api.c **** 	return msg;
 214:layer1/l23_api.c **** }
 302              		.loc 3 214 0
 303 005c 0400A0E1 		mov	r0, r4
 304 0060 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 305              	.L31:
 306              		.align	2
 307              	.L30:
 308 0064 34000000 		.word	.LC1
 309 0068 3C000000 		.word	.LC2
 310              	.LFE64:
 312              		.section	.text.l1_create_l2_msg,"ax",%progbits
 313              		.align	2
 314              		.global	l1_create_l2_msg
 316              	l1_create_l2_msg:
 317              	.LFB65:
 215:layer1/l23_api.c **** 
 216:layer1/l23_api.c **** struct msgb *l1_create_l2_msg(int msg_type, uint32_t fn, uint16_t snr,
 217:layer1/l23_api.c **** 			      uint16_t arfcn)
 218:layer1/l23_api.c **** {
 318              		.loc 3 218 0
 319              		@ args = 0, pretend = 0, frame = 0
 320              		@ frame_needed = 0, uses_anonymous_args = 0
 321              	.LVL26:
 322 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 323              	.LCFI4:
 219:layer1/l23_api.c **** 	struct l1ctl_info_dl *dl;
 220:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 324              		.loc 3 220 0
 325 0004 FF0000E2 		and	r0, r0, #255
 326              	.LVL27:
 327              		.loc 3 218 0
 328 0008 0150A0E1 		mov	r5, r1
 329 000c 0268A0E1 		mov	r6, r2, asl #16
 330 0010 0378A0E1 		mov	r7, r3, asl #16
 331              		.loc 3 220 0
 332 0014 FEFFFFEB 		bl	l1ctl_msgb_alloc
 333              	.LVL28:
 221:layer1/l23_api.c **** 
 222:layer1/l23_api.c **** 	dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 334              		.loc 3 222 0
 335 0018 0C10A0E3 		mov	r1, #12
 336              		.loc 3 220 0
 337 001c 0080A0E1 		mov	r8, r0
 338              	.LVL29:
 339              		.loc 3 222 0
 340 0020 FEFFFFEB 		bl	msgb_put
 341              	.LBB10:
 342              	.LBB11:
 343              	.LBB12:
 344              	.LBB13:
 345              		.file 4 "include/asm/swab.h"
   1:include/asm/swab.h **** /*
   2:include/asm/swab.h ****  *  arch/arm/include/asm/byteorder.h
   3:include/asm/swab.h ****  *
   4:include/asm/swab.h ****  * ARM Endian-ness.  In little endian mode, the data bus is connected such
   5:include/asm/swab.h ****  * that byte accesses appear as:
   6:include/asm/swab.h ****  *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
   7:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
   8:include/asm/swab.h ****  *  d0...d31
   9:include/asm/swab.h ****  *
  10:include/asm/swab.h ****  * When in big endian mode, byte accesses appear as:
  11:include/asm/swab.h ****  *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
  12:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
  13:include/asm/swab.h ****  *  d0...d31
  14:include/asm/swab.h ****  */
  15:include/asm/swab.h **** #ifndef __ASM_ARM_SWAB_H
  16:include/asm/swab.h **** #define __ASM_ARM_SWAB_H
  17:include/asm/swab.h **** 
  18:include/asm/swab.h **** #include <stdint.h>
  19:include/asm/swab.h **** #include <defines.h>
  20:include/asm/swab.h **** 
  21:include/asm/swab.h **** static inline uint32_t __arch_swab32(uint32_t x)
  22:include/asm/swab.h **** {
  23:include/asm/swab.h **** 	uint32_t t;
  24:include/asm/swab.h **** 
  25:include/asm/swab.h **** #ifndef __thumb__
  26:include/asm/swab.h **** 	if (!__builtin_constant_p(x)) {
  27:include/asm/swab.h **** 		/*
  28:include/asm/swab.h **** 		 * The compiler needs a bit of a hint here to always do the
  29:include/asm/swab.h **** 		 * right thing and not screw it up to different degrees
  30:include/asm/swab.h **** 		 * depending on the gcc version.
  31:include/asm/swab.h **** 		 */
  32:include/asm/swab.h **** 		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
 346              		.loc 4 32 0
 347 0024 653825E0 		eor	r3, r5, r5, ror #16
 348              	.LVL30:
 349              	.LBE13:
 350              	.LBE12:
 351              	.LBE11:
 352              	.LBE10:
 223:layer1/l23_api.c **** 	dl->frame_nr = htonl(fn);
 353              		.loc 3 223 0
 354 0028 FF38C3E3 		bic	r3, r3, #16711680
 355              	.LVL31:
 356 002c 2334A0E1 		mov	r3, r3, lsr #8
 357 0030 653423E0 		eor	r3, r3, r5, ror #8
 358              		.loc 3 222 0
 359 0034 0040A0E1 		mov	r4, r0
 360              		.loc 3 223 0
 361 0038 2324A0E1 		mov	r2, r3, lsr #8
 362 003c 230CA0E1 		mov	r0, r3, lsr #24
 363 0040 2318A0E1 		mov	r1, r3, lsr #16
 364              		.loc 3 218 0
 365 0044 2668A0E1 		mov	r6, r6, lsr #16
 366              	.LVL32:
 367 0048 2778A0E1 		mov	r7, r7, lsr #16
 368              	.LVL33:
 369              		.loc 3 223 0
 370 004c 0700C4E5 		strb	r0, [r4, #7]
 371 0050 0430C4E5 		strb	r3, [r4, #4]
 372 0054 0520C4E5 		strb	r2, [r4, #5]
 373 0058 0610C4E5 		strb	r1, [r4, #6]
 224:layer1/l23_api.c **** 	dl->snr = snr;
 374              		.loc 3 224 0
 375 005c 0960C4E5 		strb	r6, [r4, #9]
 225:layer1/l23_api.c **** 	dl->band_arfcn = htons(arfcn);
 376              		.loc 3 225 0
 377 0060 0700A0E1 		mov	r0, r7
 378 0064 FEFFFFEB 		bl	__fswab16
 379 0068 2034A0E1 		mov	r3, r0, lsr #8
 380 006c 0200C4E5 		strb	r0, [r4, #2]
 226:layer1/l23_api.c **** 
 227:layer1/l23_api.c **** 	return msg;
 228:layer1/l23_api.c **** }
 381              		.loc 3 228 0
 382 0070 0800A0E1 		mov	r0, r8
 383              		.loc 3 225 0
 384 0074 0330C4E5 		strb	r3, [r4, #3]
 385              		.loc 3 228 0
 386 0078 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 387              	.LFE65:
 389              		.section	.text.l1ctl_tx_reset,"ax",%progbits
 390              		.align	2
 391              		.global	l1ctl_tx_reset
 393              	l1ctl_tx_reset:
 394              	.LFB75:
 229:layer1/l23_api.c **** 
 230:layer1/l23_api.c **** /* receive a L1CTL_FBSB_REQ from L23 */
 231:layer1/l23_api.c **** static void l1ctl_rx_fbsb_req(struct msgb *msg)
 232:layer1/l23_api.c **** {
 233:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 234:layer1/l23_api.c **** 	struct l1ctl_fbsb_req *sync_req = (struct l1ctl_fbsb_req *) l1h->data;
 235:layer1/l23_api.c **** 
 236:layer1/l23_api.c **** 	if (sizeof(*sync_req) > msg->len) {
 237:layer1/l23_api.c **** 		printf("Short sync msg. %u\n", msg->len);
 238:layer1/l23_api.c **** 		return;
 239:layer1/l23_api.c **** 	}
 240:layer1/l23_api.c **** 
 241:layer1/l23_api.c **** 	printd("L1CTL_FBSB_REQ (arfcn=%u, flags=0x%x)\n",
 242:layer1/l23_api.c **** 		ntohs(sync_req->band_arfcn), sync_req->flags);
 243:layer1/l23_api.c **** 
 244:layer1/l23_api.c **** 	/* reset scheduler and hardware */
 245:layer1/l23_api.c **** 	l1s_reset();
 246:layer1/l23_api.c **** 
 247:layer1/l23_api.c **** 	/* pre-set the CCCH mode */
 248:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = sync_req->ccch_mode;
 249:layer1/l23_api.c **** 
 250:layer1/l23_api.c **** 	printd("Starting FCCH Recognition\n");
 251:layer1/l23_api.c **** 	l1s_fbsb_req(1, sync_req);
 252:layer1/l23_api.c **** }
 253:layer1/l23_api.c **** 
 254:layer1/l23_api.c **** /* receive a L1CTL_DM_EST_REQ from L23 */
 255:layer1/l23_api.c **** static void l1ctl_rx_dm_est_req(struct msgb *msg)
 256:layer1/l23_api.c **** {
 257:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 258:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 259:layer1/l23_api.c **** 	struct l1ctl_dm_est_req *est_req = (struct l1ctl_dm_est_req *) ul->payload;
 260:layer1/l23_api.c **** 
 261:layer1/l23_api.c **** 	printd("L1CTL_DM_EST_REQ (arfcn=%u, chan_nr=0x%02x, tsc=%u)\n",
 262:layer1/l23_api.c **** 		ntohs(est_req->h0.band_arfcn), ul->chan_nr, est_req->tsc);
 263:layer1/l23_api.c **** 
 264:layer1/l23_api.c **** 	/* disable neighbour cell measurement of C0 TS 0 */
 265:layer1/l23_api.c **** 	mframe_disable(MF_TASK_NEIGH_PM51_C0T0);
 266:layer1/l23_api.c **** 
 267:layer1/l23_api.c **** 	/* configure dedicated channel state */
 268:layer1/l23_api.c **** 	l1s.dedicated.type = chan_nr2dchan_type(ul->chan_nr);
 269:layer1/l23_api.c **** 	l1s.dedicated.tsc  = est_req->tsc;
 270:layer1/l23_api.c **** 	l1s.dedicated.tn   = ul->chan_nr & 0x7;
 271:layer1/l23_api.c **** 	l1s.dedicated.h    = est_req->h;
 272:layer1/l23_api.c **** 
 273:layer1/l23_api.c **** 	if (est_req->h) {
 274:layer1/l23_api.c **** 		int i;
 275:layer1/l23_api.c **** 		l1s.dedicated.h1.hsn  = est_req->h1.hsn;
 276:layer1/l23_api.c **** 		l1s.dedicated.h1.maio = est_req->h1.maio;
 277:layer1/l23_api.c **** 		l1s.dedicated.h1.n    = est_req->h1.n;
 278:layer1/l23_api.c **** 		for (i=0; i<est_req->h1.n; i++)
 279:layer1/l23_api.c **** 			l1s.dedicated.h1.ma[i] = ntohs(est_req->h1.ma[i]);
 280:layer1/l23_api.c **** 	} else {
 281:layer1/l23_api.c **** 		l1s.dedicated.h0.arfcn = ntohs(est_req->h0.band_arfcn);
 282:layer1/l23_api.c **** 	}
 283:layer1/l23_api.c **** 
 284:layer1/l23_api.c **** 	/* TCH config */
 285:layer1/l23_api.c **** 	if (chan_nr_is_tch(ul->chan_nr)) {
 286:layer1/l23_api.c **** 		/* Mode */
 287:layer1/l23_api.c **** 		l1a_tch_mode_set(est_req->tch_mode);
 288:layer1/l23_api.c **** 		l1a_audio_mode_set(est_req->audio_mode);
 289:layer1/l23_api.c **** 
 290:layer1/l23_api.c **** 		/* Sync */
 291:layer1/l23_api.c **** 		l1s.tch_sync = 1;	/* can be set without locking */
 292:layer1/l23_api.c **** 
 293:layer1/l23_api.c **** 		/* Audio path */
 294:layer1/l23_api.c **** 		audio_set_enabled(est_req->tch_mode, est_req->audio_mode);
 295:layer1/l23_api.c **** 	}
 296:layer1/l23_api.c **** 
 297:layer1/l23_api.c **** 	/* figure out which MF tasks to enable */
 298:layer1/l23_api.c **** 	l1a_mftask_set(chan_nr2mf_task_mask(ul->chan_nr, NEIGH_MODE_PM));
 299:layer1/l23_api.c **** }
 300:layer1/l23_api.c **** 
 301:layer1/l23_api.c **** /* receive a L1CTL_DM_FREQ_REQ from L23 */
 302:layer1/l23_api.c **** static void l1ctl_rx_dm_freq_req(struct msgb *msg)
 303:layer1/l23_api.c **** {
 304:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 305:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 306:layer1/l23_api.c **** 	struct l1ctl_dm_freq_req *freq_req =
 307:layer1/l23_api.c **** 			(struct l1ctl_dm_freq_req *) ul->payload;
 308:layer1/l23_api.c **** 
 309:layer1/l23_api.c **** 	printd("L1CTL_DM_FREQ_REQ (arfcn=%u, tsc=%u)\n",
 310:layer1/l23_api.c **** 		ntohs(freq_req->h0.band_arfcn), freq_req->tsc);
 311:layer1/l23_api.c **** 
 312:layer1/l23_api.c **** 	/* configure dedicated channel state */
 313:layer1/l23_api.c **** 	l1s.dedicated.st_tsc  = freq_req->tsc;
 314:layer1/l23_api.c **** 	l1s.dedicated.st_h    = freq_req->h;
 315:layer1/l23_api.c **** 
 316:layer1/l23_api.c **** 	if (freq_req->h) {
 317:layer1/l23_api.c **** 		int i;
 318:layer1/l23_api.c **** 		l1s.dedicated.st_h1.hsn  = freq_req->h1.hsn;
 319:layer1/l23_api.c **** 		l1s.dedicated.st_h1.maio = freq_req->h1.maio;
 320:layer1/l23_api.c **** 		l1s.dedicated.st_h1.n    = freq_req->h1.n;
 321:layer1/l23_api.c **** 		for (i=0; i<freq_req->h1.n; i++)
 322:layer1/l23_api.c **** 			l1s.dedicated.st_h1.ma[i] = ntohs(freq_req->h1.ma[i]);
 323:layer1/l23_api.c **** 	} else {
 324:layer1/l23_api.c **** 		l1s.dedicated.st_h0.arfcn = ntohs(freq_req->h0.band_arfcn);
 325:layer1/l23_api.c **** 	}
 326:layer1/l23_api.c **** 
 327:layer1/l23_api.c **** 	l1a_freq_req(ntohs(freq_req->fn));
 328:layer1/l23_api.c **** }
 329:layer1/l23_api.c **** 
 330:layer1/l23_api.c **** /* receive a L1CTL_CRYPTO_REQ from L23 */
 331:layer1/l23_api.c **** static void l1ctl_rx_crypto_req(struct msgb *msg)
 332:layer1/l23_api.c **** {
 333:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 334:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 335:layer1/l23_api.c **** 	struct l1ctl_crypto_req *cr = (struct l1ctl_crypto_req *) ul->payload;
 336:layer1/l23_api.c **** 
 337:layer1/l23_api.c **** 	printd("L1CTL_CRYPTO_REQ (algo=A5/%u, len=%u)\n", cr->algo, cr->key_len);
 338:layer1/l23_api.c **** 
 339:layer1/l23_api.c **** 	if (cr->algo && cr->key_len != 8) {
 340:layer1/l23_api.c **** 		printd("L1CTL_CRYPTO_REQ -> Invalid key\n");
 341:layer1/l23_api.c **** 		return;
 342:layer1/l23_api.c **** 	}
 343:layer1/l23_api.c **** 
 344:layer1/l23_api.c **** 	dsp_load_ciph_param(cr->algo, cr->key);
 345:layer1/l23_api.c **** }
 346:layer1/l23_api.c **** 
 347:layer1/l23_api.c **** /* receive a L1CTL_DM_REL_REQ from L23 */
 348:layer1/l23_api.c **** static void l1ctl_rx_dm_rel_req(struct msgb *msg)
 349:layer1/l23_api.c **** {
 350:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 351:layer1/l23_api.c **** 
 352:layer1/l23_api.c **** 	printd("L1CTL_DM_REL_REQ\n");
 353:layer1/l23_api.c **** 	l1a_mftask_set(0);
 354:layer1/l23_api.c **** 	l1s.dedicated.type = GSM_DCHAN_NONE;
 355:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_MAIN]);
 356:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_SACCH]);
 357:layer1/l23_api.c **** 	l1a_txq_msgb_flush(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 358:layer1/l23_api.c **** 	l1a_meas_msgb_set(NULL);
 359:layer1/l23_api.c **** 	dsp_load_ciph_param(0, NULL);
 360:layer1/l23_api.c **** 	l1a_tch_mode_set(GSM48_CMODE_SIGN);
 361:layer1/l23_api.c **** 	audio_set_enabled(GSM48_CMODE_SIGN, 0);
 362:layer1/l23_api.c **** 	l1s.tch_loop_mode = L1CTL_TCH_LOOP_OPEN;
 363:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0;
 364:layer1/l23_api.c **** }
 365:layer1/l23_api.c **** 
 366:layer1/l23_api.c **** /* receive a L1CTL_PARAM_REQ from L23 */
 367:layer1/l23_api.c **** static void l1ctl_rx_param_req(struct msgb *msg)
 368:layer1/l23_api.c **** {
 369:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 370:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 371:layer1/l23_api.c **** 	struct l1ctl_par_req *par_req = (struct l1ctl_par_req *) ul->payload;
 372:layer1/l23_api.c **** 
 373:layer1/l23_api.c **** 	printd("L1CTL_PARAM_REQ (ta=%d, tx_power=%u)\n", par_req->ta,
 374:layer1/l23_api.c **** 		par_req->tx_power);
 375:layer1/l23_api.c **** 
 376:layer1/l23_api.c **** 	l1s.ta = par_req->ta;
 377:layer1/l23_api.c **** 	l1s.tx_power = par_req->tx_power;
 378:layer1/l23_api.c **** }
 379:layer1/l23_api.c **** 
 380:layer1/l23_api.c **** /* receive a L1CTL_RACH_REQ from L23 */
 381:layer1/l23_api.c **** static void l1ctl_rx_rach_req(struct msgb *msg)
 382:layer1/l23_api.c **** {
 383:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 384:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 385:layer1/l23_api.c **** 	struct l1ctl_rach_req *rach_req = (struct l1ctl_rach_req *) ul->payload;
 386:layer1/l23_api.c **** 
 387:layer1/l23_api.c **** 	printd("L1CTL_RACH_REQ (ra=0x%02x, offset=%d, combined=%d)\n",
 388:layer1/l23_api.c **** 		rach_req->ra, ntohs(rach_req->offset), rach_req->combined);
 389:layer1/l23_api.c **** 
 390:layer1/l23_api.c **** 	l1a_rach_req(ntohs(rach_req->offset), rach_req->combined,
 391:layer1/l23_api.c **** 		rach_req->ra);
 392:layer1/l23_api.c **** }
 393:layer1/l23_api.c **** 
 394:layer1/l23_api.c **** /* receive a L1CTL_DATA_REQ from L23 */
 395:layer1/l23_api.c **** static void l1ctl_rx_data_req(struct msgb *msg)
 396:layer1/l23_api.c **** {
 397:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 398:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 399:layer1/l23_api.c **** 	struct l1ctl_data_ind *data_ind = (struct l1ctl_data_ind *) ul->payload;
 400:layer1/l23_api.c **** 	struct llist_head *tx_queue;
 401:layer1/l23_api.c **** 
 402:layer1/l23_api.c **** 	printd("L1CTL_DATA_REQ (link_id=0x%02x)\n", ul->link_id);
 403:layer1/l23_api.c **** 
 404:layer1/l23_api.c **** 	msg->l3h = data_ind->data;
 405:layer1/l23_api.c **** 	if (ul->link_id & 0x40) {
 406:layer1/l23_api.c **** 		struct gsm48_hdr *gh = (struct gsm48_hdr *)(data_ind->data + 5);
 407:layer1/l23_api.c **** 		if (gh->proto_discr == GSM48_PDISC_RR
 408:layer1/l23_api.c **** 		 && gh->msg_type == GSM48_MT_RR_MEAS_REP) {
 409:layer1/l23_api.c **** 			printd("updating measurement report\n");
 410:layer1/l23_api.c **** 			l1a_meas_msgb_set(msg);
 411:layer1/l23_api.c **** 			return;
 412:layer1/l23_api.c **** 		}
 413:layer1/l23_api.c **** 		tx_queue = &l1s.tx_queue[L1S_CHAN_SACCH];
 414:layer1/l23_api.c **** 	} else
 415:layer1/l23_api.c **** 		tx_queue = &l1s.tx_queue[L1S_CHAN_MAIN];
 416:layer1/l23_api.c **** 
 417:layer1/l23_api.c **** 	printd("ul=%p, ul->payload=%p, data_ind=%p, data_ind->data=%p l3h=%p\n",
 418:layer1/l23_api.c **** 		ul, ul->payload, data_ind, data_ind->data, msg->l3h);
 419:layer1/l23_api.c **** 
 420:layer1/l23_api.c **** 	l1a_txq_msgb_enq(tx_queue, msg);
 421:layer1/l23_api.c **** }
 422:layer1/l23_api.c **** 
 423:layer1/l23_api.c **** /* receive a L1CTL_PM_REQ from L23 */
 424:layer1/l23_api.c **** static void l1ctl_rx_pm_req(struct msgb *msg)
 425:layer1/l23_api.c **** {
 426:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 427:layer1/l23_api.c **** 	struct l1ctl_pm_req *pm_req = (struct l1ctl_pm_req *) l1h->data;
 428:layer1/l23_api.c **** 
 429:layer1/l23_api.c **** 	switch (pm_req->type) {
 430:layer1/l23_api.c **** 	case 1:
 431:layer1/l23_api.c **** 		l1s.pm.mode = 1;
 432:layer1/l23_api.c **** 		l1s.pm.range.arfcn_start =
 433:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_from);
 434:layer1/l23_api.c **** 		l1s.pm.range.arfcn_next =
 435:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_from);
 436:layer1/l23_api.c **** 		l1s.pm.range.arfcn_end =
 437:layer1/l23_api.c **** 				ntohs(pm_req->range.band_arfcn_to);
 438:layer1/l23_api.c **** 		printf("L1CTL_PM_REQ start=%u end=%u\n",
 439:layer1/l23_api.c **** 			l1s.pm.range.arfcn_start, l1s.pm.range.arfcn_end);
 440:layer1/l23_api.c **** 		break;
 441:layer1/l23_api.c **** 	}
 442:layer1/l23_api.c **** 	l1s_reset_hw(); /* must reset, otherwise measurement results are delayed */
 443:layer1/l23_api.c **** 	l1s_pm_test(1, l1s.pm.range.arfcn_next);
 444:layer1/l23_api.c **** }
 445:layer1/l23_api.c **** 
 446:layer1/l23_api.c **** /* Transmit a L1CTL_RESET_IND or L1CTL_RESET_CONF */
 447:layer1/l23_api.c **** void l1ctl_tx_reset(uint8_t msg_type, uint8_t reset_type)
 448:layer1/l23_api.c **** {
 395              		.loc 3 448 0
 396              		@ args = 0, pretend = 0, frame = 0
 397              		@ frame_needed = 0, uses_anonymous_args = 0
 398              	.LVL34:
 399 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 400              	.LCFI5:
 401              		.loc 3 448 0
 402 0004 FF0000E2 		and	r0, r0, #255
 403 0008 FF4001E2 		and	r4, r1, #255
 449:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(msg_type);
 404              		.loc 3 449 0
 405 000c FEFFFFEB 		bl	l1ctl_msgb_alloc
 406              	.LVL35:
 450:layer1/l23_api.c **** 	struct l1ctl_reset *reset_resp;
 451:layer1/l23_api.c **** 	reset_resp = (struct l1ctl_reset *)
 407              		.loc 3 451 0
 408 0010 0410A0E3 		mov	r1, #4
 409              		.loc 3 449 0
 410 0014 0050A0E1 		mov	r5, r0
 411              	.LVL36:
 412              		.loc 3 451 0
 413 0018 FEFFFFEB 		bl	msgb_put
 452:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*reset_resp));
 453:layer1/l23_api.c **** 	reset_resp->type = reset_type;
 414              		.loc 3 453 0
 415 001c 0040C0E5 		strb	r4, [r0, #0]
 454:layer1/l23_api.c **** 
 455:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 416              		.loc 3 455 0
 417 0020 0500A0E1 		mov	r0, r5
 456:layer1/l23_api.c **** }
 418              		.loc 3 456 0
 419 0024 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 420              		.loc 3 455 0
 421 0028 FEFFFFEA 		b	l1_queue_for_l2
 422              	.LFE75:
 424              		.section	.text.l1a_l23_rx,"ax",%progbits
 425              		.align	2
 426              		.global	l1a_l23_rx
 428              	l1a_l23_rx:
 429              	.LFB84:
 457:layer1/l23_api.c **** 
 458:layer1/l23_api.c **** /* receive a L1CTL_RESET_REQ from L23 */
 459:layer1/l23_api.c **** static void l1ctl_rx_reset_req(struct msgb *msg)
 460:layer1/l23_api.c **** {
 461:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 462:layer1/l23_api.c **** 	struct l1ctl_reset *reset_req =
 463:layer1/l23_api.c **** 				(struct l1ctl_reset *) l1h->data;
 464:layer1/l23_api.c **** 
 465:layer1/l23_api.c **** 	switch (reset_req->type) {
 466:layer1/l23_api.c **** 	case L1CTL_RES_T_FULL:
 467:layer1/l23_api.c **** 		printf("L1CTL_RESET_REQ: FULL!\n");
 468:layer1/l23_api.c **** 		l1s_reset();
 469:layer1/l23_api.c **** 		l1s_reset_hw();
 470:layer1/l23_api.c **** 		audio_set_enabled(GSM48_CMODE_SIGN, 0);
 471:layer1/l23_api.c **** 		l1ctl_tx_reset(L1CTL_RESET_CONF, reset_req->type);
 472:layer1/l23_api.c **** 		break;
 473:layer1/l23_api.c **** 	case L1CTL_RES_T_SCHED:
 474:layer1/l23_api.c **** 		printf("L1CTL_RESET_REQ: SCHED!\n");
 475:layer1/l23_api.c **** 		l1ctl_tx_reset(L1CTL_RESET_CONF, reset_req->type);
 476:layer1/l23_api.c **** 		sched_gsmtime_reset();
 477:layer1/l23_api.c **** 		break;
 478:layer1/l23_api.c **** 	default:
 479:layer1/l23_api.c **** 		printf("unknown L1CTL_RESET_REQ type\n");
 480:layer1/l23_api.c **** 		break;
 481:layer1/l23_api.c **** 	}
 482:layer1/l23_api.c **** }
 483:layer1/l23_api.c **** 
 484:layer1/l23_api.c **** /* Transmit a L1CTL_CCCH_MODE_CONF */
 485:layer1/l23_api.c **** static void l1ctl_tx_ccch_mode_conf(uint8_t ccch_mode)
 486:layer1/l23_api.c **** {
 487:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_CCCH_MODE_CONF);
 488:layer1/l23_api.c **** 	struct l1ctl_ccch_mode_conf *mode_conf;
 489:layer1/l23_api.c **** 	mode_conf = (struct l1ctl_ccch_mode_conf *)
 490:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 491:layer1/l23_api.c **** 	mode_conf->ccch_mode = ccch_mode;
 492:layer1/l23_api.c **** 
 493:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 494:layer1/l23_api.c **** }
 495:layer1/l23_api.c **** 
 496:layer1/l23_api.c **** /* receive a L1CTL_CCCH_MODE_REQ from L23 */
 497:layer1/l23_api.c **** static void l1ctl_rx_ccch_mode_req(struct msgb *msg)
 498:layer1/l23_api.c **** {
 499:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 500:layer1/l23_api.c **** 	struct l1ctl_ccch_mode_req *ccch_mode_req =
 501:layer1/l23_api.c **** 		(struct l1ctl_ccch_mode_req *) l1h->data;
 502:layer1/l23_api.c **** 	uint8_t ccch_mode = ccch_mode_req->ccch_mode;
 503:layer1/l23_api.c **** 
 504:layer1/l23_api.c **** 	/* pre-set the CCCH mode */
 505:layer1/l23_api.c **** 	l1s.serving_cell.ccch_mode = ccch_mode;
 506:layer1/l23_api.c **** 
 507:layer1/l23_api.c **** 	/* Update task */
 508:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH_COMB);
 509:layer1/l23_api.c **** 	mframe_disable(MF_TASK_CCCH);
 510:layer1/l23_api.c **** 
 511:layer1/l23_api.c **** 	if (ccch_mode == CCCH_MODE_COMBINED)
 512:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH_COMB);
 513:layer1/l23_api.c **** 	else if (ccch_mode == CCCH_MODE_NON_COMBINED)
 514:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH);
 515:layer1/l23_api.c **** 	else if (ccch_mode == CCCH_MODE_COMBINED_CBCH) {
 516:layer1/l23_api.c **** 		mframe_enable(MF_TASK_CCCH_COMB);
 517:layer1/l23_api.c **** 		mframe_enable(MF_TASK_SDCCH4_CBCH);
 518:layer1/l23_api.c **** 	}
 519:layer1/l23_api.c **** 
 520:layer1/l23_api.c **** 	l1ctl_tx_ccch_mode_conf(ccch_mode);
 521:layer1/l23_api.c **** }
 522:layer1/l23_api.c **** 
 523:layer1/l23_api.c **** /* Transmit a L1CTL_TCH_MODE_CONF */
 524:layer1/l23_api.c **** static void l1ctl_tx_tch_mode_conf(uint8_t tch_mode, uint8_t audio_mode)
 525:layer1/l23_api.c **** {
 526:layer1/l23_api.c **** 	struct msgb *msg = l1ctl_msgb_alloc(L1CTL_TCH_MODE_CONF);
 527:layer1/l23_api.c **** 	struct l1ctl_tch_mode_conf *mode_conf;
 528:layer1/l23_api.c **** 	mode_conf = (struct l1ctl_tch_mode_conf *)
 529:layer1/l23_api.c **** 				msgb_put(msg, sizeof(*mode_conf));
 530:layer1/l23_api.c **** 	mode_conf->tch_mode = tch_mode;
 531:layer1/l23_api.c **** 	mode_conf->audio_mode = audio_mode;
 532:layer1/l23_api.c **** 	mode_conf->tch_loop_mode = l1s.tch_loop_mode;
 533:layer1/l23_api.c **** 
 534:layer1/l23_api.c **** 	l1_queue_for_l2(msg);
 535:layer1/l23_api.c **** }
 536:layer1/l23_api.c **** 
 537:layer1/l23_api.c **** /* receive a L1CTL_TCH_MODE_REQ from L23 */
 538:layer1/l23_api.c **** static void l1ctl_rx_tch_mode_req(struct msgb *msg)
 539:layer1/l23_api.c **** {
 540:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 541:layer1/l23_api.c **** 	struct l1ctl_tch_mode_req *tch_mode_req =
 542:layer1/l23_api.c **** 		(struct l1ctl_tch_mode_req *) l1h->data;
 543:layer1/l23_api.c **** 	uint8_t tch_mode = tch_mode_req->tch_mode;
 544:layer1/l23_api.c **** 	uint8_t audio_mode = tch_mode_req->audio_mode;
 545:layer1/l23_api.c **** 
 546:layer1/l23_api.c **** 	printd("L1CTL_TCH_MODE_REQ (tch_mode=0x%02x audio_mode=0x%02x)\n",
 547:layer1/l23_api.c **** 		tch_mode, audio_mode);
 548:layer1/l23_api.c **** 	tch_mode = l1a_tch_mode_set(tch_mode);
 549:layer1/l23_api.c **** 	audio_mode = l1a_audio_mode_set(audio_mode);
 550:layer1/l23_api.c **** 
 551:layer1/l23_api.c **** 	audio_set_enabled(tch_mode, audio_mode);
 552:layer1/l23_api.c **** 
 553:layer1/l23_api.c **** 	l1s.tch_sync = 1; /* Needed for audio to work */
 554:layer1/l23_api.c **** 	l1s.tch_loop_mode = tch_mode_req->tch_loop_mode;
 555:layer1/l23_api.c **** 
 556:layer1/l23_api.c **** 	l1ctl_tx_tch_mode_conf(tch_mode, audio_mode);
 557:layer1/l23_api.c **** }
 558:layer1/l23_api.c **** 
 559:layer1/l23_api.c **** /* receive a L1CTL_NEIGH_PM_REQ from L23 */
 560:layer1/l23_api.c **** static void l1ctl_rx_neigh_pm_req(struct msgb *msg)
 561:layer1/l23_api.c **** {
 562:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 563:layer1/l23_api.c **** 	struct l1ctl_neigh_pm_req *pm_req =
 564:layer1/l23_api.c **** 		(struct l1ctl_neigh_pm_req *) l1h->data;
 565:layer1/l23_api.c **** 	int i;
 566:layer1/l23_api.c **** 
 567:layer1/l23_api.c **** 	/* reset list in order to prevent race condition */
 568:layer1/l23_api.c **** 	l1s.neigh_pm.n = 0; /* atomic */
 569:layer1/l23_api.c **** 	l1s.neigh_pm.second = 0;
 570:layer1/l23_api.c **** 	/* now reset pointer and fill list */
 571:layer1/l23_api.c **** 	l1s.neigh_pm.pos = 0;
 572:layer1/l23_api.c **** 	l1s.neigh_pm.running = 0;
 573:layer1/l23_api.c **** 	for (i = 0; i < pm_req->n; i++) {
 574:layer1/l23_api.c **** 		l1s.neigh_pm.band_arfcn[i] = ntohs(pm_req->band_arfcn[i]);
 575:layer1/l23_api.c **** 		l1s.neigh_pm.tn[i] = pm_req->tn[i];
 576:layer1/l23_api.c **** 	}
 577:layer1/l23_api.c **** 	printf("L1CTL_NEIGH_PM_REQ new list with %u entries\n", pm_req->n);
 578:layer1/l23_api.c **** 	l1s.neigh_pm.n = pm_req->n; /* atomic */
 579:layer1/l23_api.c **** 
 580:layer1/l23_api.c **** 	/* on C0 enable PM on frame 51 */
 581:layer1/l23_api.c **** 	if (l1s.dedicated.type == GSM_DCHAN_NONE)
 582:layer1/l23_api.c **** 		mframe_enable(MF_TASK_NEIGH_PM51_C0T0);
 583:layer1/l23_api.c **** }
 584:layer1/l23_api.c **** 
 585:layer1/l23_api.c **** /* receive a L1CTL_TRAFFIC_REQ from L23 */
 586:layer1/l23_api.c **** static void l1ctl_rx_traffic_req(struct msgb *msg)
 587:layer1/l23_api.c **** {
 588:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h = (struct l1ctl_hdr *) msg->data;
 589:layer1/l23_api.c **** 	struct l1ctl_info_ul *ul = (struct l1ctl_info_ul *) l1h->data;
 590:layer1/l23_api.c **** 	struct l1ctl_traffic_req *tr = (struct l1ctl_traffic_req *) ul->payload;
 591:layer1/l23_api.c **** 	int num = 0;
 592:layer1/l23_api.c **** 
 593:layer1/l23_api.c **** 	/* printd("L1CTL_TRAFFIC_REQ\n"); */ /* Very verbose, can overwhelm serial */
 594:layer1/l23_api.c **** 
 595:layer1/l23_api.c **** 	msg->l2h = tr->data;
 596:layer1/l23_api.c **** 
 597:layer1/l23_api.c **** 	num = l1a_txq_msgb_count(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 598:layer1/l23_api.c **** 	if (num >= 4) {
 599:layer1/l23_api.c **** 		printd("dropping traffic frame\n");
 600:layer1/l23_api.c **** 		msgb_free(msg);
 601:layer1/l23_api.c **** 		return;
 602:layer1/l23_api.c **** 	}
 603:layer1/l23_api.c **** 
 604:layer1/l23_api.c **** 	l1a_txq_msgb_enq(&l1s.tx_queue[L1S_CHAN_TRAFFIC], msg);
 605:layer1/l23_api.c **** }
 606:layer1/l23_api.c **** 
 607:layer1/l23_api.c **** static void l1ctl_sim_req(struct msgb *msg)
 608:layer1/l23_api.c **** {
 609:layer1/l23_api.c **** 	uint16_t len = msg->len - sizeof(struct l1ctl_hdr);
 610:layer1/l23_api.c **** 	uint8_t *data = msg->data + sizeof(struct l1ctl_hdr);
 611:layer1/l23_api.c **** 
 612:layer1/l23_api.c **** #if 1 /* for debugging only */
 613:layer1/l23_api.c **** 	{
 614:layer1/l23_api.c **** 		int i;
 615:layer1/l23_api.c **** 		printf("SIM Request (%u): ", len);
 616:layer1/l23_api.c **** 		for (i = 0; i < len; i++)
 617:layer1/l23_api.c **** 			printf("%02x ", data[i]);
 618:layer1/l23_api.c **** 		puts("\n");
 619:layer1/l23_api.c **** 	}
 620:layer1/l23_api.c **** #endif
 621:layer1/l23_api.c **** 
 622:layer1/l23_api.c ****    sim_apdu(len, data);
 623:layer1/l23_api.c **** }
 624:layer1/l23_api.c **** 
 625:layer1/l23_api.c **** static struct llist_head l23_rx_queue = LLIST_HEAD_INIT(l23_rx_queue);
 626:layer1/l23_api.c **** 
 627:layer1/l23_api.c **** /* callback from SERCOMM when L2 sends a message to L1 */
 628:layer1/l23_api.c **** void l1a_l23_rx(uint8_t dlci, struct msgb *msg)
 629:layer1/l23_api.c **** {
 430              		.loc 3 629 0
 431              		@ args = 0, pretend = 0, frame = 0
 432              		@ frame_needed = 0, uses_anonymous_args = 0
 433              	.LVL37:
 434 0000 10402DE9 		stmfd	sp!, {r4, lr}
 435              	.LCFI6:
 436              	.LBB14:
 630:layer1/l23_api.c **** 	unsigned long flags;
 631:layer1/l23_api.c **** 
 632:layer1/l23_api.c **** 	local_firq_save(flags);
 437              		.loc 3 632 0
 438 0004 00400FE1 		mrs	r4, cpsr		@ local_firq_save
 439 0008 C03084E3 		orr	r3, r4, #0xC0
 440 000c 03F021E1 		msr	cpsr_c, r3
 441              	.LVL38:
 442              	.LBE14:
 633:layer1/l23_api.c **** 	msgb_enqueue(&l23_rx_queue, msg);
 443              		.loc 3 633 0
 444 0010 08009FE5 		ldr	r0, .L38
 445              	.LVL39:
 446 0014 FEFFFFEB 		bl	msgb_enqueue
 447              	.LVL40:
 634:layer1/l23_api.c **** 	local_irq_restore(flags);
 448              		.loc 3 634 0
 449 0018 04F021E1 		msr	cpsr_c, r4		@ local_irq_restore
 450              	
 635:layer1/l23_api.c **** }
 451              		.loc 3 635 0
 452 001c 1080BDE8 		ldmfd	sp!, {r4, pc}
 453              	.L39:
 454              		.align	2
 455              	.L38:
 456 0020 00000000 		.word	l23_rx_queue
 457              	.LFE84:
 459              		.section	.rodata.str1.4
 460 0055 000000   		.align	2
 461              	.LC3:
 462 0058 6C31615F 		.ascii	"l1a_l23_cb: Short message. %u\012\000"
 462      6C32335F 
 462      63623A20 
 462      53686F72 
 462      74206D65 
 463 0077 00       		.align	2
 464              	.LC4:
 465 0078 53686F72 		.ascii	"Short sync msg. %u\012\000"
 465      74207379 
 465      6E63206D 
 465      73672E20 
 465      25750A00 
 466              		.align	2
 467              	.LC5:
 468 008c 4C314354 		.ascii	"L1CTL_FBSB_REQ (arfcn=%u, flags=0x%x)\012\000"
 468      4C5F4642 
 468      53425F52 
 468      45512028 
 468      61726663 
 469 00b3 00       		.align	2
 470              	.LC6:
 471 00b4 53746172 		.ascii	"Starting FCCH Recognition\000"
 471      74696E67 
 471      20464343 
 471      48205265 
 471      636F676E 
 472 00ce 0000     		.align	2
 473              	.LC7:
 474 00d0 4C314354 		.ascii	"L1CTL_DM_EST_REQ (arfcn=%u, chan_nr=0x%02x, tsc=%u)"
 474      4C5F444D 
 474      5F455354 
 474      5F524551 
 474      20286172 
 475 0103 0A00     		.ascii	"\012\000"
 476 0105 000000   		.align	2
 477              	.LC8:
 478 0108 4C314354 		.ascii	"L1CTL_DM_REL_REQ\000"
 478      4C5F444D 
 478      5F52454C 
 478      5F524551 
 478      00
 479 0119 000000   		.align	2
 480              	.LC9:
 481 011c 4C314354 		.ascii	"L1CTL_PARAM_REQ (ta=%d, tx_power=%u)\012\000"
 481      4C5F5041 
 481      52414D5F 
 481      52455120 
 481      2874613D 
 482 0142 0000     		.align	2
 483              	.LC10:
 484 0144 4C314354 		.ascii	"L1CTL_DM_FREQ_REQ (arfcn=%u, tsc=%u)\012\000"
 484      4C5F444D 
 484      5F465245 
 484      515F5245 
 484      51202861 
 485 016a 0000     		.align	2
 486              	.LC11:
 487 016c 4C314354 		.ascii	"L1CTL_CRYPTO_REQ (algo=A5/%u, len=%u)\012\000"
 487      4C5F4352 
 487      5950544F 
 487      5F524551 
 487      2028616C 
 488 0193 00       		.align	2
 489              	.LC12:
 490 0194 4C314354 		.ascii	"L1CTL_CRYPTO_REQ -> Invalid key\000"
 490      4C5F4352 
 490      5950544F 
 490      5F524551 
 490      202D3E20 
 491              		.align	2
 492              	.LC13:
 493 01b4 4C314354 		.ascii	"L1CTL_RACH_REQ (ra=0x%02x, offset=%d, combined=%d)\012"
 493      4C5F5241 
 493      43485F52 
 493      45512028 
 493      72613D30 
 494 01e7 00       		.ascii	"\000"
 495              		.align	2
 496              	.LC14:
 497 01e8 4C314354 		.ascii	"L1CTL_DATA_REQ (link_id=0x%02x)\012\000"
 497      4C5F4441 
 497      54415F52 
 497      45512028 
 497      6C696E6B 
 498 0209 000000   		.align	2
 499              	.LC15:
 500 020c 75706461 		.ascii	"updating measurement report\000"
 500      74696E67 
 500      206D6561 
 500      73757265 
 500      6D656E74 
 501              		.align	2
 502              	.LC16:
 503 0228 756C3D25 		.ascii	"ul=%p, ul->payload=%p, data_ind=%p, data_ind->data="
 503      702C2075 
 503      6C2D3E70 
 503      61796C6F 
 503      61643D25 
 504 025b 2570206C 		.ascii	"%p l3h=%p\012\000"
 504      33683D25 
 504      700A00
 505 0266 0000     		.align	2
 506              	.LC17:
 507 0268 4C314354 		.ascii	"L1CTL_PM_REQ start=%u end=%u\012\000"
 507      4C5F504D 
 507      5F524551 
 507      20737461 
 507      72743D25 
 508 0286 0000     		.align	2
 509              	.LC18:
 510 0288 4C314354 		.ascii	"L1CTL_RESET_REQ: FULL!\000"
 510      4C5F5245 
 510      5345545F 
 510      5245513A 
 510      2046554C 
 511 029f 00       		.align	2
 512              	.LC19:
 513 02a0 4C314354 		.ascii	"L1CTL_RESET_REQ: SCHED!\000"
 513      4C5F5245 
 513      5345545F 
 513      5245513A 
 513      20534348 
 514              		.align	2
 515              	.LC20:
 516 02b8 756E6B6E 		.ascii	"unknown L1CTL_RESET_REQ type\000"
 516      6F776E20 
 516      4C314354 
 516      4C5F5245 
 516      5345545F 
 517 02d5 000000   		.align	2
 518              	.LC21:
 519 02d8 4C314354 		.ascii	"L1CTL_TCH_MODE_REQ (tch_mode=0x%02x audio_mode=0x%0"
 519      4C5F5443 
 519      485F4D4F 
 519      44455F52 
 519      45512028 
 520 030b 3278290A 		.ascii	"2x)\012\000"
 520      00
 521              		.align	2
 522              	.LC22:
 523 0310 4C314354 		.ascii	"L1CTL_NEIGH_PM_REQ new list with %u entries\012\000"
 523      4C5F4E45 
 523      4947485F 
 523      504D5F52 
 523      4551206E 
 524 033d 000000   		.align	2
 525              	.LC23:
 526 0340 64726F70 		.ascii	"dropping traffic frame\000"
 526      70696E67 
 526      20747261 
 526      66666963 
 526      20667261 
 527 0357 00       		.align	2
 528              	.LC24:
 529 0358 53494D20 		.ascii	"SIM Request (%u): \000"
 529      52657175 
 529      65737420 
 529      28257529 
 529      3A2000
 530 036b 00       		.align	2
 531              	.LC25:
 532 036c 25303278 		.ascii	"%02x \000"
 532      2000
 533 0372 0000     		.align	2
 534              	.LC26:
 535 0374 0A00     		.ascii	"\012\000"
 536 0376 0000     		.section	.text.l1a_l23_handler,"ax",%progbits
 537              		.align	2
 538              		.global	l1a_l23_handler
 540              	l1a_l23_handler:
 541              	.LFB85:
 636:layer1/l23_api.c **** 
 637:layer1/l23_api.c **** void l1a_l23_handler(void)
 638:layer1/l23_api.c **** {
 542              		.loc 3 638 0
 543              		@ args = 0, pretend = 0, frame = 0
 544              		@ frame_needed = 0, uses_anonymous_args = 0
 545              	.LVL41:
 546 0000 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 547              	.LCFI7:
 548 0004 08D04DE2 		sub	sp, sp, #8
 549              	.LCFI8:
 550              	.LVL42:
 551              	.LBB15:
 639:layer1/l23_api.c **** 	struct msgb *msg;
 640:layer1/l23_api.c **** 	struct l1ctl_hdr *l1h;
 641:layer1/l23_api.c **** 	unsigned long flags;
 642:layer1/l23_api.c **** 
 643:layer1/l23_api.c **** 	local_firq_save(flags);
 552              		.loc 3 643 0
 553 0008 00400FE1 		mrs	r4, cpsr		@ local_firq_save
 554 000c C03084E3 		orr	r3, r4, #0xC0
 555 0010 03F021E1 		msr	cpsr_c, r3
 556              	.LVL43:
 557              	.LBE15:
 644:layer1/l23_api.c **** 	msg = msgb_dequeue(&l23_rx_queue);
 558              		.loc 3 644 0
 559 0014 44099FE5 		ldr	r0, .L152
 560 0018 FEFFFFEB 		bl	msgb_dequeue
 561              	.LVL44:
 562 001c 00A0A0E1 		mov	sl, r0
 563              	.LVL45:
 645:layer1/l23_api.c **** 	local_irq_restore(flags);
 564              		.loc 3 645 0
 565 0020 04F021E1 		msr	cpsr_c, r4		@ local_irq_restore
 566              	
 646:layer1/l23_api.c **** 	if (!msg)
 567              		.loc 3 646 0
 568 0024 000050E3 		cmp	r0, #0
 569 0028 5402000A 		beq	.L144
 570              	.LVL46:
 647:layer1/l23_api.c **** 		return;
 648:layer1/l23_api.c **** 
 649:layer1/l23_api.c **** 	l1h = (struct l1ctl_hdr *) msg->data;
 650:layer1/l23_api.c **** 
 651:layer1/l23_api.c **** #if 0
 652:layer1/l23_api.c **** 	{
 653:layer1/l23_api.c **** 		int i;
 654:layer1/l23_api.c **** 		printf("l1a_l23_rx_cb (%u): ", msg->len);
 655:layer1/l23_api.c **** 		for (i = 0; i < msg->len; i++)
 656:layer1/l23_api.c **** 			printf("%02x ", msg->data[i]);
 657:layer1/l23_api.c **** 		puts("\n");
 658:layer1/l23_api.c **** 	}
 659:layer1/l23_api.c **** #endif
 660:layer1/l23_api.c **** 
 661:layer1/l23_api.c **** 	msg->l1h = msg->data;
 662:layer1/l23_api.c **** 
 663:layer1/l23_api.c **** 	if (sizeof(*l1h) > msg->len) {
 571              		.loc 3 663 0
 572 002c B613D0E1 		ldrh	r1, [r0, #54]
 573              		.loc 3 649 0
 574 0030 403090E5 		ldr	r3, [r0, #64]
 575              	.LVL47:
 576              		.loc 3 663 0
 577 0034 030051E3 		cmp	r1, #3
 578              		.loc 3 661 0
 579 0038 103080E5 		str	r3, [r0, #16]
 664:layer1/l23_api.c **** 		printf("l1a_l23_cb: Short message. %u\n", msg->len);
 580              		.loc 3 664 0
 581 003c 20099F95 		ldrls	r0, .L152+4
 582              	.LVL48:
 583              		.loc 3 663 0
 584 0040 3500009A 		bls	.L148
 665:layer1/l23_api.c **** 		goto exit_msgbfree;
 666:layer1/l23_api.c **** 	}
 667:layer1/l23_api.c **** 
 668:layer1/l23_api.c **** 	switch (l1h->msg_type) {
 585              		.loc 3 668 0
 586 0044 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 587              	.LVL49:
 588 0048 013043E2 		sub	r3, r3, #1
 589 004c 1B0053E3 		cmp	r3, #27
 590 0050 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 591 0054 500200EA 		b	.L45
 592              		.p2align 2
 593              	.L61:
 594 0058 C8000000 		.word	.L46
 595 005c 48090000 		.word	.L45
 596 0060 48090000 		.word	.L45
 597 0064 4C050000 		.word	.L47
 598 0068 2C010000 		.word	.L48
 599 006c A0050000 		.word	.L49
 600 0070 48090000 		.word	.L45
 601 0074 2C060000 		.word	.L50
 602 0078 48090000 		.word	.L45
 603 007c 48090000 		.word	.L45
 604 0080 48090000 		.word	.L45
 605 0084 48090000 		.word	.L45
 606 0088 C0060000 		.word	.L51
 607 008c 48090000 		.word	.L45
 608 0090 48090000 		.word	.L45
 609 0094 30070000 		.word	.L52
 610 0098 48090000 		.word	.L45
 611 009c A4030000 		.word	.L53
 612 00a0 0C040000 		.word	.L54
 613 00a4 40040000 		.word	.L55
 614 00a8 08050000 		.word	.L56
 615 00ac F4080000 		.word	.L57
 616 00b0 48090000 		.word	.L45
 617 00b4 A0070000 		.word	.L58
 618 00b8 48090000 		.word	.L45
 619 00bc 28080000 		.word	.L59
 620 00c0 48090000 		.word	.L45
 621 00c4 C0080000 		.word	.L60
 622              	.L46:
 623              	.LBB16:
 624              	.LBB17:
 625              		.loc 3 234 0
 626 00c8 40309AE5 		ldr	r3, [sl, #64]
 627              		.loc 3 236 0
 628 00cc 0C0051E3 		cmp	r1, #12
 629              		.loc 3 234 0
 630 00d0 044083E2 		add	r4, r3, #4
 631              	.LVL50:
 632              		.loc 3 236 0
 633 00d4 3700008A 		bhi	.L62
 634              		.loc 3 237 0
 635 00d8 88089FE5 		ldr	r0, .L152+8
 636              	.LVL51:
 637              	.L148:
 638 00dc FEFFFFEB 		bl	printf
 639              	.LVL52:
 640 00e0 500200EA 		b	.L45
 641              	.LVL53:
 642              	.L62:
 643              		.loc 3 241 0
 644 00e4 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 645 00e8 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 646 00ec 000483E1 		orr	r0, r3, r0, asl #8
 647 00f0 FEFFFFEB 		bl	__fswab16
 648 00f4 0920D4E5 		ldrb	r2, [r4, #9]	@ zero_extendqisi2
 649 00f8 0010A0E1 		mov	r1, r0
 650 00fc 68089FE5 		ldr	r0, .L152+12
 651 0100 FEFFFFEB 		bl	printf
 652              		.loc 3 245 0
 653 0104 FEFFFFEB 		bl	l1s_reset
 654              		.loc 3 248 0
 655 0108 0B20D4E5 		ldrb	r2, [r4, #11]	@ zero_extendqisi2
 656 010c 5C389FE5 		ldr	r3, .L152+16
 657              		.loc 3 250 0
 658 0110 5C089FE5 		ldr	r0, .L152+20
 659              		.loc 3 248 0
 660 0114 1B20C3E5 		strb	r2, [r3, #27]
 661              		.loc 3 250 0
 662 0118 FEFFFFEB 		bl	puts
 663              		.loc 3 251 0
 664 011c 0410A0E1 		mov	r1, r4
 665 0120 0100A0E3 		mov	r0, #1
 666 0124 FEFFFFEB 		bl	l1s_fbsb_req
 667 0128 500200EA 		b	.L45
 668              	.LVL54:
 669              	.L48:
 670              	.LBE17:
 671              	.LBE16:
 672              	.LBB18:
 673              	.LBB19:
 674              		.loc 3 258 0
 675 012c 40409AE5 		ldr	r4, [sl, #64]
 676              	.LVL55:
 677 0130 048084E2 		add	r8, r4, #4
 678              	.LVL56:
 679              		.loc 3 259 0
 680 0134 045088E2 		add	r5, r8, #4
 681              	.LVL57:
 682              		.loc 3 261 0
 683 0138 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 684 013c 0300D5E5 		ldrb	r0, [r5, #3]	@ zero_extendqisi2
 685 0140 000483E1 		orr	r0, r3, r0, asl #8
 686 0144 FEFFFFEB 		bl	__fswab16
 687 0148 0420D4E5 		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 688 014c 0010A0E1 		mov	r1, r0
 689 0150 0430D8E5 		ldrb	r3, [r8, #4]	@ zero_extendqisi2
 690 0154 1C089FE5 		ldr	r0, .L152+24
 691 0158 FEFFFFEB 		bl	printf
 692              		.loc 3 265 0
 693 015c 1800A0E3 		mov	r0, #24
 694 0160 FEFFFFEB 		bl	mframe_disable
 695              	.LBB20:
 696              	.LBB21:
 697              		.loc 3 151 0
 698 0164 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 699 0168 A321A0E1 		mov	r2, r3, lsr #3
 700              		.loc 3 153 0
 701 016c 010052E3 		cmp	r2, #1
 702 0170 0630A003 		moveq	r3, #6
 703 0174 7200000A 		beq	.L66
 704              		.loc 3 155 0
 705 0178 1E3002E2 		and	r3, r2, #30
 706 017c 020053E3 		cmp	r3, #2
 707 0180 03308302 		addeq	r3, r3, #3
 708 0184 7200000A 		beq	.L66
 709              		.loc 3 157 0
 710 0188 1C3002E2 		and	r3, r2, #28
 711 018c 040053E3 		cmp	r3, #4
 712 0190 0130A003 		moveq	r3, #1
 713 0194 7200000A 		beq	.L66
 714              		.loc 3 159 0
 715 0198 183002E2 		and	r3, r2, #24
 716 019c 080053E3 		cmp	r3, #8
 717 01a0 0330A003 		moveq	r3, #3
 718 01a4 7200000A 		beq	.L66
 719              		.loc 3 161 0
 720 01a8 1F3002E2 		and	r3, r2, #31
 721 01ac 180053E3 		cmp	r3, #24
 722 01b0 0730A003 		moveq	r3, #7
 723 01b4 7200000A 		beq	.L66
 724              		.loc 3 164 0
 725 01b8 190053E3 		cmp	r3, #25
 726 01bc 0230A003 		moveq	r3, #2
 727 01c0 7200000A 		beq	.L66
 728              		.loc 3 167 0
 729 01c4 1A0053E3 		cmp	r3, #26
 730 01c8 0830A013 		movne	r3, #8
 731 01cc 0430A003 		moveq	r3, #4
 732              	.L66:
 733              	.LBE21:
 734              	.LBE20:
 735              		.loc 3 268 0
 736 01d0 98679FE5 		ldr	r6, .L152+16
 737 01d4 0C3B86E5 		str	r3, [r6, #2828]
 738              		.loc 3 269 0
 739 01d8 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 740 01dc 113BC6E5 		strb	r3, [r6, #2833]
 741              		.loc 3 270 0
 742 01e0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 743 01e4 073003E2 		and	r3, r3, #7
 744 01e8 123BC6E5 		strb	r3, [r6, #2834]
 745              		.loc 3 271 0
 746 01ec 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 747 01f0 133BC6E5 		strb	r3, [r6, #2835]
 748              		.loc 3 273 0
 749 01f4 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 750 01f8 000053E3 		cmp	r3, #0
 751 01fc 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 752 0200 9300000A 		beq	.L79
 753              	.LBB22:
 754              		.loc 3 275 0
 755 0204 143BC6E5 		strb	r3, [r6, #2836]
 756              		.loc 3 276 0
 757 0208 0330D5E5 		ldrb	r3, [r5, #3]	@ zero_extendqisi2
 758 020c 153BC6E5 		strb	r3, [r6, #2837]
 759              		.loc 3 277 0
 760 0210 64979FE5 		ldr	r9, .L152+28
 761 0214 0430D5E5 		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 762 0218 0070A0E3 		mov	r7, #0
 763              	.LVL58:
 764 021c 044085E2 		add	r4, r5, #4
 765 0220 163BC6E5 		strb	r3, [r6, #2838]
 766 0224 8E0000EA 		b	.L81
 767              	.L82:
 768              		.loc 3 279 0
 769 0228 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 770 022c 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 771 0230 000483E1 		orr	r0, r3, r0, asl #8
 772 0234 FEFFFFEB 		bl	__fswab16
 773 0238 B200C9E0 		strh	r0, [r9], #2	@ movhi
 774              		.loc 3 278 0
 775 023c 024084E2 		add	r4, r4, #2
 776              	.L81:
 777 0240 0430D5E5 		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 778 0244 030057E1 		cmp	r7, r3
 779 0248 017087E2 		add	r7, r7, #1
 780 024c 880000BA 		blt	.L82
 781 0250 980000EA 		b	.L83
 782              	.LVL59:
 783              	.L79:
 784              	.LBE22:
 785              		.loc 3 281 0
 786 0254 0300D5E5 		ldrb	r0, [r5, #3]	@ zero_extendqisi2
 787 0258 000483E1 		orr	r0, r3, r0, asl #8
 788 025c FEFFFFEB 		bl	__fswab16
 789 0260 18379FE5 		ldr	r3, .L152+32
 790 0264 B30086E1 		strh	r0, [r6, r3]	@ movhi
 791              	.LVL60:
 792              	.L83:
 793              	.LBB23:
 794              	.LBB24:
 795              		.loc 3 177 0
 796 0268 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 797 026c A331A0E1 		mov	r3, r3, lsr #3
 798 0270 010053E3 		cmp	r3, #1
 799 0274 9F00000A 		beq	.L84
 800 0278 1E3003E2 		and	r3, r3, #30
 801 027c 020053E3 		cmp	r3, #2
 802 0280 A900001A 		bne	.L86
 803              	.L84:
 804              	.LBE24:
 805              	.LBE23:
 806              		.loc 3 287 0
 807 0284 8600D5E5 		ldrb	r0, [r5, #134]	@ zero_extendqisi2
 808 0288 FEFFFFEB 		bl	l1a_tch_mode_set
 809              		.loc 3 288 0
 810 028c 8700D5E5 		ldrb	r0, [r5, #135]	@ zero_extendqisi2
 811 0290 FEFFFFEB 		bl	l1a_audio_mode_set
 812              		.loc 3 291 0
 813 0294 D4369FE5 		ldr	r3, .L152+16
 814 0298 0120A0E3 		mov	r2, #1
 815 029c 4B2AC3E5 		strb	r2, [r3, #2635]
 816              		.loc 3 294 0
 817 02a0 8710D5E5 		ldrb	r1, [r5, #135]	@ zero_extendqisi2
 818 02a4 8600D5E5 		ldrb	r0, [r5, #134]	@ zero_extendqisi2
 819 02a8 FEFFFFEB 		bl	audio_set_enabled
 820              	.L86:
 821 02ac 0040D8E5 		ldrb	r4, [r8, #0]	@ zero_extendqisi2
 822              	.LBB25:
 823              	.LBB26:
 824              		.loc 3 77 0
 825 02b0 A421A0E1 		mov	r2, r4, lsr #3
 826              		.loc 3 85 0
 827 02b4 010052E3 		cmp	r2, #1
 828 02b8 B400001A 		bne	.L87
 829              		.loc 3 87 0
 830 02bc 010014E3 		tst	r4, #1
 831 02c0 1300A013 		movne	r0, #19
 832              	.LVL61:
 833 02c4 0020E013 		mvnne	r2, #0
 834              	.LVL62:
 835 02c8 0210A013 		movne	r1, #2
 836              	.LVL63:
 837 02cc 1200A003 		moveq	r0, #18
 838 02d0 BC00000A 		beq	.L94
 839 02d4 DA0000EA 		b	.L91
 840              	.LVL64:
 841              	.L87:
 842              		.loc 3 89 0
 843 02d8 1E1002E2 		and	r1, r2, #30
 844 02dc 020051E3 		cmp	r1, #2
 845 02e0 BF00001A 		bne	.L92
 846              		.loc 3 91 0
 847 02e4 013002E2 		and	r3, r2, #1
 848              		.loc 3 92 0
 849 02e8 000053E3 		cmp	r3, #0
 850              		.loc 3 91 0
 851 02ec 140083E2 		add	r0, r3, #20
 852              	.LVL65:
 853              		.loc 3 92 0
 854 02f0 0020E013 		mvnne	r2, #0
 855              	.LVL66:
 856 02f4 DA00001A 		bne	.L91
 857              	.LVL67:
 858              	.L94:
 859 02f8 0020E0E3 		mvn	r2, #0
 860 02fc 0310A0E3 		mov	r1, #3
 861 0300 DA0000EA 		b	.L91
 862              	.LVL68:
 863              	.L92:
 864              		.loc 3 93 0
 865 0304 1C3002E2 		and	r3, r2, #28
 866 0308 040053E3 		cmp	r3, #4
 867              		.loc 3 95 0
 868 030c 03300202 		andeq	r3, r2, #3
 869 0310 04008302 		addeq	r0, r3, #4
 870              	.LVL69:
 871              		.loc 3 93 0
 872 0314 D800000A 		beq	.L146
 873              		.loc 3 97 0
 874 0318 183002E2 		and	r3, r2, #24
 875 031c 080053E3 		cmp	r3, #8
 876              		.loc 3 99 0
 877 0320 07300202 		andeq	r3, r2, #7
 878 0324 08008302 		addeq	r0, r3, #8
 879              		.loc 3 97 0
 880 0328 D800000A 		beq	.L146
 881              		.loc 3 101 0
 882 032c 1F3002E2 		and	r3, r2, #31
 883 0330 180053E3 		cmp	r3, #24
 884 0334 1600A003 		moveq	r0, #22
 885 0338 1720A003 		moveq	r2, #23
 886              	.LVL70:
 887 033c 0010A003 		moveq	r1, #0
 888              	.LVL71:
 889 0340 DA00000A 		beq	.L91
 890              		.loc 3 107 0
 891 0344 190053E3 		cmp	r3, #25
 892 0348 1000A003 		moveq	r0, #16
 893 034c D800000A 		beq	.L146
 894              		.loc 3 111 0
 895 0350 1A0053E3 		cmp	r3, #26
 896 0354 0000A013 		movne	r0, #0
 897 0358 0020E013 		mvnne	r2, #0
 898 035c 0010A011 		movne	r1, r0
 899 0360 DA00001A 		bne	.L91
 900 0364 1100A0E3 		mov	r0, #17
 901              	.L146:
 902 0368 0020E0E3 		mvn	r2, #0
 903 036c 0110A0E3 		mov	r1, #1
 904              	.L91:
 905              		.loc 3 128 0
 906 0370 0130A0E3 		mov	r3, #1
 907 0374 1322A0E1 		mov	r2, r3, asl r2
 908              	.LVL72:
 909 0378 130082E1 		orr	r0, r2, r3, asl r0
 910              	.LVL73:
 911              		.loc 3 132 0
 912 037c 020051E3 		cmp	r1, #2
 913              		.loc 3 140 0
 914 0380 02038003 		orreq	r0, r0, #134217728
 915              		.loc 3 132 0
 916 0384 E500000A 		beq	.L106
 917 0388 030051E3 		cmp	r1, #3
 918              		.loc 3 137 0
 919 038c 01038003 		orreq	r0, r0, #67108864
 920              		.loc 3 132 0
 921 0390 E500000A 		beq	.L106
 922 0394 030051E1 		cmp	r1, r3
 923              		.loc 3 134 0
 924 0398 02048003 		orreq	r0, r0, #33554432
 925              	.L106:
 926              	.LBE26:
 927              	.LBE25:
 928              		.loc 3 298 0
 929 039c FEFFFFEB 		bl	l1a_mftask_set
 930              	.LVL74:
 931 03a0 500200EA 		b	.L45
 932              	.LVL75:
 933              	.L53:
 934              	.LBE19:
 935              	.LBE18:
 936              	.LBB27:
 937              	.LBB28:
 938              		.loc 3 354 0
 939 03a4 C4559FE5 		ldr	r5, .L152+16
 940              		.loc 3 352 0
 941 03a8 D4059FE5 		ldr	r0, .L152+36
 942              		.loc 3 354 0
 943 03ac 0040A0E3 		mov	r4, #0
 944              	.LVL76:
 945              		.loc 3 352 0
 946 03b0 FEFFFFEB 		bl	puts
 947              		.loc 3 353 0
 948 03b4 0000A0E3 		mov	r0, #0
 949 03b8 FEFFFFEB 		bl	l1a_mftask_set
 950              		.loc 3 355 0
 951 03bc C4059FE5 		ldr	r0, .L152+40
 952              		.loc 3 354 0
 953 03c0 0C4B85E5 		str	r4, [r5, #2828]
 954              		.loc 3 355 0
 955 03c4 FEFFFFEB 		bl	l1a_txq_msgb_flush
 956              		.loc 3 356 0
 957 03c8 BC059FE5 		ldr	r0, .L152+44
 958 03cc FEFFFFEB 		bl	l1a_txq_msgb_flush
 959              		.loc 3 357 0
 960 03d0 B8059FE5 		ldr	r0, .L152+48
 961 03d4 FEFFFFEB 		bl	l1a_txq_msgb_flush
 962              		.loc 3 358 0
 963 03d8 0400A0E1 		mov	r0, r4
 964 03dc FEFFFFEB 		bl	l1a_meas_msgb_set
 965              		.loc 3 359 0
 966 03e0 0410A0E1 		mov	r1, r4
 967 03e4 0400A0E1 		mov	r0, r4
 968 03e8 FEFFFFEB 		bl	dsp_load_ciph_param
 969              		.loc 3 360 0
 970 03ec 0400A0E1 		mov	r0, r4
 971 03f0 FEFFFFEB 		bl	l1a_tch_mode_set
 972              		.loc 3 361 0
 973 03f4 0400A0E1 		mov	r0, r4
 974 03f8 0410A0E1 		mov	r1, r4
 975 03fc FEFFFFEB 		bl	audio_set_enabled
 976              		.loc 3 363 0
 977 0400 204CC5E5 		strb	r4, [r5, #3104]
 978              		.loc 3 362 0
 979 0404 504A85E5 		str	r4, [r5, #2640]
 980 0408 500200EA 		b	.L45
 981              	.LVL77:
 982              	.L54:
 983              	.LBE28:
 984              	.LBE27:
 985              	.LBB29:
 986              	.LBB30:
 987              		.loc 3 371 0
 988 040c 40409AE5 		ldr	r4, [sl, #64]
 989              	.LVL78:
 990 0410 044084E2 		add	r4, r4, #4
 991 0414 045084E2 		add	r5, r4, #4
 992              	.LVL79:
 993              		.loc 3 373 0
 994 0418 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 995 041c 70059FE5 		ldr	r0, .L152+52
 996 0420 D410D4E1 		ldrsb	r1, [r4, #4]
 997 0424 FEFFFFEB 		bl	printf
 998              		.loc 3 376 0
 999 0428 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1000 042c 3C259FE5 		ldr	r2, .L152+16
 1001 0430 483AC2E5 		strb	r3, [r2, #2632]
 1002              		.loc 3 377 0
 1003 0434 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 1004 0438 493AC2E5 		strb	r3, [r2, #2633]
 1005 043c 500200EA 		b	.L45
 1006              	.LVL80:
 1007              	.L55:
 1008              	.LBE30:
 1009              	.LBE29:
 1010              	.LBB31:
 1011              	.LBB32:
 1012              		.loc 3 307 0
 1013 0440 40309AE5 		ldr	r3, [sl, #64]
 1014 0444 084083E2 		add	r4, r3, #8
 1015              	.LVL81:
 1016              		.loc 3 309 0
 1017 0448 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1018 044c 0500D4E5 		ldrb	r0, [r4, #5]	@ zero_extendqisi2
 1019 0450 000483E1 		orr	r0, r3, r0, asl #8
 1020 0454 FEFFFFEB 		bl	__fswab16
 1021 0458 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 1022 045c 0010A0E1 		mov	r1, r0
 1023 0460 30059FE5 		ldr	r0, .L152+56
 1024 0464 FEFFFFEB 		bl	printf
 1025              		.loc 3 313 0
 1026 0468 00659FE5 		ldr	r6, .L152+16
 1027 046c 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1028 0470 983BC6E5 		strb	r3, [r6, #2968]
 1029              		.loc 3 314 0
 1030 0474 0330D4E5 		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 1031 0478 9A3BC6E5 		strb	r3, [r6, #2970]
 1032              		.loc 3 316 0
 1033 047c 0330D4E5 		ldrb	r3, [r4, #3]	@ zero_extendqisi2
 1034 0480 000053E3 		cmp	r3, #0
 1035 0484 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1036 0488 3501000A 		beq	.L110
 1037              	.LBB33:
 1038              		.loc 3 318 0
 1039 048c 9C3BC6E5 		strb	r3, [r6, #2972]
 1040              		.loc 3 319 0
 1041 0490 0530D4E5 		ldrb	r3, [r4, #5]	@ zero_extendqisi2
 1042 0494 9D3BC6E5 		strb	r3, [r6, #2973]
 1043              		.loc 3 320 0
 1044 0498 0630D4E5 		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 1045 049c BA8E86E2 		add	r8, r6, #2976
 1046 04a0 0070A0E3 		mov	r7, #0
 1047              	.LVL82:
 1048 04a4 0450A0E1 		mov	r5, r4
 1049 04a8 9E3BC6E5 		strb	r3, [r6, #2974]
 1050 04ac 300100EA 		b	.L112
 1051              	.L113:
 1052              		.loc 3 322 0
 1053 04b0 0830D5E5 		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 1054 04b4 0900D5E5 		ldrb	r0, [r5, #9]	@ zero_extendqisi2
 1055 04b8 000483E1 		orr	r0, r3, r0, asl #8
 1056 04bc FEFFFFEB 		bl	__fswab16
 1057 04c0 B200C8E0 		strh	r0, [r8], #2	@ movhi
 1058              		.loc 3 321 0
 1059 04c4 025085E2 		add	r5, r5, #2
 1060              	.LVL83:
 1061              	.L112:
 1062 04c8 0630D4E5 		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 1063 04cc 030057E1 		cmp	r7, r3
 1064 04d0 017087E2 		add	r7, r7, #1
 1065 04d4 2A0100BA 		blt	.L113
 1066              	.LVL84:
 1067 04d8 3A0100EA 		b	.L114
 1068              	.LVL85:
 1069              	.L110:
 1070              	.LBE33:
 1071              		.loc 3 324 0
 1072 04dc 0500D4E5 		ldrb	r0, [r4, #5]	@ zero_extendqisi2
 1073 04e0 000483E1 		orr	r0, r3, r0, asl #8
 1074 04e4 FEFFFFEB 		bl	__fswab16
 1075 04e8 AC349FE5 		ldr	r3, .L152+60
 1076 04ec B30086E1 		strh	r0, [r6, r3]	@ movhi
 1077              	.LVL86:
 1078              	.L114:
 1079              		.loc 3 327 0
 1080 04f0 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1081 04f4 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 1082 04f8 030480E1 		orr	r0, r0, r3, asl #8
 1083 04fc FEFFFFEB 		bl	__fswab16
 1084 0500 FEFFFFEB 		bl	l1a_freq_req
 1085 0504 500200EA 		b	.L45
 1086              	.LVL87:
 1087              	.L56:
 1088              	.LBE32:
 1089              	.LBE31:
 1090              	.LBB34:
 1091              	.LBB35:
 1092              		.loc 3 335 0
 1093 0508 40409AE5 		ldr	r4, [sl, #64]
 1094              	.LVL88:
 1095 050c 044084E2 		add	r4, r4, #4
 1096 0510 045084E2 		add	r5, r4, #4
 1097              	.LVL89:
 1098              		.loc 3 337 0
 1099 0514 84049FE5 		ldr	r0, .L152+64
 1100 0518 0410D4E5 		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 1101 051c 0120D5E5 		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 1102 0520 FEFFFFEB 		bl	printf
 1103              		.loc 3 339 0
 1104 0524 0400D4E5 		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1105 0528 000050E3 		cmp	r0, #0
 1106 052c 4E01000A 		beq	.L115
 1107 0530 0130D5E5 		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 1108 0534 080053E3 		cmp	r3, #8
 1109              		.loc 3 340 0
 1110 0538 64049F15 		ldrne	r0, .L152+68
 1111              		.loc 3 339 0
 1112 053c C801001A 		bne	.L149
 1113              	.L115:
 1114              		.loc 3 344 0
 1115 0540 021085E2 		add	r1, r5, #2
 1116 0544 FEFFFFEB 		bl	dsp_load_ciph_param
 1117 0548 500200EA 		b	.L45
 1118              	.LVL90:
 1119              	.L47:
 1120              	.LBE35:
 1121              	.LBE34:
 1122              	.LBB36:
 1123              	.LBB37:
 1124              		.loc 3 385 0
 1125 054c 40609AE5 		ldr	r6, [sl, #64]
 1126 0550 046086E2 		add	r6, r6, #4
 1127 0554 044086E2 		add	r4, r6, #4
 1128              	.LVL91:
 1129              		.loc 3 387 0
 1130 0558 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1131 055c 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 1132 0560 000483E1 		orr	r0, r3, r0, asl #8
 1133 0564 FEFFFFEB 		bl	__fswab16
 1134 0568 0450D6E5 		ldrb	r5, [r6, #4]	@ zero_extendqisi2
 1135 056c 0020A0E1 		mov	r2, r0
 1136 0570 0510A0E1 		mov	r1, r5
 1137 0574 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1138 0578 28049FE5 		ldr	r0, .L152+72
 1139 057c FEFFFFEB 		bl	printf
 1140              		.loc 3 390 0
 1141 0580 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1142 0584 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 1143 0588 000483E1 		orr	r0, r3, r0, asl #8
 1144 058c FEFFFFEB 		bl	__fswab16
 1145 0590 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
 1146 0594 0420D6E5 		ldrb	r2, [r6, #4]	@ zero_extendqisi2
 1147 0598 FEFFFFEB 		bl	l1a_rach_req
 1148 059c 500200EA 		b	.L45
 1149              	.LVL92:
 1150              	.L49:
 1151              	.LBE37:
 1152              	.LBE36:
 1153              	.LBB38:
 1154              	.LBB39:
 1155              		.loc 3 398 0
 1156 05a0 40609AE5 		ldr	r6, [sl, #64]
 1157 05a4 044086E2 		add	r4, r6, #4
 1158              	.LVL93:
 1159              		.loc 3 399 0
 1160 05a8 045084E2 		add	r5, r4, #4
 1161              	.LVL94:
 1162              		.loc 3 402 0
 1163 05ac F8039FE5 		ldr	r0, .L152+76
 1164 05b0 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
 1165 05b4 FEFFFFEB 		bl	printf
 1166              		.loc 3 404 0
 1167 05b8 18508AE5 		str	r5, [sl, #24]
 1168              		.loc 3 405 0
 1169 05bc 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1170 05c0 400013E3 		tst	r3, #64
 1171 05c4 BC639F05 		ldreq	r6, .L152+40
 1172              	.LVL95:
 1173 05c8 7F01000A 		beq	.L120
 1174              	.LBB40:
 1175              		.loc 3 407 0
 1176 05cc 0930D4E5 		ldrb	r3, [r4, #9]	@ zero_extendqisi2
 1177 05d0 060053E3 		cmp	r3, #6
 1178              	.LVL96:
 1179              		.loc 3 406 0
 1180 05d4 0D3086E2 		add	r3, r6, #13
 1181              	.LVL97:
 1182              		.loc 3 407 0
 1183 05d8 7E01001A 		bne	.L121
 1184 05dc 0130D3E5 		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1185              	.LVL98:
 1186 05e0 150053E3 		cmp	r3, #21
 1187 05e4 7E01001A 		bne	.L121
 1188              		.loc 3 409 0
 1189 05e8 C0039FE5 		ldr	r0, .L152+80
 1190 05ec FEFFFFEB 		bl	puts
 1191              		.loc 3 410 0
 1192 05f0 0A00A0E1 		mov	r0, sl
 1193              	.LBE40:
 1194              	.LBE39:
 1195              	.LBE38:
 669:layer1/l23_api.c **** 	case L1CTL_FBSB_REQ:
 670:layer1/l23_api.c **** 		l1ctl_rx_fbsb_req(msg);
 671:layer1/l23_api.c **** 		break;
 672:layer1/l23_api.c **** 	case L1CTL_DM_EST_REQ:
 673:layer1/l23_api.c **** 		l1ctl_rx_dm_est_req(msg);
 674:layer1/l23_api.c **** 		break;
 675:layer1/l23_api.c **** 	case L1CTL_DM_REL_REQ:
 676:layer1/l23_api.c **** 		l1ctl_rx_dm_rel_req(msg);
 677:layer1/l23_api.c **** 		break;
 678:layer1/l23_api.c **** 	case L1CTL_PARAM_REQ:
 679:layer1/l23_api.c **** 		l1ctl_rx_param_req(msg);
 680:layer1/l23_api.c **** 		break;
 681:layer1/l23_api.c **** 	case L1CTL_DM_FREQ_REQ:
 682:layer1/l23_api.c **** 		l1ctl_rx_dm_freq_req(msg);
 683:layer1/l23_api.c **** 		break;
 684:layer1/l23_api.c **** 	case L1CTL_CRYPTO_REQ:
 685:layer1/l23_api.c **** 		l1ctl_rx_crypto_req(msg);
 686:layer1/l23_api.c **** 		break;
 687:layer1/l23_api.c **** 	case L1CTL_RACH_REQ:
 688:layer1/l23_api.c **** 		l1ctl_rx_rach_req(msg);
 689:layer1/l23_api.c **** 		break;
 690:layer1/l23_api.c **** 	case L1CTL_DATA_REQ:
 691:layer1/l23_api.c **** 		l1ctl_rx_data_req(msg);
 692:layer1/l23_api.c **** 		/* we have to keep the msgb, not free it! */
 693:layer1/l23_api.c **** 		goto exit_nofree;
 694:layer1/l23_api.c **** 	case L1CTL_PM_REQ:
 695:layer1/l23_api.c **** 		l1ctl_rx_pm_req(msg);
 696:layer1/l23_api.c **** 		break;
 697:layer1/l23_api.c **** 	case L1CTL_RESET_REQ:
 698:layer1/l23_api.c **** 		l1ctl_rx_reset_req(msg);
 699:layer1/l23_api.c **** 		break;
 700:layer1/l23_api.c **** 	case L1CTL_CCCH_MODE_REQ:
 701:layer1/l23_api.c **** 		l1ctl_rx_ccch_mode_req(msg);
 702:layer1/l23_api.c **** 		break;
 703:layer1/l23_api.c **** 	case L1CTL_TCH_MODE_REQ:
 704:layer1/l23_api.c **** 		l1ctl_rx_tch_mode_req(msg);
 705:layer1/l23_api.c **** 		break;
 706:layer1/l23_api.c **** 	case L1CTL_NEIGH_PM_REQ:
 707:layer1/l23_api.c **** 		l1ctl_rx_neigh_pm_req(msg);
 708:layer1/l23_api.c **** 		break;
 709:layer1/l23_api.c **** 	case L1CTL_TRAFFIC_REQ:
 710:layer1/l23_api.c **** 		l1ctl_rx_traffic_req(msg);
 711:layer1/l23_api.c **** 		/* we have to keep the msgb, not free it! */
 712:layer1/l23_api.c **** 		goto exit_nofree;
 713:layer1/l23_api.c **** 	case L1CTL_SIM_REQ:
 714:layer1/l23_api.c **** 		l1ctl_sim_req(msg);
 715:layer1/l23_api.c **** 		break;
 716:layer1/l23_api.c **** 	}
 717:layer1/l23_api.c **** 
 718:layer1/l23_api.c **** exit_msgbfree:
 719:layer1/l23_api.c **** 	msgb_free(msg);
 720:layer1/l23_api.c **** exit_nofree:
 721:layer1/l23_api.c **** 	return;
 722:layer1/l23_api.c **** }
 1196              		.loc 3 722 0
 1197 05f4 08D08DE2 		add	sp, sp, #8
 1198 05f8 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1199              	.LBB41:
 1200              	.LBB42:
 1201              	.LBB43:
 1202              		.loc 3 410 0
 1203 05fc FEFFFFEA 		b	l1a_meas_msgb_set
 1204              	.LVL99:
 1205              	.L121:
 1206 0600 84639FE5 		ldr	r6, .L152+44
 1207              	.LVL100:
 1208              	.L120:
 1209              	.LBE43:
 1210              		.loc 3 417 0
 1211 0604 0410A0E1 		mov	r1, r4
 1212 0608 0530A0E1 		mov	r3, r5
 1213              	.LVL101:
 1214 060c A0039FE5 		ldr	r0, .L152+84
 1215 0610 042084E2 		add	r2, r4, #4
 1216 0614 00508DE5 		str	r5, [sp, #0]
 1217 0618 04508DE5 		str	r5, [sp, #4]
 1218 061c FEFFFFEB 		bl	printf
 1219              		.loc 3 420 0
 1220 0620 0600A0E1 		mov	r0, r6
 1221 0624 0A10A0E1 		mov	r1, sl
 1222 0628 380200EA 		b	.L151
 1223              	.LVL102:
 1224              	.L50:
 1225              	.LBE42:
 1226              	.LBE41:
 1227              	.LBB44:
 1228              	.LBB45:
 1229              		.loc 3 427 0
 1230 062c 40309AE5 		ldr	r3, [sl, #64]
 1231              		.loc 3 429 0
 1232 0630 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1233 0634 010052E3 		cmp	r2, #1
 1234              		.loc 3 427 0
 1235 0638 046083E2 		add	r6, r3, #4
 1236              	.LVL103:
 1237              		.loc 3 429 0
 1238 063c A701001A 		bne	.L124
 1239              		.loc 3 431 0
 1240 0640 28439FE5 		ldr	r4, .L152+16
 1241              	.LVL104:
 1242 0644 F82A84E5 		str	r2, [r4, #2808]
 1243              		.loc 3 432 0
 1244 0648 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 1245 064c 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 1246 0650 000483E1 		orr	r0, r3, r0, asl #8
 1247 0654 FEFFFFEB 		bl	__fswab16
 1248 0658 58539FE5 		ldr	r5, .L152+88
 1249 065c B50084E1 		strh	r0, [r4, r5]	@ movhi
 1250              		.loc 3 434 0
 1251 0660 0430D6E5 		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 1252 0664 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 1253 0668 000483E1 		orr	r0, r3, r0, asl #8
 1254 066c FEFFFFEB 		bl	__fswab16
 1255 0670 44339FE5 		ldr	r3, .L152+92
 1256 0674 B30084E1 		strh	r0, [r4, r3]	@ movhi
 1257              		.loc 3 436 0
 1258 0678 0730D6E5 		ldrb	r3, [r6, #7]	@ zero_extendqisi2
 1259 067c 0600D6E5 		ldrb	r0, [r6, #6]	@ zero_extendqisi2
 1260 0680 030480E1 		orr	r0, r0, r3, asl #8
 1261 0684 FEFFFFEB 		bl	__fswab16
 1262 0688 0B3CA0E3 		mov	r3, #2816
 1263 068c 00C0A0E1 		mov	ip, r0
 1264              		.loc 3 438 0
 1265 0690 0020A0E1 		mov	r2, r0
 1266 0694 B51094E1 		ldrh	r1, [r4, r5]
 1267 0698 20039FE5 		ldr	r0, .L152+96
 1268              		.loc 3 436 0
 1269 069c B3C084E1 		strh	ip, [r4, r3]	@ movhi
 1270              		.loc 3 438 0
 1271 06a0 FEFFFFEB 		bl	printf
 1272              	.LVL105:
 1273              	.L124:
 1274              		.loc 3 442 0
 1275 06a4 FEFFFFEB 		bl	l1s_reset_hw
 1276              		.loc 3 443 0
 1277 06a8 C0229FE5 		ldr	r2, .L152+16
 1278 06ac 08339FE5 		ldr	r3, .L152+92
 1279 06b0 0100A0E3 		mov	r0, #1
 1280 06b4 B31092E1 		ldrh	r1, [r2, r3]
 1281 06b8 FEFFFFEB 		bl	l1s_pm_test
 1282 06bc 500200EA 		b	.L45
 1283              	.LVL106:
 1284              	.L51:
 1285              	.LBE45:
 1286              	.LBE44:
 1287              	.LBB46:
 1288              	.LBB47:
 1289              		.loc 3 463 0
 1290 06c0 40409AE5 		ldr	r4, [sl, #64]
 1291              	.LVL107:
 1292              		.loc 3 465 0
 1293 06c4 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1294 06c8 010053E3 		cmp	r3, #1
 1295 06cc B601000A 		beq	.L127
 1296 06d0 020053E3 		cmp	r3, #2
 1297              		.loc 3 479 0
 1298 06d4 E8029F15 		ldrne	r0, .L152+100
 1299              		.loc 3 465 0
 1300 06d8 C801001A 		bne	.L149
 1301 06dc C10100EA 		b	.L128
 1302              	.L127:
 1303              		.loc 3 467 0
 1304 06e0 E0029FE5 		ldr	r0, .L152+104
 1305 06e4 FEFFFFEB 		bl	puts
 1306              		.loc 3 468 0
 1307 06e8 FEFFFFEB 		bl	l1s_reset
 1308              		.loc 3 469 0
 1309 06ec FEFFFFEB 		bl	l1s_reset_hw
 1310              		.loc 3 470 0
 1311 06f0 0000A0E3 		mov	r0, #0
 1312 06f4 0010A0E1 		mov	r1, r0
 1313 06f8 FEFFFFEB 		bl	audio_set_enabled
 1314              		.loc 3 471 0
 1315 06fc 0410D4E5 		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 1316 0700 0E00A0E3 		mov	r0, #14
 1317 0704 FEFFFFEB 		bl	l1ctl_tx_reset
 1318 0708 500200EA 		b	.L45
 1319              	.L128:
 1320              		.loc 3 474 0
 1321 070c B8029FE5 		ldr	r0, .L152+108
 1322 0710 FEFFFFEB 		bl	puts
 1323              		.loc 3 475 0
 1324 0714 0410D4E5 		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 1325 0718 0E00A0E3 		mov	r0, #14
 1326 071c FEFFFFEB 		bl	l1ctl_tx_reset
 1327              		.loc 3 476 0
 1328 0720 FEFFFFEB 		bl	sched_gsmtime_reset
 1329 0724 500200EA 		b	.L45
 1330              	.LVL108:
 1331              	.L149:
 1332              		.loc 3 479 0
 1333 0728 FEFFFFEB 		bl	puts
 1334 072c 500200EA 		b	.L45
 1335              	.LVL109:
 1336              	.L52:
 1337              	.LBE47:
 1338              	.LBE46:
 1339              	.LBB48:
 1340              	.LBB49:
 1341              		.loc 3 502 0
 1342 0730 40309AE5 		ldr	r3, [sl, #64]
 1343 0734 0450D3E5 		ldrb	r5, [r3, #4]	@ zero_extendqisi2
 1344              	.LVL110:
 1345              		.loc 3 505 0
 1346 0738 30329FE5 		ldr	r3, .L152+16
 1347              		.loc 3 508 0
 1348 073c 0300A0E3 		mov	r0, #3
 1349              		.loc 3 505 0
 1350 0740 1B50C3E5 		strb	r5, [r3, #27]
 1351              		.loc 3 508 0
 1352 0744 FEFFFFEB 		bl	mframe_disable
 1353              		.loc 3 509 0
 1354 0748 0200A0E3 		mov	r0, #2
 1355 074c FEFFFFEB 		bl	mframe_disable
 1356              		.loc 3 511 0
 1357 0750 020055E3 		cmp	r5, #2
 1358              		.loc 3 512 0
 1359 0754 0300A003 		moveq	r0, #3
 1360              		.loc 3 511 0
 1361 0758 DD01000A 		beq	.L147
 1362              		.loc 3 513 0
 1363 075c 010055E3 		cmp	r5, #1
 1364              		.loc 3 514 0
 1365 0760 0200A003 		moveq	r0, #2
 1366              		.loc 3 513 0
 1367 0764 DD01000A 		beq	.L147
 1368              		.loc 3 515 0
 1369 0768 030055E3 		cmp	r5, #3
 1370 076c DE01001A 		bne	.L131
 1371              		.loc 3 516 0
 1372 0770 0500A0E1 		mov	r0, r5
 1373 0774 FEFFFFEB 		bl	mframe_enable
 1374              		.loc 3 517 0
 1375 0778 1000A0E3 		mov	r0, #16
 1376              	.L147:
 1377 077c FEFFFFEB 		bl	mframe_enable
 1378              	.L131:
 1379              	.LBB50:
 1380              	.LBB51:
 1381              		.loc 3 487 0
 1382 0780 1100A0E3 		mov	r0, #17
 1383 0784 FEFFFFEB 		bl	l1ctl_msgb_alloc
 1384              		.loc 3 489 0
 1385 0788 0410A0E3 		mov	r1, #4
 1386              		.loc 3 487 0
 1387 078c 0040A0E1 		mov	r4, r0
 1388              	.LVL111:
 1389              		.loc 3 489 0
 1390 0790 FEFFFFEB 		bl	msgb_put
 1391              		.loc 3 491 0
 1392 0794 0050C0E5 		strb	r5, [r0, #0]
 1393              		.loc 3 493 0
 1394 0798 0400A0E1 		mov	r0, r4
 1395 079c 060200EA 		b	.L150
 1396              	.LVL112:
 1397              	.L58:
 1398              	.LBE51:
 1399              	.LBE50:
 1400              	.LBE49:
 1401              	.LBE48:
 1402              	.LBB52:
 1403              	.LBB53:
 1404              		.loc 3 542 0
 1405 07a0 40309AE5 		ldr	r3, [sl, #64]
 1406 07a4 048083E2 		add	r8, r3, #4
 1407              	.LVL113:
 1408              		.loc 3 546 0
 1409 07a8 0440D3E5 		ldrb	r4, [r3, #4]	@ zero_extendqisi2
 1410              	.LVL114:
 1411 07ac 0150D8E5 		ldrb	r5, [r8, #1]	@ zero_extendqisi2
 1412 07b0 0410A0E1 		mov	r1, r4
 1413 07b4 0520A0E1 		mov	r2, r5
 1414 07b8 10029FE5 		ldr	r0, .L152+112
 1415 07bc FEFFFFEB 		bl	printf
 1416              		.loc 3 548 0
 1417 07c0 0400A0E1 		mov	r0, r4
 1418 07c4 FEFFFFEB 		bl	l1a_tch_mode_set
 1419 07c8 0070A0E1 		mov	r7, r0
 1420              		.loc 3 549 0
 1421 07cc 0500A0E1 		mov	r0, r5
 1422 07d0 FEFFFFEB 		bl	l1a_audio_mode_set
 1423 07d4 0060A0E1 		mov	r6, r0
 1424              		.loc 3 551 0
 1425 07d8 0610A0E1 		mov	r1, r6
 1426              		.loc 3 553 0
 1427 07dc 8C419FE5 		ldr	r4, .L152+16
 1428              		.loc 3 551 0
 1429 07e0 0700A0E1 		mov	r0, r7
 1430 07e4 FEFFFFEB 		bl	audio_set_enabled
 1431              		.loc 3 553 0
 1432 07e8 0130A0E3 		mov	r3, #1
 1433 07ec 4B3AC4E5 		strb	r3, [r4, #2635]
 1434              		.loc 3 554 0
 1435 07f0 0230D8E5 		ldrb	r3, [r8, #2]	@ zero_extendqisi2
 1436              	.LBB54:
 1437              	.LBB55:
 1438              		.loc 3 526 0
 1439 07f4 1900A0E3 		mov	r0, #25
 1440              	.LBE55:
 1441              	.LBE54:
 1442              		.loc 3 554 0
 1443 07f8 503A84E5 		str	r3, [r4, #2640]
 1444              	.LBB56:
 1445              	.LBB57:
 1446              		.loc 3 526 0
 1447 07fc FEFFFFEB 		bl	l1ctl_msgb_alloc
 1448              		.loc 3 528 0
 1449 0800 0410A0E3 		mov	r1, #4
 1450              		.loc 3 526 0
 1451 0804 0050A0E1 		mov	r5, r0
 1452              	.LVL115:
 1453              		.loc 3 528 0
 1454 0808 FEFFFFEB 		bl	msgb_put
 1455              		.loc 3 530 0
 1456 080c 0070C0E5 		strb	r7, [r0, #0]
 1457              		.loc 3 531 0
 1458 0810 0160C0E5 		strb	r6, [r0, #1]
 1459              		.loc 3 532 0
 1460 0814 503A94E5 		ldr	r3, [r4, #2640]
 1461 0818 0230C0E5 		strb	r3, [r0, #2]
 1462              		.loc 3 534 0
 1463 081c 0500A0E1 		mov	r0, r5
 1464              	.LVL116:
 1465              	.L150:
 1466 0820 FEFFFFEB 		bl	l1_queue_for_l2
 1467              	.LVL117:
 1468 0824 500200EA 		b	.L45
 1469              	.LVL118:
 1470              	.L59:
 1471              	.LBE57:
 1472              	.LBE56:
 1473              	.LBE53:
 1474              	.LBE52:
 1475              	.LBB58:
 1476              	.LBB59:
 1477              		.loc 3 564 0
 1478 0828 40309AE5 		ldr	r3, [sl, #64]
 1479              		.loc 3 568 0
 1480 082c 3C219FE5 		ldr	r2, .L152+16
 1481              		.loc 3 564 0
 1482 0830 046083E2 		add	r6, r3, #4
 1483              	.LVL119:
 1484              		.loc 3 572 0
 1485 0834 98919FE5 		ldr	r9, .L152+116
 1486              		.loc 3 568 0
 1487 0838 0030A0E3 		mov	r3, #0
 1488              		.loc 3 572 0
 1489 083c 94819FE5 		ldr	r8, .L152+120
 1490 0840 0370A0E1 		mov	r7, r3
 1491              	.LVL120:
 1492 0844 0650A0E1 		mov	r5, r6
 1493 0848 0640A0E1 		mov	r4, r6
 1494              	.LVL121:
 1495 084c 233CC2E5 		strb	r3, [r2, #3107]
 1496              		.loc 3 568 0
 1497 0850 203CC2E5 		strb	r3, [r2, #3104]
 1498              		.loc 3 569 0
 1499 0854 213CC2E5 		strb	r3, [r2, #3105]
 1500              		.loc 3 571 0
 1501 0858 223CC2E5 		strb	r3, [r2, #3106]
 1502 085c 1F0200EA 		b	.L135
 1503              	.L136:
 1504              		.loc 3 574 0
 1505 0860 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1506 0864 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 1507 0868 000483E1 		orr	r0, r3, r0, asl #8
 1508 086c FEFFFFEB 		bl	__fswab16
 1509 0870 B200C9E0 		strh	r0, [r9], #2	@ movhi
 1510              		.loc 3 575 0
 1511 0874 8230D5E5 		ldrb	r3, [r5, #130]	@ zero_extendqisi2
 1512 0878 0130C8E4 		strb	r3, [r8], #1
 1513              		.loc 3 573 0
 1514 087c 024084E2 		add	r4, r4, #2
 1515 0880 015085E2 		add	r5, r5, #1
 1516              	.LVL122:
 1517              	.L135:
 1518 0884 0010D6E5 		ldrb	r1, [r6, #0]	@ zero_extendqisi2
 1519 0888 010057E1 		cmp	r7, r1
 1520 088c 017087E2 		add	r7, r7, #1
 1521 0890 160200BA 		blt	.L136
 1522              	.LVL123:
 1523              		.loc 3 577 0
 1524 0894 40019FE5 		ldr	r0, .L152+124
 1525 0898 FEFFFFEB 		bl	printf
 1526              		.loc 3 578 0
 1527 089c CC309FE5 		ldr	r3, .L152+16
 1528              		.loc 3 581 0
 1529 08a0 0C2B93E5 		ldr	r2, [r3, #2828]
 1530              		.loc 3 578 0
 1531 08a4 0010D6E5 		ldrb	r1, [r6, #0]	@ zero_extendqisi2
 1532              		.loc 3 581 0
 1533 08a8 000052E3 		cmp	r2, #0
 1534              		.loc 3 578 0
 1535 08ac 201CC3E5 		strb	r1, [r3, #3104]
 1536              		.loc 3 581 0
 1537 08b0 5002001A 		bne	.L45
 1538              		.loc 3 582 0
 1539 08b4 1800A0E3 		mov	r0, #24
 1540 08b8 FEFFFFEB 		bl	mframe_enable
 1541 08bc 500200EA 		b	.L45
 1542              	.LVL124:
 1543              	.L60:
 1544              	.LBE59:
 1545              	.LBE58:
 1546              	.LBB60:
 1547              	.LBB61:
 1548              		.loc 3 595 0
 1549 08c0 40309AE5 		ldr	r3, [sl, #64]
 1550 08c4 083083E2 		add	r3, r3, #8
 1551 08c8 14308AE5 		str	r3, [sl, #20]
 1552              		.loc 3 597 0
 1553 08cc BC009FE5 		ldr	r0, .L152+48
 1554 08d0 FEFFFFEB 		bl	l1a_txq_msgb_count
 1555              		.loc 3 598 0
 1556 08d4 030050E3 		cmp	r0, #3
 1557              		.loc 3 599 0
 1558 08d8 00019FC5 		ldrgt	r0, .L152+128
 1559              		.loc 3 598 0
 1560 08dc C80100CA 		bgt	.L149
 1561              		.loc 3 604 0
 1562 08e0 A8009FE5 		ldr	r0, .L152+48
 1563 08e4 0A10A0E1 		mov	r1, sl
 1564              	.LVL125:
 1565              	.L151:
 1566              	.LBE61:
 1567              	.LBE60:
 1568              		.loc 3 722 0
 1569 08e8 08D08DE2 		add	sp, sp, #8
 1570 08ec F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1571              	.LBB62:
 1572              	.LBB63:
 1573              		.loc 3 604 0
 1574 08f0 FEFFFFEA 		b	l1a_txq_msgb_enq
 1575              	.LVL126:
 1576              	.L57:
 1577              	.LBE63:
 1578              	.LBE62:
 1579              	.LBB64:
 1580              	.LBB65:
 1581              	.LBB66:
 1582              		.loc 3 615 0
 1583 08f4 043041E2 		sub	r3, r1, #4
 1584 08f8 0338A0E1 		mov	r3, r3, asl #16
 1585 08fc 2358A0E1 		mov	r5, r3, lsr #16
 1586              	.LBE66:
 1587              		.loc 3 610 0
 1588 0900 40309AE5 		ldr	r3, [sl, #64]
 1589              	.LBB67:
 1590              		.loc 3 615 0
 1591 0904 D8009FE5 		ldr	r0, .L152+132
 1592 0908 0510A0E1 		mov	r1, r5
 1593              	.LBE67:
 1594              		.loc 3 610 0
 1595 090c 046083E2 		add	r6, r3, #4
 1596              	.LVL127:
 1597              	.LBB68:
 1598              		.loc 3 615 0
 1599 0910 FEFFFFEB 		bl	printf
 1600 0914 0040A0E3 		mov	r4, #0
 1601              	.LVL128:
 1602 0918 480200EA 		b	.L141
 1603              	.L142:
 1604              		.loc 3 617 0
 1605 091c 0610D4E7 		ldrb	r1, [r4, r6]	@ zero_extendqisi2
 1606              		.loc 3 616 0
 1607 0920 014084E2 		add	r4, r4, #1
 1608              		.loc 3 617 0
 1609 0924 FEFFFFEB 		bl	printf
 1610              	.L141:
 1611              		.loc 3 616 0
 1612 0928 050054E1 		cmp	r4, r5
 1613              		.loc 3 617 0
 1614 092c B4009FE5 		ldr	r0, .L152+136
 1615              		.loc 3 616 0
 1616 0930 450200BA 		blt	.L142
 1617              		.loc 3 618 0
 1618 0934 B0009FE5 		ldr	r0, .L152+140
 1619 0938 FEFFFFEB 		bl	puts
 1620              	.LBE68:
 1621              		.loc 3 622 0
 1622 093c 0500A0E1 		mov	r0, r5
 1623 0940 0610A0E1 		mov	r1, r6
 1624 0944 FEFFFFEB 		bl	sim_apdu
 1625              	.LVL129:
 1626              	.L45:
 1627              	.LBE65:
 1628              	.LBE64:
 1629              		.loc 3 719 0
 1630 0948 0A00A0E1 		mov	r0, sl
 1631              		.loc 3 722 0
 1632 094c 08D08DE2 		add	sp, sp, #8
 1633 0950 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1634              		.loc 3 719 0
 1635 0954 FEFFFFEA 		b	msgb_free
 1636              	.LVL130:
 1637              	.L144:
 1638              		.loc 3 722 0
 1639 0958 08D08DE2 		add	sp, sp, #8
 1640 095c F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1641              	.L153:
 1642              		.align	2
 1643              	.L152:
 1644 0960 00000000 		.word	l23_rx_queue
 1645 0964 58000000 		.word	.LC3
 1646 0968 78000000 		.word	.LC4
 1647 096c 8C000000 		.word	.LC5
 1648 0970 00000000 		.word	l1s
 1649 0974 B4000000 		.word	.LC6
 1650 0978 D0000000 		.word	.LC7
 1651 097c 180B0000 		.word	l1s+2840
 1652 0980 140B0000 		.word	2836
 1653 0984 08010000 		.word	.LC8
 1654 0988 540A0000 		.word	l1s+2644
 1655 098c 5C0A0000 		.word	l1s+2652
 1656 0990 640A0000 		.word	l1s+2660
 1657 0994 1C010000 		.word	.LC9
 1658 0998 44010000 		.word	.LC10
 1659 099c 9C0B0000 		.word	2972
 1660 09a0 6C010000 		.word	.LC11
 1661 09a4 94010000 		.word	.LC12
 1662 09a8 B4010000 		.word	.LC13
 1663 09ac E8010000 		.word	.LC14
 1664 09b0 0C020000 		.word	.LC15
 1665 09b4 28020000 		.word	.LC16
 1666 09b8 FC0A0000 		.word	2812
 1667 09bc FE0A0000 		.word	2814
 1668 09c0 68020000 		.word	.LC17
 1669 09c4 B8020000 		.word	.LC20
 1670 09c8 88020000 		.word	.LC18
 1671 09cc A0020000 		.word	.LC19
 1672 09d0 D8020000 		.word	.LC21
 1673 09d4 240C0000 		.word	l1s+3108
 1674 09d8 A40C0000 		.word	l1s+3236
 1675 09dc 10030000 		.word	.LC22
 1676 09e0 40030000 		.word	.LC23
 1677 09e4 58030000 		.word	.LC24
 1678 09e8 6C030000 		.word	.LC25
 1679 09ec 74030000 		.word	.LC26
 1680              	.LFE85:
 1682              		.section	.text.l1a_l23api_init,"ax",%progbits
 1683              		.align	2
 1684              		.global	l1a_l23api_init
 1686              	l1a_l23api_init:
 1687              	.LFB86:
 723:layer1/l23_api.c **** 
 724:layer1/l23_api.c **** void l1a_l23api_init(void)
 725:layer1/l23_api.c **** {
 1688              		.loc 3 725 0
 1689              		@ args = 0, pretend = 0, frame = 0
 1690              		@ frame_needed = 0, uses_anonymous_args = 0
 1691              		@ link register save eliminated.
 1692              	.LVL131:
 726:layer1/l23_api.c **** 	sercomm_register_rx_cb(SC_DLCI_L1A_L23, l1a_l23_rx);
 1693              		.loc 3 726 0
 1694 0000 04109FE5 		ldr	r1, .L156
 1695 0004 0500A0E3 		mov	r0, #5
 1696              		.loc 3 725 0
 1697              		@ lr needed for prologue
 727:layer1/l23_api.c **** }
 1698              		.loc 3 727 0
 1699              		.loc 3 726 0
 1700 0008 FEFFFFEA 		b	sercomm_register_rx_cb
 1701              	.L157:
 1702              		.align	2
 1703              	.L156:
 1704 000c 00000000 		.word	l1a_l23_rx
 1705              	.LFE86:
 1915              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 l23_api.c
     /tmp/ccvlwgua.s:15     .bss:0000000000000000 l1a_l23_tx_cb
                             .bss:0000000000000000 $d
     /tmp/ccvlwgua.s:21     .data:0000000000000000 l23_rx_queue
     /tmp/ccvlwgua.s:22     .data:0000000000000000 $d
     /tmp/ccvlwgua.s:27     .text.__fswab16:0000000000000000 __fswab16
     /tmp/ccvlwgua.s:35     .text.__fswab16:0000000000000000 $a
     /tmp/ccvlwgua.s:54     .text.msgb_tailroom:0000000000000000 msgb_tailroom
     /tmp/ccvlwgua.s:62     .text.msgb_tailroom:0000000000000000 $a
     /tmp/ccvlwgua.s:83     .text.msgb_put:0000000000000000 msgb_put
     /tmp/ccvlwgua.s:89     .text.msgb_put:0000000000000000 $a
     /tmp/ccvlwgua.s:131    .text.msgb_put:000000000000004c $d
     /tmp/ccvlwgua.s:138    .text.l1_queue_for_l2:0000000000000000 l1_queue_for_l2
     /tmp/ccvlwgua.s:145    .text.l1_queue_for_l2:0000000000000000 $a
     /tmp/ccvlwgua.s:174    .text.l1_queue_for_l2:0000000000000030 $d
     /tmp/ccvlwgua.s:180    .text.audio_set_enabled:0000000000000000 audio_set_enabled
     /tmp/ccvlwgua.s:186    .text.audio_set_enabled:0000000000000000 $a
     /tmp/ccvlwgua.s:236    .text.l1ctl_msgb_alloc:0000000000000000 l1ctl_msgb_alloc
     /tmp/ccvlwgua.s:242    .text.l1ctl_msgb_alloc:0000000000000000 $a
     /tmp/ccvlwgua.s:308    .text.l1ctl_msgb_alloc:0000000000000064 $d
     /tmp/ccvlwgua.s:316    .text.l1_create_l2_msg:0000000000000000 l1_create_l2_msg
     /tmp/ccvlwgua.s:322    .text.l1_create_l2_msg:0000000000000000 $a
     /tmp/ccvlwgua.s:393    .text.l1ctl_tx_reset:0000000000000000 l1ctl_tx_reset
     /tmp/ccvlwgua.s:399    .text.l1ctl_tx_reset:0000000000000000 $a
     /tmp/ccvlwgua.s:428    .text.l1a_l23_rx:0000000000000000 l1a_l23_rx
     /tmp/ccvlwgua.s:434    .text.l1a_l23_rx:0000000000000000 $a
     /tmp/ccvlwgua.s:456    .text.l1a_l23_rx:0000000000000020 $d
     /tmp/ccvlwgua.s:540    .text.l1a_l23_handler:0000000000000000 l1a_l23_handler
     /tmp/ccvlwgua.s:546    .text.l1a_l23_handler:0000000000000000 $a
     /tmp/ccvlwgua.s:594    .text.l1a_l23_handler:0000000000000058 $d
     /tmp/ccvlwgua.s:626    .text.l1a_l23_handler:00000000000000c8 $a
     /tmp/ccvlwgua.s:1644   .text.l1a_l23_handler:0000000000000960 $d
     /tmp/ccvlwgua.s:1686   .text.l1a_l23api_init:0000000000000000 l1a_l23api_init
     /tmp/ccvlwgua.s:1694   .text.l1a_l23api_init:0000000000000000 $a
     /tmp/ccvlwgua.s:1704   .text.l1a_l23api_init:000000000000000c $d

UNDEFINED SYMBOLS
osmo_panic
sercomm_sendmsg
twl3025_unit_enable
msgb_alloc
puts
msgb_enqueue
msgb_dequeue
printf
l1s_reset
l1s_fbsb_req
mframe_disable
l1a_tch_mode_set
l1a_audio_mode_set
l1a_mftask_set
l1a_txq_msgb_flush
l1a_meas_msgb_set
dsp_load_ciph_param
l1a_freq_req
l1a_rach_req
l1s_reset_hw
l1s_pm_test
sched_gsmtime_reset
mframe_enable
l1a_txq_msgb_count
l1a_txq_msgb_enq
sim_apdu
msgb_free
l1s
sercomm_register_rx_cb
