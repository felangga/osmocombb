   1              		.file	"prim_tch.c"
   9              	.Ltext0:
  10              		.global	tch_a_sched_set
  11              		.section	.rodata
  12              		.align	2
  15              	tch_a_sched_set:
  16 0000 00000000 		.word	l1s_tch_a_cmd
  17 0004 00       		.byte	0
  18 0005 00       		.byte	0
  19 0006 0000     		.space	2
  20 0008 0000     		.short	0
  21 000a 0300     		.short	3
  22 000c 00000000 		.word	0
  23 0010 00       		.byte	0
  24 0011 00       		.byte	0
  25 0012 00000000 		.space	6
  25      0000
  26 0018 00000000 		.word	0
  27 001c 00       		.byte	0
  28 001d 00       		.byte	0
  29 001e 00000000 		.space	6
  29      0000
  30 0024 00000000 		.word	l1s_tch_a_resp
  31 0028 00       		.byte	0
  32 0029 FC       		.byte	-4
  33 002a 0000     		.space	2
  34 002c 0000     		.short	0
  35 002e 0000     		.short	0
  36 0030 00000000 		.word	0
  37 0034 00       		.byte	0
  38 0035 00       		.byte	0
  39 0036 00000000 		.space	6
  39      0000
  40 003c 00000000 		.word	tdma_end_set
  41 0040 00       		.byte	0
  42 0041 00       		.byte	0
  43 0042 00000000 		.space	6
  43      0000
  44              		.global	tch_d_sched_set
  45              		.align	2
  48              	tch_d_sched_set:
  49 0048 00000000 		.word	l1s_tch_d_cmd
  50 004c 00       		.byte	0
  51 004d 00       		.byte	0
  52 004e 0000     		.space	2
  53 0050 0000     		.short	0
  54 0052 0300     		.short	3
  55 0054 00000000 		.word	0
  56 0058 00       		.byte	0
  57 0059 00       		.byte	0
  58 005a 00000000 		.space	6
  58      0000
  59 0060 00000000 		.word	0
  60 0064 00       		.byte	0
  61 0065 00       		.byte	0
  62 0066 00000000 		.space	6
  62      0000
  63 006c 00000000 		.word	l1s_tch_d_resp
  64 0070 00       		.byte	0
  65 0071 FC       		.byte	-4
  66 0072 0000     		.space	2
  67 0074 0000     		.short	0
  68 0076 0000     		.short	0
  69 0078 00000000 		.word	0
  70 007c 00       		.byte	0
  71 007d 00       		.byte	0
  72 007e 00000000 		.space	6
  72      0000
  73 0084 00000000 		.word	tdma_end_set
  74 0088 00       		.byte	0
  75 0089 00       		.byte	0
  76 008a 00000000 		.space	6
  76      0000
  77              		.global	tch_sched_set
  78              		.align	2
  81              	tch_sched_set:
  82 0090 00000000 		.word	l1s_tch_cmd
  83 0094 00       		.byte	0
  84 0095 00       		.byte	0
  85 0096 0000     		.space	2
  86 0098 0000     		.short	0
  87 009a 0300     		.short	3
  88 009c 00000000 		.word	0
  89 00a0 00       		.byte	0
  90 00a1 00       		.byte	0
  91 00a2 00000000 		.space	6
  91      0000
  92 00a8 00000000 		.word	0
  93 00ac 00       		.byte	0
  94 00ad 00       		.byte	0
  95 00ae 00000000 		.space	6
  95      0000
  96 00b4 00000000 		.word	l1s_tch_resp
  97 00b8 00       		.byte	0
  98 00b9 FC       		.byte	-4
  99 00ba 0000     		.space	2
 100 00bc 0000     		.short	0
 101 00be 0000     		.short	0
 102 00c0 00000000 		.word	0
 103 00c4 00       		.byte	0
 104 00c5 00       		.byte	0
 105 00c6 00000000 		.space	6
 105      0000
 106 00cc 00000000 		.word	tdma_end_set
 107 00d0 00       		.byte	0
 108 00d1 00       		.byte	0
 109 00d2 00000000 		.space	6
 109      0000
 110              		.section	.text.__fswab16,"ax",%progbits
 111              		.align	2
 113              	__fswab16:
 114              	.LFB3:
 115              		.file 1 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
 116              		.loc 1 47 0
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              		@ link register save eliminated.
 120              	.LVL0:
 121 0000 0008A0E1 		mov	r0, r0, asl #16
 122              	.LVL1:
 123 0004 2008A0E1 		mov	r0, r0, lsr #16
 124              	.LVL2:
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
 125              		.loc 1 51 0
 126 0008 2034A0E1 		mov	r3, r0, lsr #8
 127 000c FF0000E2 		and	r0, r0, #255
 128              	.LVL3:
  52:include/swab.h **** #endif
  53:include/swab.h **** }
 129              		.loc 1 53 0
 130 0010 000483E1 		orr	r0, r3, r0, asl #8
 131              		.loc 1 47 0
 132              		@ lr needed for prologue
 133              		.loc 1 53 0
 134 0014 1EFF2FE1 		bx	lr
 135              	.LFE3:
 137              		.section	.text.__fswab32,"ax",%progbits
 138              		.align	2
 140              	__fswab32:
 141              	.LFB4:
  54:include/swab.h **** 
  55:include/swab.h **** static inline __attribute_const__ uint32_t __fswab32(uint32_t val)
  56:include/swab.h **** {
 142              		.loc 1 56 0
 143              		@ args = 0, pretend = 0, frame = 0
 144              		@ frame_needed = 0, uses_anonymous_args = 0
 145              		@ link register save eliminated.
 146              	.LVL4:
 147 0000 0030A0E1 		mov	r3, r0
 148              	.LBB2:
 149              	.LBB3:
 150              		.file 2 "include/asm/swab.h"
   1:include/asm/swab.h **** /*
   2:include/asm/swab.h ****  *  arch/arm/include/asm/byteorder.h
   3:include/asm/swab.h ****  *
   4:include/asm/swab.h ****  * ARM Endian-ness.  In little endian mode, the data bus is connected such
   5:include/asm/swab.h ****  * that byte accesses appear as:
   6:include/asm/swab.h ****  *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
   7:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
   8:include/asm/swab.h ****  *  d0...d31
   9:include/asm/swab.h ****  *
  10:include/asm/swab.h ****  * When in big endian mode, byte accesses appear as:
  11:include/asm/swab.h ****  *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
  12:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
  13:include/asm/swab.h ****  *  d0...d31
  14:include/asm/swab.h ****  */
  15:include/asm/swab.h **** #ifndef __ASM_ARM_SWAB_H
  16:include/asm/swab.h **** #define __ASM_ARM_SWAB_H
  17:include/asm/swab.h **** 
  18:include/asm/swab.h **** #include <stdint.h>
  19:include/asm/swab.h **** #include <defines.h>
  20:include/asm/swab.h **** 
  21:include/asm/swab.h **** static inline uint32_t __arch_swab32(uint32_t x)
  22:include/asm/swab.h **** {
  23:include/asm/swab.h **** 	uint32_t t;
  24:include/asm/swab.h **** 
  25:include/asm/swab.h **** #ifndef __thumb__
  26:include/asm/swab.h **** 	if (!__builtin_constant_p(x)) {
  27:include/asm/swab.h **** 		/*
  28:include/asm/swab.h **** 		 * The compiler needs a bit of a hint here to always do the
  29:include/asm/swab.h **** 		 * right thing and not screw it up to different degrees
  30:include/asm/swab.h **** 		 * depending on the gcc version.
  31:include/asm/swab.h **** 		 */
  32:include/asm/swab.h **** 		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
 151              		.loc 2 32 0
 152 0004 600820E0 		eor	r0, r0, r0, ror #16
 153              	.LVL5:
  33:include/asm/swab.h **** 	} else
  34:include/asm/swab.h **** #endif
  35:include/asm/swab.h **** 		t = x ^ ((x << 16) | (x >> 16)); /* eor r1,r0,r0,ror #16 */
  36:include/asm/swab.h **** 
  37:include/asm/swab.h **** 	x = (x << 24) | (x >> 8);		/* mov r0,r0,ror #8      */
 154              		.loc 2 37 0
 155 0008 FF08C0E3 		bic	r0, r0, #16711680
 156              	.LVL6:
 157 000c 2004A0E1 		mov	r0, r0, lsr #8
 158              	.LBE3:
 159              	.LBE2:
  57:include/swab.h **** #ifdef __arch_swab32
  58:include/swab.h **** 	return __arch_swab32(val);
  59:include/swab.h **** #else
  60:include/swab.h **** 	return ___constant_swab32(val);
  61:include/swab.h **** #endif
  62:include/swab.h **** }
 160              		.loc 1 62 0
 161 0010 630420E0 		eor	r0, r0, r3, ror #8
 162              		.loc 1 56 0
 163              		@ lr needed for prologue
 164              		.loc 1 62 0
 165 0014 1EFF2FE1 		bx	lr
 166              	.LFE4:
 168              		.section	.text.msgb_tailroom,"ax",%progbits
 169              		.align	2
 171              	msgb_tailroom:
 172              	.LFB38:
 173              		.file 3 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 174              		.loc 3 151 0
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178              	.LVL7:
 179 0000 B423D0E1 		ldrh	r2, [r0, #52]
 180 0004 383090E5 		ldr	r3, [r0, #56]
 181 0008 3C0090E5 		ldr	r0, [r0, #60]
 182              	.LVL8:
 183 000c 023083E0 		add	r3, r3, r2
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 184              		.loc 3 153 0
 185 0010 030060E0 		rsb	r0, r0, r3
 186              		.loc 3 151 0
 187              		@ lr needed for prologue
 188              		.loc 3 153 0
 189 0014 1EFF2FE1 		bx	lr
 190              	.LFE38:
 192              		.section	.rodata.str1.4,"aMS",%progbits,1
 193              		.align	2
 194              	.LC0:
 195 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 195      28257029 
 195      3A204E6F 
 195      7420656E 
 195      6F756768 
 196 0032 00       		.ascii	"\000"
 197              		.section	.text.msgb_put,"ax",%progbits
 198              		.align	2
 200              	msgb_put:
 201              	.LFB40:
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 202              		.loc 3 180 0
 203              		@ args = 0, pretend = 0, frame = 0
 204              		@ frame_needed = 0, uses_anonymous_args = 0
 205              	.LVL9:
 206 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 207              	.LCFI0:
 208              		.loc 3 180 0
 209 0004 0150A0E1 		mov	r5, r1
 210 0008 0040A0E1 		mov	r4, r0
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 211              		.loc 3 182 0
 212 000c FEFFFFEB 		bl	msgb_tailroom
 213              	.LVL10:
 214 0010 050050E1 		cmp	r0, r5
 215 0014 0020A0E1 		mov	r2, r0
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 216              		.loc 3 183 0
 217 0018 0410A0E1 		mov	r1, r4
 218 001c 28009FE5 		ldr	r0, .L11
 219 0020 0530A0E1 		mov	r3, r5
 220              		.loc 3 181 0
 221 0024 3C6094E5 		ldr	r6, [r4, #60]
 222              	.LVL11:
 223              		.loc 3 182 0
 224              	.LVL12:
 225              		.loc 3 183 0
 226 0028 FEFFFFBB 		bllt	osmo_panic
 227              	.LVL13:
 228              	.L8:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 229              		.loc 3 185 0
 230 002c 3C2094E5 		ldr	r2, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 231              		.loc 3 186 0
 232 0030 B633D4E1 		ldrh	r3, [r4, #54]
 233              		.loc 3 185 0
 234 0034 052082E0 		add	r2, r2, r5
 235              		.loc 3 186 0
 236 0038 053083E0 		add	r3, r3, r5
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 237              		.loc 3 188 0
 238 003c 0600A0E1 		mov	r0, r6
 239              		.loc 3 186 0
 240 0040 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 241              		.loc 3 185 0
 242 0044 3C2084E5 		str	r2, [r4, #60]
 243              		.loc 3 188 0
 244 0048 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 245              	.L12:
 246              		.align	2
 247              	.L11:
 248 004c 00000000 		.word	.LC0
 249              	.LFE40:
 251              		.section	.text.dsp_task_iq_swap,"ax",%progbits
 252              		.align	2
 254              	dsp_task_iq_swap:
 255              	.LFB65:
 256              		.file 4 "include/calypso/dsp.h"
   1:include/calypso/dsp.h **** #ifndef _CALYPSO_DSP_H
   2:include/calypso/dsp.h **** #define _CALYPSO_DSP_H
   3:include/calypso/dsp.h **** 
   4:include/calypso/dsp.h **** #include <calypso/dsp_api.h>
   5:include/calypso/dsp.h **** #include <rffe.h>
   6:include/calypso/dsp.h **** 
   7:include/calypso/dsp.h **** #define CAL_DSP_TGT_BB_LVL	80
   8:include/calypso/dsp.h **** 
   9:include/calypso/dsp.h **** struct gsm_time;
  10:include/calypso/dsp.h **** 
  11:include/calypso/dsp.h **** struct dsp_api {
  12:include/calypso/dsp.h **** 	T_NDB_MCU_DSP *ndb;
  13:include/calypso/dsp.h **** 	T_DB_DSP_TO_MCU *db_r;
  14:include/calypso/dsp.h **** 	T_DB_MCU_TO_DSP *db_w;
  15:include/calypso/dsp.h **** 	T_PARAM_MCU_DSP *param;
  16:include/calypso/dsp.h **** 	int r_page;
  17:include/calypso/dsp.h **** 	int w_page;
  18:include/calypso/dsp.h **** 	int r_page_used;
  19:include/calypso/dsp.h **** 	int frame_ctr;
  20:include/calypso/dsp.h **** };
  21:include/calypso/dsp.h **** 
  22:include/calypso/dsp.h **** extern struct dsp_api dsp_api;
  23:include/calypso/dsp.h **** 
  24:include/calypso/dsp.h **** void dsp_power_on(void);
  25:include/calypso/dsp.h **** void dsp_dump_version(void);
  26:include/calypso/dsp.h **** void dsp_dump(void);
  27:include/calypso/dsp.h **** void dsp_checksum_task(void);
  28:include/calypso/dsp.h **** void dsp_api_memset(uint16_t *ptr, int octets);
  29:include/calypso/dsp.h **** void dsp_memcpy_to_api(volatile uint16_t *dsp_buf, const uint8_t *mcu_buf, int n, int be);
  30:include/calypso/dsp.h **** void dsp_memcpy_from_api(uint8_t *mcu_buf, const volatile uint16_t *dsp_buf, int n, int be);
  31:include/calypso/dsp.h **** void dsp_load_afc_dac(uint16_t afc);
  32:include/calypso/dsp.h **** void dsp_load_apc_dac(uint16_t apc);
  33:include/calypso/dsp.h **** void dsp_load_tch_param(struct gsm_time *next_time,
  34:include/calypso/dsp.h ****                         uint8_t chan_mode, uint8_t chan_type, uint8_t chan_sub,
  35:include/calypso/dsp.h ****                         uint8_t tch_loop, uint8_t sync_tch, uint8_t tn);
  36:include/calypso/dsp.h **** void dsp_load_ciph_param(int mode, uint8_t *key);
  37:include/calypso/dsp.h **** void dsp_end_scenario(void);
  38:include/calypso/dsp.h **** 
  39:include/calypso/dsp.h **** void dsp_load_rx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  40:include/calypso/dsp.h **** void dsp_load_tx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  41:include/calypso/dsp.h **** 
  42:include/calypso/dsp.h **** static inline uint16_t
  43:include/calypso/dsp.h **** dsp_task_iq_swap(uint16_t dsp_task, uint16_t band_arfcn, int tx)
  44:include/calypso/dsp.h **** {
 257              		.loc 4 44 0
 258              		@ args = 0, pretend = 0, frame = 0
 259              		@ frame_needed = 0, uses_anonymous_args = 0
 260              	.LVL14:
 261 0000 0138A0E1 		mov	r3, r1, asl #16
 262 0004 00C8A0E1 		mov	ip, r0, asl #16
 263 0008 10402DE9 		stmfd	sp!, {r4, lr}
 264              	.LCFI1:
  45:include/calypso/dsp.h **** 	if (rffe_iq_swapped(band_arfcn, tx))
 265              		.loc 4 45 0
 266 000c 0210A0E1 		mov	r1, r2
 267              	.LVL15:
 268 0010 2308A0E1 		mov	r0, r3, lsr #16
 269              	.LVL16:
 270              		.loc 4 44 0
 271 0014 2C48A0E1 		mov	r4, ip, lsr #16
 272              	.LVL17:
 273              		.loc 4 45 0
 274 0018 FEFFFFEB 		bl	rffe_iq_swapped
 275              	.LVL18:
 276 001c 000050E3 		cmp	r0, #0
  46:include/calypso/dsp.h **** 		dsp_task |= 0x8000;
 277              		.loc 4 46 0
 278 0020 02498413 		orrne	r4, r4, #32768
  47:include/calypso/dsp.h **** 	return dsp_task;
  48:include/calypso/dsp.h **** }
 279              		.loc 4 48 0
 280 0024 0400A0E1 		mov	r0, r4
 281 0028 1080BDE8 		ldmfd	sp!, {r4, pc}
 282              	.LFE65:
 284              		.section	.text.msb_get_bit,"ax",%progbits
 285              		.align	2
 287              	msb_get_bit:
 288              	.LFB67:
 289              		.file 5 "layer1/prim_tch.c"
   1:layer1/prim_tch.c **** /* Layer 1 - TCH */
   2:layer1/prim_tch.c **** 
   3:layer1/prim_tch.c **** /* (C) 2010 by Dieter Spaar <spaar@mirider.augusta.de>
   4:layer1/prim_tch.c ****  * (C) 2010 by Sylvain Munaut <tnt@246tnt.com>
   5:layer1/prim_tch.c ****  *
   6:layer1/prim_tch.c ****  * All Rights Reserved
   7:layer1/prim_tch.c ****  *
   8:layer1/prim_tch.c ****  * This program is free software; you can redistribute it and/or modify
   9:layer1/prim_tch.c ****  * it under the terms of the GNU General Public License as published by
  10:layer1/prim_tch.c ****  * the Free Software Foundation; either version 2 of the License, or
  11:layer1/prim_tch.c ****  * (at your option) any later version.
  12:layer1/prim_tch.c ****  *
  13:layer1/prim_tch.c ****  * This program is distributed in the hope that it will be useful,
  14:layer1/prim_tch.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:layer1/prim_tch.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:layer1/prim_tch.c ****  * GNU General Public License for more details.
  17:layer1/prim_tch.c ****  *
  18:layer1/prim_tch.c ****  * You should have received a copy of the GNU General Public License along
  19:layer1/prim_tch.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  20:layer1/prim_tch.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  21:layer1/prim_tch.c ****  *
  22:layer1/prim_tch.c ****  */
  23:layer1/prim_tch.c **** 
  24:layer1/prim_tch.c **** #include <stdint.h>
  25:layer1/prim_tch.c **** #include <stdio.h>
  26:layer1/prim_tch.c **** #include <string.h>
  27:layer1/prim_tch.c **** #include <stdlib.h>
  28:layer1/prim_tch.c **** 
  29:layer1/prim_tch.c **** #include <defines.h>
  30:layer1/prim_tch.c **** #include <debug.h>
  31:layer1/prim_tch.c **** #include <memory.h>
  32:layer1/prim_tch.c **** #include <byteorder.h>
  33:layer1/prim_tch.c **** #include <osmocom/gsm/gsm_utils.h>
  34:layer1/prim_tch.c **** #include <osmocom/gsm/protocol/gsm_04_08.h>
  35:layer1/prim_tch.c **** #include <osmocom/codec/codec.h>
  36:layer1/prim_tch.c **** #include <osmocom/core/msgb.h>
  37:layer1/prim_tch.c **** #include <calypso/dsp_api.h>
  38:layer1/prim_tch.c **** #include <calypso/irq.h>
  39:layer1/prim_tch.c **** #include <calypso/tpu.h>
  40:layer1/prim_tch.c **** #include <calypso/tsp.h>
  41:layer1/prim_tch.c **** #include <calypso/dsp.h>
  42:layer1/prim_tch.c **** #include <calypso/timer.h>
  43:layer1/prim_tch.c **** #include <comm/sercomm.h>
  44:layer1/prim_tch.c **** 
  45:layer1/prim_tch.c **** #include <rffe.h>
  46:layer1/prim_tch.c **** #include <layer1/sync.h>
  47:layer1/prim_tch.c **** #include <layer1/afc.h>
  48:layer1/prim_tch.c **** #include <layer1/agc.h>
  49:layer1/prim_tch.c **** #include <layer1/toa.h>
  50:layer1/prim_tch.c **** #include <layer1/tdma_sched.h>
  51:layer1/prim_tch.c **** #include <layer1/mframe_sched.h>
  52:layer1/prim_tch.c **** #include <layer1/tpu_window.h>
  53:layer1/prim_tch.c **** #include <layer1/l23_api.h>
  54:layer1/prim_tch.c **** #include <layer1/rfch.h>
  55:layer1/prim_tch.c **** #include <layer1/prim.h>
  56:layer1/prim_tch.c **** 
  57:layer1/prim_tch.c **** #include <l1ctl_proto.h>
  58:layer1/prim_tch.c **** 
  59:layer1/prim_tch.c **** static inline int msb_get_bit(uint8_t *buf, int bn)
  60:layer1/prim_tch.c **** {
 290              		.loc 5 60 0
 291              		@ args = 0, pretend = 0, frame = 0
 292              		@ frame_needed = 0, uses_anonymous_args = 0
 293              		@ link register save eliminated.
 294              	.LVL19:
 295 0000 C101D0E7 		ldrb	r0, [r0, r1, asr #3]	@ zero_extendqisi2
 296              	.LVL20:
 297 0004 0110E0E1 		mvn	r1, r1
 298              	.LVL21:
 299 0008 071001E2 		and	r1, r1, #7
 300 000c 5001A0E1 		mov	r0, r0, asr r1
  61:layer1/prim_tch.c **** 	int pos_byte = bn >> 3;
  62:layer1/prim_tch.c **** 	int pos_bit  = 7 - (bn & 7);
  63:layer1/prim_tch.c **** 
  64:layer1/prim_tch.c **** 	return (buf[pos_byte] >> pos_bit) & 1;
  65:layer1/prim_tch.c **** }
 301              		.loc 5 65 0
 302 0010 010000E2 		and	r0, r0, #1
 303              		.loc 5 60 0
 304              		@ lr needed for prologue
 305              		.loc 5 65 0
 306 0014 1EFF2FE1 		bx	lr
 307              	.LFE67:
 309              		.section	.text.msb_set_bit,"ax",%progbits
 310              		.align	2
 312              	msb_set_bit:
 313              	.LFB68:
  66:layer1/prim_tch.c **** 
  67:layer1/prim_tch.c **** static inline void msb_set_bit(uint8_t *buf, int bn, int bit)
  68:layer1/prim_tch.c **** {
 314              		.loc 5 68 0
 315              		@ args = 0, pretend = 0, frame = 0
 316              		@ frame_needed = 0, uses_anonymous_args = 0
 317              		@ link register save eliminated.
 318              	.LVL22:
  69:layer1/prim_tch.c **** 	int pos_byte = bn >> 3;
  70:layer1/prim_tch.c **** 	int pos_bit  = 7 - (bn & 7);
  71:layer1/prim_tch.c **** 
  72:layer1/prim_tch.c **** 	buf[pos_byte] |=  (bit << pos_bit);
 319              		.loc 5 72 0
 320 0000 C1C1A0E1 		mov	ip, r1, asr #3
 321 0004 0C30D0E7 		ldrb	r3, [r0, ip]	@ zero_extendqisi2
 322 0008 0110E0E1 		mvn	r1, r1
 323              	.LVL23:
 324 000c 071001E2 		and	r1, r1, #7
 325 0010 123183E1 		orr	r3, r3, r2, asl r1
 326              		.loc 5 68 0
 327              		@ lr needed for prologue
 328              		.loc 5 72 0
 329 0014 0C30C0E7 		strb	r3, [r0, ip]
  73:layer1/prim_tch.c **** }
 330              		.loc 5 73 0
 331 0018 1EFF2FE1 		bx	lr
 332              	.LFE68:
 334              		.section	.text.tch_fr_bit_magic,"ax",%progbits
 335              		.align	2
 337              	tch_fr_bit_magic:
 338              	.LFB69:
  74:layer1/prim_tch.c **** 
  75:layer1/prim_tch.c **** static void tch_fr_bit_magic(uint8_t *frame, int dl)
  76:layer1/prim_tch.c **** {
 339              		.loc 5 76 0
 340              		@ args = 0, pretend = 0, frame = 36
 341              		@ frame_needed = 0, uses_anonymous_args = 0
 342              	.LVL24:
 343 0000 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 344              	.LCFI2:
 345 0004 24D04DE2 		sub	sp, sp, #36
 346              	.LCFI3:
 347              	.LVL25:
 348              		.loc 5 76 0
 349 0008 0190A0E1 		mov	r9, r1
 350 000c 0070A0E1 		mov	r7, r0
  77:layer1/prim_tch.c **** 	uint8_t fr[33];
  78:layer1/prim_tch.c **** 	int i, di, si;
  79:layer1/prim_tch.c **** 
  80:layer1/prim_tch.c **** 	memset(fr, 0x00, 33);
 351              		.loc 5 80 0
 352 0010 0010A0E3 		mov	r1, #0
 353              	.LVL26:
 354 0014 03008DE2 		add	r0, sp, #3
 355              	.LVL27:
 356 0018 2120A0E3 		mov	r2, #33
 357 001c FEFFFFEB 		bl	memset
  81:layer1/prim_tch.c **** 
  82:layer1/prim_tch.c **** 	if (dl)
 358              		.loc 5 82 0
 359 0020 000059E3 		cmp	r9, #0
  83:layer1/prim_tch.c **** 		fr[0] = 0xd0;
 360              		.loc 5 83 0
 361 0024 2F30E013 		mvnne	r3, #47
 362 0028 0330CD15 		strneb	r3, [sp, #3]
 363 002c 80A09FE5 		ldr	sl, .L36
 364 0030 0060A0E3 		mov	r6, #0
 365              	.LVL28:
 366              	.LVL29:
 367              	.L24:
  84:layer1/prim_tch.c **** 
  85:layer1/prim_tch.c **** 	for (i = 0; i < 260; i++) {
  86:layer1/prim_tch.c **** 		di = gsm610_bitorder[i];
  87:layer1/prim_tch.c **** 		si = (i > 181) ? i + 4 : i;
 368              		.loc 5 87 0
 369 0034 B50056E3 		cmp	r6, #181
 370              		.loc 5 86 0
 371 0038 B030DAE1 		ldrh	r3, [sl, #0]
 372              	.LVL30:
 373              		.loc 5 87 0
 374 003c 0640A0E1 		mov	r4, r6
 375 0040 044086C2 		addgt	r4, r6, #4
  88:layer1/prim_tch.c **** 
  89:layer1/prim_tch.c **** 		if (dl)
 376              		.loc 5 89 0
 377 0044 000059E3 		cmp	r9, #0
  90:layer1/prim_tch.c **** 			msb_set_bit(fr, 4 + di, msb_get_bit(frame, si));
 378              		.loc 5 90 0
 379 0048 0410A0E1 		mov	r1, r4
 380 004c 0700A0E1 		mov	r0, r7
 381 0050 045083E2 		add	r5, r3, #4
 382 0054 03808DE2 		add	r8, sp, #3
 383              		.loc 5 89 0
 384 0058 1A00000A 		beq	.L28
 385              	.LVL31:
 386              		.loc 5 90 0
 387 005c FEFFFFEB 		bl	msb_get_bit
 388              	.LVL32:
 389 0060 0510A0E1 		mov	r1, r5
 390 0064 0020A0E1 		mov	r2, r0
 391 0068 0800A0E1 		mov	r0, r8
 392 006c 200000EA 		b	.L35
 393              	.LVL33:
 394              	.L28:
  91:layer1/prim_tch.c **** 		else
  92:layer1/prim_tch.c **** 			msb_set_bit(fr, si, msb_get_bit(frame, 4 + di));
 395              		.loc 5 92 0
 396 0070 0510A0E1 		mov	r1, r5
 397              	.LVL34:
 398 0074 0700A0E1 		mov	r0, r7
 399 0078 FEFFFFEB 		bl	msb_get_bit
 400              	.LVL35:
 401 007c 0410A0E1 		mov	r1, r4
 402 0080 0020A0E1 		mov	r2, r0
 403 0084 0800A0E1 		mov	r0, r8
 404              	.L35:
 405              		.loc 5 85 0
 406 0088 016086E2 		add	r6, r6, #1
 407              		.loc 5 92 0
 408 008c FEFFFFEB 		bl	msb_set_bit
 409              		.loc 5 85 0
 410 0090 410F56E3 		cmp	r6, #260
 411 0094 02A08AE2 		add	sl, sl, #2
 412 0098 0B00001A 		bne	.L24
  93:layer1/prim_tch.c **** 	}
  94:layer1/prim_tch.c **** 
  95:layer1/prim_tch.c **** 	memcpy(frame, fr, 33);
 413              		.loc 5 95 0
 414 009c 0700A0E1 		mov	r0, r7
 415 00a0 03108DE2 		add	r1, sp, #3
 416 00a4 2120A0E3 		mov	r2, #33
 417 00a8 FEFFFFEB 		bl	memcpy
  96:layer1/prim_tch.c **** }
 418              		.loc 5 96 0
 419 00ac 24D08DE2 		add	sp, sp, #36
 420 00b0 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 421              	.L37:
 422              		.align	2
 423              	.L36:
 424 00b4 00000000 		.word	gsm610_bitorder
 425              	.LFE69:
 427              		.global	__umodsi3
 428              		.section	.text.tch_get_params,"ax",%progbits
 429              		.align	2
 431              	tch_get_params:
 432              	.LFB70:
  97:layer1/prim_tch.c **** 
  98:layer1/prim_tch.c **** /* This computes various parameters both for the DSP and for
  99:layer1/prim_tch.c ****  * our logic. Not all are used all the time, but it's easier
 100:layer1/prim_tch.c ****  * to build all in one place */
 101:layer1/prim_tch.c **** static void tch_get_params(struct gsm_time *time, uint8_t chan_nr,
 102:layer1/prim_tch.c ****                            uint32_t *fn_report, uint8_t *tch_f_hn,
 103:layer1/prim_tch.c ****                            uint8_t *tch_sub, uint8_t *tch_mode)
 104:layer1/prim_tch.c **** {
 433              		.loc 5 104 0
 434              		@ args = 8, pretend = 0, frame = 0
 435              		@ frame_needed = 0, uses_anonymous_args = 0
 436              	.LVL36:
 437 0000 01C0A0E1 		mov	ip, r1
 438 0004 FF1001E2 		and	r1, r1, #255
 439 0008 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 440              	.LCFI4:
 105:layer1/prim_tch.c **** 	uint8_t tn = chan_nr & 0x07;
 106:layer1/prim_tch.c **** 	uint8_t cbits = chan_nr >> 3;
 441              		.loc 5 106 0
 442 000c A1E1A0E1 		mov	lr, r1, lsr #3
 443 0010 AE10A0E1 		mov	r1, lr, lsr #1
 444              	.LVL37:
 445 0014 014001E2 		and	r4, r1, #1
 446              		.loc 5 104 0
 447 0018 0350A0E1 		mov	r5, r3
 107:layer1/prim_tch.c **** 
 108:layer1/prim_tch.c **** 	*tch_f_hn = (cbits & 2) ? 0 : 1;
 448              		.loc 5 108 0
 449 001c 013024E2 		eor	r3, r4, #1
 450              	.LVL38:
 109:layer1/prim_tch.c **** 
 110:layer1/prim_tch.c **** 	if (*tch_f_hn) {
 451              		.loc 5 110 0
 452 0020 000054E3 		cmp	r4, #0
 453              		.loc 5 108 0
 454 0024 0030C5E5 		strb	r3, [r5, #0]
 455              	.LBB4:
 111:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn * 13) + 104) % 104;
 112:layer1/prim_tch.c **** 		*tch_sub = 0;
 113:layer1/prim_tch.c **** 	} else {
 114:layer1/prim_tch.c **** 		uint8_t chan_sub = cbits & 1;
 456              		.loc 5 114 0
 457 0028 01400E12 		andne	r4, lr, #1
 458              	.LVL39:
 115:layer1/prim_tch.c **** 		uint8_t tn_report = (tn & ~1) | chan_sub;
 116:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn_report * 13) + 104) % 104;
 459              		.loc 5 116 0
 460 002c 06300C12 		andne	r3, ip, #6
 461 0030 001090E5 		ldr	r1, [r0, #0]
 462              	.LBE4:
 463              		.loc 5 104 0
 464 0034 0260A0E1 		mov	r6, r2
 465              		.loc 5 105 0
 466 0038 07000CE2 		and	r0, ip, #7
 467              	.LVL40:
 468              		.loc 5 111 0
 469 003c 0D30A003 		moveq	r3, #13
 470              	.LBB5:
 471              		.loc 5 116 0
 472 0040 04308311 		orrne	r3, r3, r4
 473 0044 0D20A013 		movne	r2, #13
 474              	.LVL41:
 475              	.LBE5:
 476              		.loc 5 111 0
 477 0048 93000000 		muleq	r0, r3, r0
 478              	.LVL42:
 479              	.LBB6:
 480              		.loc 5 116 0
 481 004c 93020010 		mulne	r0, r3, r2
 482 0050 010060E0 		rsb	r0, r0, r1
 483 0054 680080E2 		add	r0, r0, #104
 484 0058 6810A0E3 		mov	r1, #104
 485 005c FEFFFFEB 		bl	__umodsi3
 486              	.LVL43:
 487              	.LBE6:
 488              		.loc 5 104 0
 489 0060 1C709DE5 		ldr	r7, [sp, #28]
 490 0064 18809DE5 		ldr	r8, [sp, #24]
 117:layer1/prim_tch.c **** 		*tch_sub = chan_sub;
 118:layer1/prim_tch.c **** 	}
 119:layer1/prim_tch.c **** 
 120:layer1/prim_tch.c **** 	if (tch_mode) {
 491              		.loc 5 120 0
 492 0068 000057E3 		cmp	r7, #0
 493              	.LBB7:
 494              		.loc 5 116 0
 495 006c 000086E5 		str	r0, [r6, #0]
 496              		.loc 5 117 0
 497 0070 0040C8E5 		strb	r4, [r8, #0]
 498              	.LBE7:
 499              		.loc 5 120 0
 500 0074 F081BD08 		ldmeqfd	sp!, {r4, r5, r6, r7, r8, pc}
 501              	.LVL44:
 121:layer1/prim_tch.c **** 		switch (l1s.tch_mode) {
 502              		.loc 5 121 0
 503 0078 44309FE5 		ldr	r3, .L57
 504 007c 4A3AD3E5 		ldrb	r3, [r3, #2634]	@ zero_extendqisi2
 505 0080 010053E3 		cmp	r3, #1
 506 0084 2400000A 		beq	.L45
 507 0088 210053E3 		cmp	r3, #33
 122:layer1/prim_tch.c **** 		case GSM48_CMODE_SPEECH_V1:
 123:layer1/prim_tch.c **** 			*tch_mode = *tch_f_hn ? TCH_FS_MODE : TCH_HS_MODE;
 124:layer1/prim_tch.c **** 			break;
 125:layer1/prim_tch.c **** 		case GSM48_CMODE_SPEECH_EFR:
 126:layer1/prim_tch.c **** 			*tch_mode = *tch_f_hn ? TCH_EFR_MODE : SIG_ONLY_MODE;
 127:layer1/prim_tch.c **** 			break;
 128:layer1/prim_tch.c **** 		default:
 129:layer1/prim_tch.c **** 			*tch_mode = SIG_ONLY_MODE;
 508              		.loc 5 129 0
 509 008c 0030A013 		movne	r3, #0
 510              		.loc 5 121 0
 511 0090 2D00001A 		bne	.L56
 512 0094 290000EA 		b	.L46
 513              	.L45:
 514              		.loc 5 123 0
 515 0098 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 516 009c 000053E3 		cmp	r3, #0
 517 00a0 0230A003 		moveq	r3, #2
 518 00a4 0130A013 		movne	r3, #1
 519 00a8 2D0000EA 		b	.L56
 520              	.L46:
 521              		.loc 5 126 0
 522 00ac 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 523 00b0 000053E3 		cmp	r3, #0
 524 00b4 0830A013 		movne	r3, #8
 525 00b8 0030A003 		moveq	r3, #0
 526              	.L56:
 527              		.loc 5 129 0
 528 00bc 0030C7E5 		strb	r3, [r7, #0]
 529 00c0 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 530              	.L58:
 531              		.align	2
 532              	.L57:
 533 00c4 00000000 		.word	l1s
 534              	.LFE70:
 536              		.section	.text.l1a_tx_tch_compl,"ax",%progbits
 537              		.align	2
 539              	l1a_tx_tch_compl:
 540              	.LFB71:
 130:layer1/prim_tch.c **** 		}
 131:layer1/prim_tch.c **** 	}
 132:layer1/prim_tch.c **** }
 133:layer1/prim_tch.c **** 
 134:layer1/prim_tch.c **** 
 135:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 136:layer1/prim_tch.c ****  * Shared completion handler
 137:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 138:layer1/prim_tch.c **** 
 139:layer1/prim_tch.c **** /*
 140:layer1/prim_tch.c ****  * FIXME We really need a better way to handle completion, where we can
 141:layer1/prim_tch.c ****  *       pass arguments and such ...
 142:layer1/prim_tch.c ****  *
 143:layer1/prim_tch.c ****  *       Right now, we just 'hope' it gets processed before the next one ...
 144:layer1/prim_tch.c ****  */
 145:layer1/prim_tch.c **** 
 146:layer1/prim_tch.c **** #define TX_TYPE_SACCH	(1<<0)
 147:layer1/prim_tch.c **** #define TX_TYPE_FACCH	(1<<1)
 148:layer1/prim_tch.c **** #define TX_TYPE_TRAFFIC	(1<<2)
 149:layer1/prim_tch.c **** 
 150:layer1/prim_tch.c **** static uint16_t last_tx_tch_fn;
 151:layer1/prim_tch.c **** static uint16_t last_tx_tch_type;
 152:layer1/prim_tch.c **** 
 153:layer1/prim_tch.c **** static void l1a_tx_tch_compl(__unused enum l1_compl c)
 154:layer1/prim_tch.c **** {
 541              		.loc 5 154 0
 542              		@ args = 0, pretend = 0, frame = 0
 543              		@ frame_needed = 0, uses_anonymous_args = 0
 544              	.LVL45:
 545 0000 10402DE9 		stmfd	sp!, {r4, lr}
 546              	.LCFI5:
 155:layer1/prim_tch.c **** 	struct msgb *msg;
 156:layer1/prim_tch.c **** 
 157:layer1/prim_tch.c **** 	if (last_tx_tch_type & (TX_TYPE_SACCH | TX_TYPE_FACCH)) {
 547              		.loc 5 157 0
 548 0004 58409FE5 		ldr	r4, .L65
 549 0008 B010D4E1 		ldrh	r1, [r4, #0]
 158:layer1/prim_tch.c **** 		msg = l1_create_l2_msg(L1CTL_DATA_CONF, last_tx_tch_fn, 0, 0);
 550              		.loc 5 158 0
 551 000c 0020A0E3 		mov	r2, #0
 552              		.loc 5 157 0
 553 0010 030011E3 		tst	r1, #3
 554              		.loc 5 158 0
 555 0014 0230A0E1 		mov	r3, r2
 556 0018 0F00A0E3 		mov	r0, #15
 557              	.LVL46:
 558              		.loc 5 157 0
 559 001c 0A00000A 		beq	.L60
 560              		.loc 5 158 0
 561 0020 40109FE5 		ldr	r1, .L65+4
 562 0024 B010D1E1 		ldrh	r1, [r1, #0]
 563 0028 FEFFFFEB 		bl	l1_create_l2_msg
 159:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 564              		.loc 5 159 0
 565 002c FEFFFFEB 		bl	l1_queue_for_l2
 566              	.L60:
 160:layer1/prim_tch.c **** 	}
 161:layer1/prim_tch.c **** 
 162:layer1/prim_tch.c **** 	if (last_tx_tch_type & TX_TYPE_TRAFFIC) {
 567              		.loc 5 162 0
 568 0030 B010D4E1 		ldrh	r1, [r4, #0]
 163:layer1/prim_tch.c **** 		msg = l1_create_l2_msg(L1CTL_TRAFFIC_CONF, last_tx_tch_fn, 0, 0);
 569              		.loc 5 163 0
 570 0034 0020A0E3 		mov	r2, #0
 571              		.loc 5 162 0
 572 0038 040011E3 		tst	r1, #4
 573              		.loc 5 163 0
 574 003c 0230A0E1 		mov	r3, r2
 575 0040 1D00A0E3 		mov	r0, #29
 576              		.loc 5 162 0
 577 0044 1400000A 		beq	.L62
 578              		.loc 5 163 0
 579 0048 18109FE5 		ldr	r1, .L65+4
 580 004c B010D1E1 		ldrh	r1, [r1, #0]
 581 0050 FEFFFFEB 		bl	l1_create_l2_msg
 164:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 582              		.loc 5 164 0
 583 0054 FEFFFFEB 		bl	l1_queue_for_l2
 584              	.L62:
 165:layer1/prim_tch.c **** 	}
 166:layer1/prim_tch.c **** 
 167:layer1/prim_tch.c **** 	last_tx_tch_type = 0;
 585              		.loc 5 167 0
 586 0058 0030A0E3 		mov	r3, #0	@ movhi
 587 005c B030C4E1 		strh	r3, [r4, #0]	@ movhi
 168:layer1/prim_tch.c **** }
 588              		.loc 5 168 0
 589 0060 1080BDE8 		ldmfd	sp!, {r4, pc}
 590              	.L66:
 591              		.align	2
 592              	.L65:
 593 0064 74000000 		.word	last_tx_tch_type
 594 0068 76000000 		.word	last_tx_tch_fn
 595              	.LFE71:
 597              		.section	.text.prim_tch_init,"ax",%progbits
 598              		.align	2
 600              	prim_tch_init:
 601              	.LFB72:
 169:layer1/prim_tch.c **** 
 170:layer1/prim_tch.c **** static __attribute__ ((constructor)) void prim_tch_init(void)
 171:layer1/prim_tch.c **** {
 602              		.loc 5 171 0
 603              		@ args = 0, pretend = 0, frame = 0
 604              		@ frame_needed = 0, uses_anonymous_args = 0
 605              		@ link register save eliminated.
 606              	.LVL47:
 172:layer1/prim_tch.c **** 	l1s.completion[L1_COMPL_TX_TCH]  = &l1a_tx_tch_compl;
 607              		.loc 5 172 0
 608 0000 08209FE5 		ldr	r2, .L69
 609 0004 08309FE5 		ldr	r3, .L69+4
 610              		.loc 5 171 0
 611              		@ lr needed for prologue
 612              		.loc 5 172 0
 613 0008 802A83E5 		str	r2, [r3, #2688]
 173:layer1/prim_tch.c **** }
 614              		.loc 5 173 0
 615 000c 1EFF2FE1 		bx	lr
 616              	.L70:
 617              		.align	2
 618              	.L69:
 619 0010 00000000 		.word	l1a_tx_tch_compl
 620 0014 00000000 		.word	l1s
 621              	.LFE72:
 623              		.section	.ctors,"aw",%progbits
 624              		.align	2
 625 0000 00000000 		.word	prim_tch_init
 626              		.bss
 627              	meas_id.4463:
 628 0000 00       		.space	1
 629              		.section	.rodata.str1.4
 630 0033 00       		.align	2
 631              	.LC1:
 632 0034 54434820 		.ascii	"TCH FACCH: unable to allocate msgb\000"
 632      46414343 
 632      483A2075 
 632      6E61626C 
 632      6520746F 
 633              		.global	__udivsi3
 634              		.global	__divsi3
 635 0057 00       		.align	2
 636              	.LC2:
 637 0058 54434820 		.ascii	"TCH traffic: unable to allocate msgb\000"
 637      74726166 
 637      6669633A 
 637      20756E61 
 637      626C6520 
 638              		.section	.text.l1s_tch_resp,"ax",%progbits
 639              		.align	2
 641              	l1s_tch_resp:
 642              	.LFB73:
 174:layer1/prim_tch.c **** 
 175:layer1/prim_tch.c **** 
 176:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 177:layer1/prim_tch.c ****  * TCH: Voice & FACCH
 178:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 179:layer1/prim_tch.c **** 
 180:layer1/prim_tch.c **** /*
 181:layer1/prim_tch.c ****  * Voice and FACCH data are spread in various ways depending on a lot of
 182:layer1/prim_tch.c ****  * factors. Trying to handle that with the mframe scheduler is just a mess,
 183:layer1/prim_tch.c ****  * so we schedule it burst by burst and handle the complex logic inside the
 184:layer1/prim_tch.c ****  * primitive task code itself.
 185:layer1/prim_tch.c ****  */
 186:layer1/prim_tch.c **** 
 187:layer1/prim_tch.c **** 
 188:layer1/prim_tch.c **** #define FACCH_MEAS_HIST	8	/* Up to 8 bursts history */
 189:layer1/prim_tch.c **** struct l1s_rx_tch_state {
 190:layer1/prim_tch.c **** 	struct l1s_meas_hdr meas[FACCH_MEAS_HIST];
 191:layer1/prim_tch.c **** };
 192:layer1/prim_tch.c **** 
 193:layer1/prim_tch.c **** static struct l1s_rx_tch_state rx_tch;
 194:layer1/prim_tch.c **** 
 195:layer1/prim_tch.c **** 
 196:layer1/prim_tch.c **** static int l1s_tch_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 197:layer1/prim_tch.c **** {
 643              		.loc 5 197 0
 644              		@ args = 0, pretend = 0, frame = 24
 645              		@ frame_needed = 0, uses_anonymous_args = 0
 646              	.LVL48:
 647 0000 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 648              	.LCFI6:
 198:layer1/prim_tch.c **** 	static uint8_t meas_id = 0;
 199:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 200:layer1/prim_tch.c **** 	struct gsm_time rx_time;
 201:layer1/prim_tch.c **** 	uint8_t chan_nr;
 202:layer1/prim_tch.c **** 	uint16_t arfcn;
 203:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 204:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub;
 205:layer1/prim_tch.c **** 	uint32_t fn_report;
 206:layer1/prim_tch.c **** 	int facch_rx_now, traffic_rx_now;
 207:layer1/prim_tch.c **** 
 208:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 209:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 649              		.loc 5 209 0
 650 0004 B8349FE5 		ldr	r3, .L111
 651 0008 B8049FE5 		ldr	r0, .L111+4
 652              	.LVL49:
 653 000c 003093E5 		ldr	r3, [r3, #0]
 654              		.loc 5 197 0
 655 0010 20D04DE2 		sub	sp, sp, #32
 656              	.LCFI7:
 657              	.LVL50:
 658              		.loc 5 209 0
 659 0014 000083E0 		add	r0, r3, r0
 660 0018 AC149FE5 		ldr	r1, .L111+8
 661              	.LVL51:
 662              		.loc 5 197 0
 663 001c 0248A0E1 		mov	r4, r2, asl #16
 664              		.loc 5 209 0
 665 0020 FEFFFFEB 		bl	__umodsi3
 666              	.LVL52:
 667 0024 08508DE2 		add	r5, sp, #8
 668 0028 0010A0E1 		mov	r1, r0
 669              		.loc 5 197 0
 670 002c 2448A0E1 		mov	r4, r4, lsr #16
 671              	.LVL53:
 672              		.loc 5 209 0
 673 0030 0500A0E1 		mov	r0, r5
 674 0034 FEFFFFEB 		bl	gsm_fn2gsmtime
 210:layer1/prim_tch.c **** 	rfch_get_params(&rx_time, &arfcn, &tsc, &tn);
 211:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 675              		.loc 5 211 0
 676 0038 FF4004E2 		and	r4, r4, #255
 677              	.LVL54:
 678              		.loc 5 210 0
 679 003c 0500A0E1 		mov	r0, r5
 680 0040 1F208DE2 		add	r2, sp, #31
 681 0044 1E308DE2 		add	r3, sp, #30
 682 0048 1A108DE2 		add	r1, sp, #26
 683 004c FEFFFFEB 		bl	rfch_get_params
 684              		.loc 5 211 0
 685 0050 0400A0E1 		mov	r0, r4
 686              	.LVL55:
 687 0054 1E10DDE5 		ldrb	r1, [sp, #30]	@ zero_extendqisi2
 688 0058 FEFFFFEB 		bl	mframe_task2chan_nr
 212:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 213:layer1/prim_tch.c **** 
 214:layer1/prim_tch.c **** 	meas_id = (meas_id + 1) % FACCH_MEAS_HIST; /* absolute value doesn't matter */
 689              		.loc 5 214 0
 690 005c 6C649FE5 		ldr	r6, .L111+12
 691              		.loc 5 211 0
 692 0060 00A0A0E1 		mov	sl, r0
 693              	.LVL56:
 694              		.loc 5 212 0
 695 0064 1CC08DE2 		add	ip, sp, #28
 696 0068 0500A0E1 		mov	r0, r5
 697 006c 14208DE2 		add	r2, sp, #20
 698 0070 0080A0E3 		mov	r8, #0
 699 0074 0A10A0E1 		mov	r1, sl
 700 0078 1D308DE2 		add	r3, sp, #29
 701 007c 00C08DE5 		str	ip, [sp, #0]
 702 0080 04808DE5 		str	r8, [sp, #4]
 703 0084 FEFFFFEB 		bl	tch_get_params
 704              		.loc 5 214 0
 705 0088 0040D6E5 		ldrb	r4, [r6, #0]	@ zero_extendqisi2
 706 008c 014084E2 		add	r4, r4, #1
 215:layer1/prim_tch.c **** 
 216:layer1/prim_tch.c **** 	/* Collect measurements */
 217:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 707              		.loc 5 217 0
 708 0090 3C749FE5 		ldr	r7, .L111+16
 709              		.loc 5 214 0
 710 0094 1E4104E2 		and	r4, r4, #-2147483641
 711 0098 FF4004E2 		and	r4, r4, #255
 712 009c 0040C6E5 		strb	r4, [r6, #0]
 713              		.loc 5 217 0
 714 00a0 043097E5 		ldr	r3, [r7, #4]
 715 00a4 2C549FE5 		ldr	r5, .L111+20
 716 00a8 B011D3E1 		ldrh	r1, [r3, #16]
 717 00ac 844185E0 		add	r4, r5, r4, asl #3
 718 00b0 B210C4E1 		strh	r1, [r4, #2]	@ movhi
 218:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].pm_dbm8 =
 719              		.loc 5 218 0
 720 00b4 B201D3E1 		ldrh	r0, [r3, #18]
 721 00b8 A001A0E1 		mov	r0, r0, lsr #3
 722 00bc FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 723 00c0 B400C4E1 		strh	r0, [r4, #4]	@ movhi
 219:layer1/prim_tch.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
 220:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].freq_err =
 724              		.loc 5 220 0
 725 00c4 040097E5 		ldr	r0, [r7, #4]
 726 00c8 0C349FE5 		ldr	r3, .L111+24
 727 00cc F421D0E1 		ldrsh	r2, [r0, #20]
 728 00d0 920303E0 		mul	r3, r2, r3
 729 00d4 0010D6E5 		ldrb	r1, [r6, #0]	@ zero_extendqisi2
 730 00d8 FF2C83E2 		add	r2, r3, #65280
 731 00dc 8111A0E1 		mov	r1, r1, asl #3
 732 00e0 080053E1 		cmp	r3, r8
 733 00e4 FF2082E2 		add	r2, r2, #255
 734 00e8 0230A0B1 		movlt	r3, r2
 735 00ec 052081E0 		add	r2, r1, r5
 736 00f0 042082E2 		add	r2, r2, #4
 737 00f4 4338A0E1 		mov	r3, r3, asr #16
 738 00f8 B230C2E1 		strh	r3, [r2, #2]	@ movhi
 221:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 222:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 739              		.loc 5 222 0
 740 00fc B631D0E1 		ldrh	r3, [r0, #22]
 741 0100 B200D2E1 		ldrh	r0, [r2, #2]
 223:layer1/prim_tch.c **** 
 224:layer1/prim_tch.c **** 	/* feed computed frequency error into AFC loop */
 225:layer1/prim_tch.c **** 	if (rx_tch.meas[meas_id].snr > AFC_SNR_THRESHOLD)
 742              		.loc 5 225 0
 743 0104 0A0C53E3 		cmp	r3, #2560
 744              		.loc 5 222 0
 745 0108 B53081E1 		strh	r3, [r1, r5]	@ movhi
 226:layer1/prim_tch.c **** 		afc_input(rx_tch.meas[meas_id].freq_err, arfcn, 1);
 746              		.loc 5 226 0
 747 010c 0008A081 		movhi	r0, r0, asl #16
 227:layer1/prim_tch.c **** 	else
 228:layer1/prim_tch.c **** 		afc_input(rx_tch.meas[meas_id].freq_err, arfcn, 0);
 748              		.loc 5 228 0
 749 0110 0008A091 		movls	r0, r0, asl #16
 229:layer1/prim_tch.c **** 
 230:layer1/prim_tch.c **** 	/* feed computed TOA into TA loop */
 231:layer1/prim_tch.c **** 	toa_input(rx_tch.meas[meas_id].toa_qbit << 2, rx_tch.meas[meas_id].snr);
 750              		.loc 5 231 0
 751 0114 B4539FE5 		ldr	r5, .L111+12
 752              		.loc 5 226 0
 753 0118 4008A081 		movhi	r0, r0, asr #16
 754 011c 0120A083 		movhi	r2, #1
 755              		.loc 5 228 0
 756 0120 4008A091 		movls	r0, r0, asr #16
 757 0124 0820A091 		movls	r2, r8
 758              	.LVL57:
 759 0128 BA11DDE1 		ldrh	r1, [sp, #26]
 760 012c FEFFFFEB 		bl	afc_input
 761              		.loc 5 231 0
 762 0130 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 763 0134 9C439FE5 		ldr	r4, .L111+20
 764 0138 8331A0E1 		mov	r3, r3, asl #3
 765 013c 042083E0 		add	r2, r3, r4
 766 0140 F200D2E1 		ldrsh	r0, [r2, #2]
 767 0144 B41093E1 		ldrh	r1, [r3, r4]
 768 0148 0001A0E1 		mov	r0, r0, asl #2
 769 014c FEFFFFEB 		bl	toa_input
 232:layer1/prim_tch.c **** 
 233:layer1/prim_tch.c **** 	/* Tell the RF frontend to set the gain appropriately */
 234:layer1/prim_tch.c **** 	rffe_compute_gain(rx_tch.meas[meas_id].pm_dbm8 / 8,
 770              		.loc 5 234 0
 771 0150 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 772 0154 834184E0 		add	r4, r4, r3, asl #3
 773 0158 F400D4E1 		ldrsh	r0, [r4, #4]
 774 015c 073080E2 		add	r3, r0, #7
 775 0160 000050E3 		cmp	r0, #0
 776 0164 0300A0B1 		movlt	r0, r3
 777 0168 C001A0E1 		mov	r0, r0, asr #3
 778 016c 5010A0E3 		mov	r1, #80
 779 0170 FEFFFFEB 		bl	rffe_compute_gain
 780              	.LVL58:
 235:layer1/prim_tch.c **** 		CAL_DSP_TGT_BB_LVL);
 236:layer1/prim_tch.c **** 
 237:layer1/prim_tch.c **** 	/* FACCH Block end ? */
 238:layer1/prim_tch.c **** 	if (tch_f_hn) {
 781              		.loc 5 238 0
 782 0174 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 783 0178 000053E3 		cmp	r3, #0
 784 017c 6500000A 		beq	.L76
 239:layer1/prim_tch.c **** 		/* FACCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13) */
 240:layer1/prim_tch.c **** 		facch_rx_now = ((rx_time.fn % 13) % 4) == 3;
 241:layer1/prim_tch.c **** 	} else {
 242:layer1/prim_tch.c **** 		/* FAACH/H: See GSM 05.02 Clause 7 Table 1of9 */
 243:layer1/prim_tch.c **** 		uint8_t t2_norm = rx_time.t2 - tch_sub;
 244:layer1/prim_tch.c **** 		facch_rx_now = (t2_norm == 15) ||
 245:layer1/prim_tch.c **** 		               (t2_norm == 23) ||
 246:layer1/prim_tch.c **** 		               (t2_norm ==  6);
 247:layer1/prim_tch.c **** 	}
 248:layer1/prim_tch.c **** 
 249:layer1/prim_tch.c **** 	if (facch_rx_now && (dsp_api.ndb->a_fd[0] & (1<<B_BLUD))) {
 785              		.loc 5 249 0
 786 0180 08009DE5 		ldr	r0, [sp, #8]
 787 0184 0D10A0E3 		mov	r1, #13
 788 0188 FEFFFFEB 		bl	__umodsi3
 789 018c 030000E2 		and	r0, r0, #3
 790 0190 030050E3 		cmp	r0, #3
 791 0194 E400001A 		bne	.L79
 792 0198 6E0000EA 		b	.L78
 793              	.L76:
 794              	.LBB8:
 795              		.loc 5 243 0
 796 019c 0E30DDE5 		ldrb	r3, [sp, #14]	@ zero_extendqisi2
 797              	.LVL59:
 798 01a0 1C20DDE5 		ldrb	r2, [sp, #28]	@ zero_extendqisi2
 799 01a4 033062E0 		rsb	r3, r2, r3
 800 01a8 FF3003E2 		and	r3, r3, #255
 801              	.LVL60:
 802              		.loc 5 244 0
 803 01ac 170053E3 		cmp	r3, #23
 804 01b0 0F005313 		cmpne	r3, #15
 805 01b4 6E00000A 		beq	.L78
 806              	.LVL61:
 807 01b8 060053E3 		cmp	r3, #6
 808 01bc E100001A 		bne	.L81
 809              	.L78:
 810              	.LBE8:
 811              		.loc 5 249 0
 812 01c0 0C339FE5 		ldr	r3, .L111+16
 813              	.LVL62:
 814 01c4 002093E5 		ldr	r2, [r3, #0]
 815              	.LVL63:
 816 01c8 10339FE5 		ldr	r3, .L111+28
 817 01cc F33092E1 		ldrsh	r3, [r2, r3]
 818 01d0 000053E3 		cmp	r3, #0
 819 01d4 E10000AA 		bge	.L81
 820              	.LBB9:
 250:layer1/prim_tch.c **** 		struct msgb *msg;
 251:layer1/prim_tch.c **** 		struct l1ctl_info_dl *dl;
 252:layer1/prim_tch.c **** 		struct l1ctl_data_ind *di;
 253:layer1/prim_tch.c **** 		uint16_t num_biterr;
 254:layer1/prim_tch.c **** 		uint32_t avg_snr = 0;
 255:layer1/prim_tch.c **** 		int32_t avg_dbm8 = 0;
 256:layer1/prim_tch.c **** 		int i, n;
 257:layer1/prim_tch.c **** 
 258:layer1/prim_tch.c **** 		/* Allocate msgb */
 259:layer1/prim_tch.c **** 			/* FIXME: we actually want all allocation out of L1S! */
 260:layer1/prim_tch.c **** 		msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 821              		.loc 5 260 0
 822 01d8 0300A0E3 		mov	r0, #3
 823 01dc FEFFFFEB 		bl	l1ctl_msgb_alloc
 261:layer1/prim_tch.c **** 		if(!msg) {
 824              		.loc 5 261 0
 825 01e0 007050E2 		subs	r7, r0, #0
 826              	.LVL64:
 827 01e4 7B00001A 		bne	.L83
 262:layer1/prim_tch.c **** 			printf("TCH FACCH: unable to allocate msgb\n");
 828              		.loc 5 262 0
 829 01e8 F4029FE5 		ldr	r0, .L111+32
 830 01ec FEFFFFEB 		bl	puts
 831 01f0 CD0000EA 		b	.L85
 832              	.L83:
 263:layer1/prim_tch.c **** 			goto skip_rx_facch;
 264:layer1/prim_tch.c **** 		}
 265:layer1/prim_tch.c **** 
 266:layer1/prim_tch.c **** 		dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 833              		.loc 5 266 0
 834 01f4 0C10A0E3 		mov	r1, #12
 835 01f8 FEFFFFEB 		bl	msgb_put
 267:layer1/prim_tch.c **** 		di = (struct l1ctl_data_ind *) msgb_put(msg, sizeof(*di));
 836              		.loc 5 267 0
 837 01fc 1710A0E3 		mov	r1, #23
 838              		.loc 5 266 0
 839 0200 0050A0E1 		mov	r5, r0
 840              	.LVL65:
 841              		.loc 5 267 0
 842 0204 0700A0E1 		mov	r0, r7
 843 0208 FEFFFFEB 		bl	msgb_put
 268:layer1/prim_tch.c **** 
 269:layer1/prim_tch.c **** 		/* Fill DL header (should be about the first burst ... here is the last) */
 270:layer1/prim_tch.c **** 		dl->chan_nr = chan_nr;
 271:layer1/prim_tch.c **** 		dl->link_id = 0x00;	/* FACCH */
 844              		.loc 5 271 0
 845 020c 0040A0E3 		mov	r4, #0
 846              		.loc 5 270 0
 847 0210 00A0C5E5 		strb	sl, [r5, #0]
 848              		.loc 5 271 0
 849 0214 0140C5E5 		strb	r4, [r5, #1]
 850              		.loc 5 267 0
 851 0218 0080A0E1 		mov	r8, r0
 852              	.LVL66:
 272:layer1/prim_tch.c **** 		dl->band_arfcn = htons(arfcn);
 853              		.loc 5 272 0
 854 021c BA01DDE1 		ldrh	r0, [sp, #26]
 855 0220 FEFFFFEB 		bl	__fswab16
 856 0224 2034A0E1 		mov	r3, r0, lsr #8
 857 0228 0330C5E5 		strb	r3, [r5, #3]
 858 022c 0200C5E5 		strb	r0, [r5, #2]
 273:layer1/prim_tch.c **** 		dl->frame_nr = htonl(rx_time.fn);
 859              		.loc 5 273 0
 860 0230 08009DE5 		ldr	r0, [sp, #8]
 861 0234 FEFFFFEB 		bl	__fswab32
 862 0238 201CA0E1 		mov	r1, r0, lsr #24
 863 023c 2034A0E1 		mov	r3, r0, lsr #8
 864 0240 2028A0E1 		mov	r2, r0, lsr #16
 865 0244 0530C5E5 		strb	r3, [r5, #5]
 866 0248 0710C5E5 		strb	r1, [r5, #7]
 867 024c 0400C5E5 		strb	r0, [r5, #4]
 868 0250 0620C5E5 		strb	r2, [r5, #6]
 274:layer1/prim_tch.c **** 
 275:layer1/prim_tch.c **** 		/* Average SNR & RX level */
 276:layer1/prim_tch.c **** 		n = tch_f_hn ? 8 : 6;
 869              		.loc 5 276 0
 870 0254 74329FE5 		ldr	r3, .L111+12
 871 0258 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 872 025c 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 873 0260 040053E1 		cmp	r3, r4
 874 0264 0660A003 		moveq	r6, #6
 875              	.LVL67:
 876 0268 0860A013 		movne	r6, #8
 877 026c 081082E2 		add	r1, r2, #8
 878              	.LVL68:
 879 0270 0400A0E1 		mov	r0, r4
 880              	.LVL69:
 881 0274 04C0A0E1 		mov	ip, r4
 882              	.LVL70:
 883 0278 A90000EA 		b	.L89
 884              	.L90:
 885              	.LBB10:
 277:layer1/prim_tch.c **** 		for (i=0; i<n; i++) {
 278:layer1/prim_tch.c **** 			int j = (meas_id + FACCH_MEAS_HIST - i) % FACCH_MEAS_HIST;
 886              		.loc 5 278 0
 887 027c 1E3111E2 		ands	r3, r1, #-2147483641
 888 0280 01304342 		submi	r3, r3, #1
 889 0284 833EE041 		mvnmi	r3, r3, asl #29
 890 0288 A33EE041 		mvnmi	r3, r3, lsr #29
 891 028c 01308342 		addmi	r3, r3, #1
 279:layer1/prim_tch.c **** 			avg_snr += rx_tch.meas[j].snr;
 892              		.loc 5 279 0
 893 0290 8331A0E1 		mov	r3, r3, asl #3
 894 0294 0E2083E0 		add	r2, r3, lr
 280:layer1/prim_tch.c **** 			avg_dbm8 += rx_tch.meas[j].pm_dbm8;
 895              		.loc 5 280 0
 896 0298 F420D2E1 		ldrsh	r2, [r2, #4]
 897              		.loc 5 279 0
 898 029c BE3093E1 		ldrh	r3, [r3, lr]
 899              	.LBE10:
 900              		.loc 5 277 0
 901 02a0 011041E2 		sub	r1, r1, #1
 902              	.LBB11:
 903              		.loc 5 279 0
 904 02a4 030080E0 		add	r0, r0, r3
 905              		.loc 5 280 0
 906 02a8 024084E0 		add	r4, r4, r2
 907              	.L89:
 908              	.LBE11:
 909              		.loc 5 277 0
 910 02ac 06005CE1 		cmp	ip, r6
 911              	.LBB12:
 912              		.loc 5 279 0
 913 02b0 20E29FE5 		ldr	lr, .L111+20
 914              	.LBE12:
 915              		.loc 5 277 0
 916 02b4 01C08CE2 		add	ip, ip, #1
 917 02b8 9D0000BA 		blt	.L90
 281:layer1/prim_tch.c **** 		}
 282:layer1/prim_tch.c **** 
 283:layer1/prim_tch.c **** 		dl->snr = avg_snr / n;
 918              		.loc 5 283 0
 919 02bc 0610A0E1 		mov	r1, r6
 920 02c0 FEFFFFEB 		bl	__udivsi3
 921              	.LVL71:
 284:layer1/prim_tch.c **** 		dl->rx_level = dbm2rxlev(avg_dbm8 / (8*n));
 922              		.loc 5 284 0
 923 02c4 8611A0E1 		mov	r1, r6, asl #3
 924              		.loc 5 283 0
 925 02c8 0900C5E5 		strb	r0, [r5, #9]
 926              		.loc 5 284 0
 927 02cc 0400A0E1 		mov	r0, r4
 928 02d0 FEFFFFEB 		bl	__divsi3
 929 02d4 FEFFFFEB 		bl	dbm2rxlev
 285:layer1/prim_tch.c **** 
 286:layer1/prim_tch.c **** 		/* Errors & CRC status */
 287:layer1/prim_tch.c **** 		num_biterr = dsp_api.ndb->a_fd[2] & 0xffff;
 930              		.loc 5 287 0
 931 02d8 F4319FE5 		ldr	r3, .L111+16
 932              		.loc 5 284 0
 933 02dc 0800C5E5 		strb	r0, [r5, #8]
 934              		.loc 5 287 0
 935 02e0 002093E5 		ldr	r2, [r3, #0]
 936 02e4 FC319FE5 		ldr	r3, .L111+36
 937 02e8 B33092E1 		ldrh	r3, [r2, r3]
 938              	.LVL72:
 288:layer1/prim_tch.c **** 		if (num_biterr > 0xff)
 939              		.loc 5 288 0
 940 02ec FF0053E3 		cmp	r3, #255
 289:layer1/prim_tch.c **** 			dl->num_biterr = 0xff;
 941              		.loc 5 289 0
 942 02f0 0030E083 		mvnhi	r3, #0
 943              	.LVL73:
 944              	.LVL74:
 290:layer1/prim_tch.c **** 		else
 291:layer1/prim_tch.c **** 			dl->num_biterr = num_biterr;
 945              		.loc 5 291 0
 946 02f4 0A30C5E5 		strb	r3, [r5, #10]
 292:layer1/prim_tch.c **** 
 293:layer1/prim_tch.c **** 		dl->fire_crc = ((dsp_api.ndb->a_fd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> B_FIRE0;
 947              		.loc 5 293 0
 948 02f8 D4419FE5 		ldr	r4, .L111+16
 949              	.LVL75:
 950 02fc DC319FE5 		ldr	r3, .L111+28
 951              	.LVL76:
 952 0300 002094E5 		ldr	r2, [r4, #0]
 953 0304 B33092E1 		ldrh	r3, [r2, r3]
 954 0308 603003E2 		and	r3, r3, #96
 955 030c C332A0E1 		mov	r3, r3, asr #5
 956 0310 0B30C5E5 		strb	r3, [r5, #11]
 294:layer1/prim_tch.c **** 
 295:layer1/prim_tch.c **** 		/* Update rx level for pm report */
 296:layer1/prim_tch.c **** 		pu_update_rx_level(dl->rx_level);
 957              		.loc 5 296 0
 958 0314 0800D5E5 		ldrb	r0, [r5, #8]	@ zero_extendqisi2
 959 0318 FEFFFFEB 		bl	pu_update_rx_level
 297:layer1/prim_tch.c **** 
 298:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 299:layer1/prim_tch.c **** 		dsp_memcpy_from_api(di->data, &dsp_api.ndb->a_fd[3], 23, 0);
 960              		.loc 5 299 0
 961 031c 001094E5 		ldr	r1, [r4, #0]
 962 0320 0800A0E1 		mov	r0, r8
 963 0324 221E81E2 		add	r1, r1, #544
 964 0328 1720A0E3 		mov	r2, #23
 965 032c 0030A0E3 		mov	r3, #0
 966 0330 FEFFFFEB 		bl	dsp_memcpy_from_api
 300:layer1/prim_tch.c **** 
 301:layer1/prim_tch.c **** 		/* Give message to up layer */
 302:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 967              		.loc 5 302 0
 968 0334 0700A0E1 		mov	r0, r7
 969 0338 FEFFFFEB 		bl	l1_queue_for_l2
 970              	.L85:
 303:layer1/prim_tch.c **** 
 304:layer1/prim_tch.c **** 	skip_rx_facch:
 305:layer1/prim_tch.c **** 		/* Reset A_FD header (needed by DSP) */
 306:layer1/prim_tch.c **** 		/* B_FIRE1 =1, B_FIRE0 =0 , BLUD =0 */
 307:layer1/prim_tch.c **** 		dsp_api.ndb->a_fd[0] = (1<<B_FIRE1);
 971              		.loc 5 307 0
 972 033c 90319FE5 		ldr	r3, .L111+16
 973 0340 002093E5 		ldr	r2, [r3, #0]
 308:layer1/prim_tch.c **** 		dsp_api.ndb->a_fd[2] = 0xffff;
 309:layer1/prim_tch.c **** 
 310:layer1/prim_tch.c **** 		/* Reset A_DD_0 header in NDB (needed by DSP) */
 311:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_0[0] = 0;
 312:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_0[2] = 0xffff;
 313:layer1/prim_tch.c **** 
 314:layer1/prim_tch.c **** 		/* Reset A_DD_1 header in NDB (needed by DSP) */
 315:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_1[0] = 0;
 316:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_1[2] = 0xffff;
 974              		.loc 5 316 0
 975 0344 0010E0E3 		mvn	r1, #0	@ movhi
 976 0348 433FA0E3 		mov	r3, #268
 977 034c B31082E1 		strh	r1, [r2, r3]	@ movhi
 978              		.loc 5 307 0
 979 0350 88319FE5 		ldr	r3, .L111+28
 980 0354 4010A0E3 		mov	r1, #64	@ movhi
 981 0358 B31082E1 		strh	r1, [r2, r3]	@ movhi
 982              		.loc 5 308 0
 983 035c 043083E2 		add	r3, r3, #4
 984 0360 0010E0E3 		mvn	r1, #0	@ movhi
 985 0364 B31082E1 		strh	r1, [r2, r3]	@ movhi
 986              		.loc 5 311 0
 987 0368 1A3083E2 		add	r3, r3, #26
 988 036c 0010A0E3 		mov	r1, #0	@ movhi
 989 0370 B31082E1 		strh	r1, [r2, r3]	@ movhi
 990              		.loc 5 312 0
 991 0374 043083E2 		add	r3, r3, #4
 992 0378 0010E0E3 		mvn	r1, #0	@ movhi
 993 037c B31082E1 		strh	r1, [r2, r3]	@ movhi
 994              		.loc 5 315 0
 995 0380 4D3F43E2 		sub	r3, r3, #308
 996 0384 0010A0E3 		mov	r1, #0	@ movhi
 997 0388 B31082E1 		strh	r1, [r2, r3]	@ movhi
 998              	.LVL77:
 999              	.L81:
 1000              	.LBE9:
 317:layer1/prim_tch.c **** 	}
 318:layer1/prim_tch.c **** 
 319:layer1/prim_tch.c **** 	/* Traffic now ? */
 320:layer1/prim_tch.c **** 	if (tch_f_hn) {
 1001              		.loc 5 320 0
 1002 038c 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 1003              	.LVL78:
 1004 0390 000053E3 		cmp	r3, #0
 1005 0394 EC00000A 		beq	.L96
 1006              	.L79:
 321:layer1/prim_tch.c **** 		/* TCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13)*/
 322:layer1/prim_tch.c **** 		traffic_rx_now = ((rx_time.fn % 13) % 4) == 3;
 1007              		.loc 5 322 0
 1008 0398 08009DE5 		ldr	r0, [sp, #8]
 1009 039c 0D10A0E3 		mov	r1, #13
 1010 03a0 FEFFFFEB 		bl	__umodsi3
 1011 03a4 030000E2 		and	r0, r0, #3
 1012 03a8 030050E3 		cmp	r0, #3
 1013 03ac 0000A013 		movne	r0, #0
 1014 03b0 0100A003 		moveq	r0, #1
 1015              	.LVL79:
 1016 03b4 F60000EA 		b	.L97
 1017              	.LVL80:
 1018              	.L96:
 323:layer1/prim_tch.c **** 	} else {
 324:layer1/prim_tch.c **** 		/* TCH/H0: B0(0,2,4,6),B1(4,6,8,10),B2(8,10,0,2) (mod 13) */
 325:layer1/prim_tch.c **** 		/*     H1: B0(1,3,5,7),B1(5,7,9,11),B2(9,11,1,3) (mod 13) */
 326:layer1/prim_tch.c **** 		traffic_rx_now = (((rx_time.fn - tch_sub + 13) % 13) % 4) == 2;
 1019              		.loc 5 326 0
 1020 03b8 1C30DDE5 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 1021 03bc 08009DE5 		ldr	r0, [sp, #8]
 1022 03c0 000063E0 		rsb	r0, r3, r0
 1023 03c4 0D0080E2 		add	r0, r0, #13
 1024 03c8 0D10A0E3 		mov	r1, #13
 1025 03cc FEFFFFEB 		bl	__umodsi3
 1026 03d0 030000E2 		and	r0, r0, #3
 1027 03d4 020050E3 		cmp	r0, #2
 1028 03d8 0000A013 		movne	r0, #0
 1029 03dc 0100A003 		moveq	r0, #1
 1030              	.LVL81:
 1031              	.L97:
 327:layer1/prim_tch.c **** 	}
 328:layer1/prim_tch.c **** 
 329:layer1/prim_tch.c **** 	if (traffic_rx_now) {
 1032              		.loc 5 329 0
 1033 03e0 000050E3 		cmp	r0, #0
 1034 03e4 2901000A 		beq	.L98
 1035              	.LBB13:
 330:layer1/prim_tch.c **** 		volatile uint16_t *traffic_buf;
 331:layer1/prim_tch.c **** 
 332:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_dd_1 : dsp_api.ndb->a_dd_0;
 1036              		.loc 5 332 0
 1037 03e8 1C30DDE5 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 1038 03ec 000053E3 		cmp	r3, #0
 1039 03f0 DC309FE5 		ldr	r3, .L111+16
 1040 03f4 00309315 		ldrne	r3, [r3, #0]
 1041 03f8 00309305 		ldreq	r3, [r3, #0]
 1042 03fc 426F8312 		addne	r6, r3, #264
 1043              	.LVL82:
 1044 0400 8E6F8302 		addeq	r6, r3, #568
 333:layer1/prim_tch.c **** 
 334:layer1/prim_tch.c **** 		if (traffic_buf[0] & (1<<B_BLUD)) {
 1045              		.loc 5 334 0
 1046 0404 B030D6E1 		ldrh	r3, [r6, #0]
 1047 0408 020913E3 		tst	r3, #32768
 1048 040c 2901000A 		beq	.L98
 335:layer1/prim_tch.c **** 			/* Send the data to upper layers (if interested and good frame) */
 336:layer1/prim_tch.c **** 			if ((l1s.audio_mode & AUDIO_RX_TRAFFIC_IND) &&
 1049              		.loc 5 336 0
 1050 0410 AC309FE5 		ldr	r3, .L111
 1051 0414 4C3AD3E5 		ldrb	r3, [r3, #2636]	@ zero_extendqisi2
 1052 0418 080013E3 		tst	r3, #8
 1053 041c 2501000A 		beq	.L104
 1054 0420 AC309FE5 		ldr	r3, .L111+16
 1055 0424 002093E5 		ldr	r2, [r3, #0]
 1056 0428 8E3FA0E3 		mov	r3, #568
 1057 042c B33092E1 		ldrh	r3, [r2, r3]
 1058 0430 044013E2 		ands	r4, r3, #4
 1059 0434 2501001A 		bne	.L104
 1060              	.LBB14:
 337:layer1/prim_tch.c **** 			    !(dsp_api.ndb->a_dd_0[0] & (1<<B_BFI))) {
 338:layer1/prim_tch.c **** 				struct msgb *msg;
 339:layer1/prim_tch.c **** 				struct l1ctl_info_dl *dl;
 340:layer1/prim_tch.c **** 				struct l1ctl_traffic_ind *ti;
 341:layer1/prim_tch.c **** 				uint8_t *payload;
 342:layer1/prim_tch.c **** 
 343:layer1/prim_tch.c **** 				/* Allocate msgb */
 344:layer1/prim_tch.c **** 				/* FIXME: we actually want all allocation out of L1S! */
 345:layer1/prim_tch.c **** 				msg = l1ctl_msgb_alloc(L1CTL_TRAFFIC_IND);
 1061              		.loc 5 345 0
 1062 0438 1E00A0E3 		mov	r0, #30
 1063              	.LVL83:
 1064 043c FEFFFFEB 		bl	l1ctl_msgb_alloc
 346:layer1/prim_tch.c **** 				if(!msg) {
 1065              		.loc 5 346 0
 1066 0440 005050E2 		subs	r5, r0, #0
 1067              	.LVL84:
 1068 0444 1301001A 		bne	.L107
 347:layer1/prim_tch.c **** 					printf("TCH traffic: unable to allocate msgb\n");
 1069              		.loc 5 347 0
 1070 0448 9C009FE5 		ldr	r0, .L111+40
 1071 044c FEFFFFEB 		bl	puts
 1072 0450 250100EA 		b	.L104
 1073              	.L107:
 348:layer1/prim_tch.c **** 					goto skip_rx_traffic;
 349:layer1/prim_tch.c **** 				}
 350:layer1/prim_tch.c **** 
 351:layer1/prim_tch.c **** 				dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 1074              		.loc 5 351 0
 1075 0454 0C10A0E3 		mov	r1, #12
 1076 0458 FEFFFFEB 		bl	msgb_put
 352:layer1/prim_tch.c **** 				ti = (struct l1ctl_traffic_ind *) msgb_put(msg, sizeof(*ti));
 1077              		.loc 5 352 0
 1078 045c 0410A0E1 		mov	r1, r4
 1079 0460 0500A0E1 		mov	r0, r5
 1080 0464 FEFFFFEB 		bl	msgb_put
 353:layer1/prim_tch.c **** 				payload = (uint8_t *) msgb_put(msg, 33);
 1081              		.loc 5 353 0
 1082 0468 2110A0E3 		mov	r1, #33
 1083 046c 0500A0E1 		mov	r0, r5
 1084 0470 FEFFFFEB 		bl	msgb_put
 354:layer1/prim_tch.c **** 
 355:layer1/prim_tch.c **** 				/* Copy actual data, skipping the information block [0,1,2] */
 356:layer1/prim_tch.c **** 				dsp_memcpy_from_api(payload, &traffic_buf[3], 33, 1);
 1085              		.loc 5 356 0
 1086 0474 061086E2 		add	r1, r6, #6
 1087              		.loc 5 353 0
 1088 0478 0040A0E1 		mov	r4, r0
 1089              	.LVL85:
 1090              		.loc 5 356 0
 1091 047c 2120A0E3 		mov	r2, #33
 1092 0480 0130A0E3 		mov	r3, #1
 1093 0484 FEFFFFEB 		bl	dsp_memcpy_from_api
 357:layer1/prim_tch.c **** 
 358:layer1/prim_tch.c **** 				/**
 359:layer1/prim_tch.c **** 				 * Perform some bit conversations
 360:layer1/prim_tch.c **** 				 * FIXME: what about other (than FR) codecs?
 361:layer1/prim_tch.c **** 				 */
 362:layer1/prim_tch.c **** 				tch_fr_bit_magic(payload, 1);
 1094              		.loc 5 362 0
 1095 0488 0400A0E1 		mov	r0, r4
 1096 048c 0110A0E3 		mov	r1, #1
 1097 0490 FEFFFFEB 		bl	tch_fr_bit_magic
 363:layer1/prim_tch.c **** 
 364:layer1/prim_tch.c **** 				/* Give message to up layer */
 365:layer1/prim_tch.c **** 				l1_queue_for_l2(msg);
 1098              		.loc 5 365 0
 1099 0494 0500A0E1 		mov	r0, r5
 1100 0498 FEFFFFEB 		bl	l1_queue_for_l2
 1101              	.LVL86:
 1102              	.L104:
 1103              	.LBE14:
 366:layer1/prim_tch.c **** 			}
 367:layer1/prim_tch.c **** 
 368:layer1/prim_tch.c **** 	skip_rx_traffic:
 369:layer1/prim_tch.c **** 			/* Reset traffic buffer header in NDB (needed by DSP) */
 370:layer1/prim_tch.c **** 			traffic_buf[0] = 0;
 1104              		.loc 5 370 0
 1105 049c 0020A0E3 		mov	r2, #0	@ movhi
 371:layer1/prim_tch.c **** 			traffic_buf[2] = 0xffff;
 1106              		.loc 5 371 0
 1107 04a0 0030E0E3 		mvn	r3, #0	@ movhi
 1108              		.loc 5 370 0
 1109 04a4 B020C6E1 		strh	r2, [r6, #0]	@ movhi
 1110              		.loc 5 371 0
 1111 04a8 B430C6E1 		strh	r3, [r6, #4]	@ movhi
 1112              	.LVL87:
 1113              	.L98:
 1114              	.LBE13:
 372:layer1/prim_tch.c **** 		}
 373:layer1/prim_tch.c **** 	}
 374:layer1/prim_tch.c **** 
 375:layer1/prim_tch.c **** 	/* mark READ page as being used */
 376:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 1115              		.loc 5 376 0
 1116 04ac 20309FE5 		ldr	r3, .L111+16
 1117 04b0 0120A0E3 		mov	r2, #1
 377:layer1/prim_tch.c **** 
 378:layer1/prim_tch.c **** 	return 0;
 379:layer1/prim_tch.c **** }
 1118              		.loc 5 379 0
 1119 04b4 0000A0E3 		mov	r0, #0
 1120              	.LVL88:
 1121              		.loc 5 376 0
 1122 04b8 182083E5 		str	r2, [r3, #24]
 1123              		.loc 5 379 0
 1124 04bc 20D08DE2 		add	sp, sp, #32
 1125 04c0 F085BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, pc}
 1126              	.L112:
 1127              		.align	2
 1128              	.L111:
 1129 04c4 00000000 		.word	l1s
 1130 04c8 FF6F2900 		.word	2715647
 1131 04cc 00702900 		.word	2715648
 1132 04d0 00000000 		.word	meas_id.4463
 1133 04d4 00000000 		.word	dsp_api
 1134 04d8 34000000 		.word	rx_tch
 1135 04dc C0500100 		.word	86208
 1136 04e0 1A020000 		.word	538
 1137 04e4 34000000 		.word	.LC1
 1138 04e8 1E020000 		.word	542
 1139 04ec 58000000 		.word	.LC2
 1140              	.LFE73:
 1142              		.bss
 1143 0001 000000   		.align	2
 1144              	icnt.4642:
 1145 0004 00000000 		.space	4
 1146              		.section	.text.l1s_tch_cmd,"ax",%progbits
 1147              		.align	2
 1149              	l1s_tch_cmd:
 1150              	.LFB74:
 380:layer1/prim_tch.c **** 
 381:layer1/prim_tch.c **** static int l1s_tch_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 382:layer1/prim_tch.c **** {
 1151              		.loc 5 382 0
 1152              		@ args = 0, pretend = 0, frame = 12
 1153              		@ frame_needed = 0, uses_anonymous_args = 0
 1154              	.LVL89:
 1155 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1156              	.LCFI8:
 1157 0004 0248A0E1 		mov	r4, r2, asl #16
 1158 0008 18D04DE2 		sub	sp, sp, #24
 1159              	.LCFI9:
 1160              	.LVL90:
 1161              		.loc 5 382 0
 1162 000c 2448A0E1 		mov	r4, r4, lsr #16
 383:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 384:layer1/prim_tch.c **** 	uint8_t chan_nr;
 385:layer1/prim_tch.c **** 	uint16_t arfcn;
 386:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 387:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 388:layer1/prim_tch.c **** 	uint32_t fn_report;
 389:layer1/prim_tch.c **** 	uint8_t sync = 0;
 390:layer1/prim_tch.c **** 	static int icnt;
 391:layer1/prim_tch.c **** 	int facch_tx_now, traffic_tx_now;
 392:layer1/prim_tch.c **** 
 393:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 394:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 1163              		.loc 5 394 0
 1164 0010 17208DE2 		add	r2, sp, #23
 1165              	.LVL91:
 1166 0014 16308DE2 		add	r3, sp, #22
 1167 0018 38039FE5 		ldr	r0, .L148
 1168              	.LVL92:
 1169 001c 10108DE2 		add	r1, sp, #16
 1170              	.LVL93:
 395:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1171              		.loc 5 395 0
 1172 0020 FF4004E2 		and	r4, r4, #255
 1173              	.LVL94:
 1174              		.loc 5 394 0
 1175 0024 FEFFFFEB 		bl	rfch_get_params
 1176              	.LVL95:
 1177              		.loc 5 395 0
 1178 0028 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 1179 002c 0400A0E1 		mov	r0, r4
 1180 0030 FEFFFFEB 		bl	mframe_task2chan_nr
 396:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1181              		.loc 5 396 0
 1182 0034 14C08DE2 		add	ip, sp, #20
 1183              		.loc 5 395 0
 1184 0038 0010A0E1 		mov	r1, r0
 1185              		.loc 5 396 0
 1186 003c 0C208DE2 		add	r2, sp, #12
 1187 0040 10039FE5 		ldr	r0, .L148
 1188 0044 00C08DE5 		str	ip, [sp, #0]
 1189 0048 15308DE2 		add	r3, sp, #21
 1190 004c 13C08DE2 		add	ip, sp, #19
 1191 0050 04C08DE5 		str	ip, [sp, #4]
 1192 0054 FEFFFFEB 		bl	tch_get_params
 397:layer1/prim_tch.c **** 
 398:layer1/prim_tch.c **** 	/* Sync & FACCH delay */
 399:layer1/prim_tch.c **** 	if (l1s.tch_sync) {
 1193              		.loc 5 399 0
 1194 0058 FC029FE5 		ldr	r0, .L148+4
 1195 005c 4B2AD0E5 		ldrb	r2, [r0, #2635]	@ zero_extendqisi2
 1196 0060 000052E3 		cmp	r2, #0
 1197 0064 F4129FE5 		ldr	r1, .L148+8
 400:layer1/prim_tch.c **** 		l1s.tch_sync = 0;
 1198              		.loc 5 400 0
 1199 0068 0030A013 		movne	r3, #0
 401:layer1/prim_tch.c **** 		sync = 1;
 402:layer1/prim_tch.c **** 		icnt = 0;
 1200              		.loc 5 402 0
 1201 006c 0160A013 		movne	r6, #1
 1202              	.LVL96:
 1203 0070 00308115 		strne	r3, [r1, #0]
 1204              		.loc 5 400 0
 1205 0074 4B3AC015 		strneb	r3, [r0, #2635]
 1206 0078 2200001A 		bne	.L116
 1207              	.LVL97:
 1208              	.L114:
 403:layer1/prim_tch.c **** 	} else if (icnt <= 26)
 1209              		.loc 5 403 0
 1210 007c 003091E5 		ldr	r3, [r1, #0]
 1211 0080 1A0053E3 		cmp	r3, #26
 404:layer1/prim_tch.c **** 		icnt++;
 1212              		.loc 5 404 0
 1213 0084 013083D2 		addle	r3, r3, #1
 1214 0088 003081D5 		strle	r3, [r1, #0]
 1215 008c 0260A0E1 		mov	r6, r2
 1216              	.LVL98:
 1217              	.L116:
 1218              	.LVL99:
 405:layer1/prim_tch.c **** 
 406:layer1/prim_tch.c **** 	/* Load FACCH data if we start a new burst */
 407:layer1/prim_tch.c **** 	/* (the DSP wants the data on the CMD of the burst _preceding_ the
 408:layer1/prim_tch.c **** 	 * first burst) */
 409:layer1/prim_tch.c **** 	if (tch_f_hn) {
 1219              		.loc 5 409 0
 1220 0090 1530DDE5 		ldrb	r3, [sp, #21]	@ zero_extendqisi2
 1221 0094 000053E3 		cmp	r3, #0
 1222 0098 BC329FE5 		ldr	r3, .L148+4
 1223 009c 2D00000A 		beq	.L119
 410:layer1/prim_tch.c **** 		/* FACCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) */
 411:layer1/prim_tch.c **** 		facch_tx_now = ((l1s.next_time.fn % 13) % 4) == 3;
 412:layer1/prim_tch.c **** 	} else {
 413:layer1/prim_tch.c **** 		/* FAACH/H: See GSM 05.02 Clause 7 Table 1of9 */
 414:layer1/prim_tch.c **** 		uint8_t t2_norm = l1s.next_time.t2 - tch_sub;
 415:layer1/prim_tch.c **** 		facch_tx_now = (t2_norm == 23) ||
 416:layer1/prim_tch.c **** 		               (t2_norm ==  6) ||
 417:layer1/prim_tch.c **** 		               (t2_norm == 15);
 418:layer1/prim_tch.c **** 	}
 419:layer1/prim_tch.c **** 
 420:layer1/prim_tch.c **** 	if (facch_tx_now) {
 1224              		.loc 5 420 0
 1225 00a0 0C0093E5 		ldr	r0, [r3, #12]
 1226 00a4 0D10A0E3 		mov	r1, #13
 1227 00a8 FEFFFFEB 		bl	__umodsi3
 1228 00ac 030000E2 		and	r0, r0, #3
 1229 00b0 030050E3 		cmp	r0, #3
 1230 00b4 6500001A 		bne	.L122
 1231 00b8 360000EA 		b	.L121
 1232              	.L119:
 1233              	.LBB15:
 1234              		.loc 5 414 0
 1235 00bc 1230D3E5 		ldrb	r3, [r3, #18]	@ zero_extendqisi2
 1236              	.LVL100:
 1237 00c0 1420DDE5 		ldrb	r2, [sp, #20]	@ zero_extendqisi2
 1238 00c4 033062E0 		rsb	r3, r2, r3
 1239 00c8 FF3003E2 		and	r3, r3, #255
 1240              	.LVL101:
 1241              		.loc 5 415 0
 1242 00cc 060053E3 		cmp	r3, #6
 1243 00d0 17005313 		cmpne	r3, #23
 1244 00d4 3600000A 		beq	.L121
 1245              	.LVL102:
 1246 00d8 0F0053E3 		cmp	r3, #15
 1247 00dc 6200001A 		bne	.L124
 1248              	.L121:
 1249              	.LBE15:
 1250              	.LBB16:
 421:layer1/prim_tch.c **** 		uint16_t *info_ptr = dsp_api.ndb->a_fu;
 1251              		.loc 5 421 0
 1252 00e0 7C329FE5 		ldr	r3, .L148+12
 1253              	.LVL103:
 1254 00e4 002093E5 		ldr	r2, [r3, #0]
 1255              	.LVL104:
 422:layer1/prim_tch.c **** 		struct msgb *msg;
 423:layer1/prim_tch.c **** 		const uint8_t *data;
 424:layer1/prim_tch.c **** 
 425:layer1/prim_tch.c **** 		/* Pull FACCH data (if ready) */
 426:layer1/prim_tch.c **** 		if (icnt > 26)
 1256              		.loc 5 426 0
 1257 00e8 70329FE5 		ldr	r3, .L148+8
 1258 00ec 003093E5 		ldr	r3, [r3, #0]
 1259              		.loc 5 421 0
 1260 00f0 0A4D82E2 		add	r4, r2, #640
 1261              	.LVL105:
 1262              		.loc 5 426 0
 1263 00f4 1A0053E3 		cmp	r3, #26
 1264              		.loc 5 421 0
 1265 00f8 024084E2 		add	r4, r4, #2
 427:layer1/prim_tch.c **** 			msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_MAIN]);
 428:layer1/prim_tch.c **** 		else
 429:layer1/prim_tch.c **** 			msg = NULL;
 430:layer1/prim_tch.c **** 
 431:layer1/prim_tch.c **** 		/* If TX is empty and we're signalling only, use dummy frame */
 432:layer1/prim_tch.c **** 		if (msg)
 433:layer1/prim_tch.c **** 			data = msg->l3h;
 1266              		.loc 5 433 0
 1267 00fc 0050A0D3 		movle	r5, #0
 1268              	.LVL106:
 1269              		.loc 5 426 0
 1270 0100 440000DA 		ble	.L127
 1271              		.loc 5 427 0
 1272 0104 5C029FE5 		ldr	r0, .L148+16
 1273 0108 FEFFFFEB 		bl	msgb_dequeue
 1274              		.loc 5 432 0
 1275 010c 005050E2 		subs	r5, r0, #0
 1276              		.loc 5 433 0
 1277 0110 18109515 		ldrne	r1, [r5, #24]
 1278              	.LVL107:
 1279              		.loc 5 432 0
 1280 0114 4900001A 		bne	.L129
 1281              	.L127:
 1282              	.LVL108:
 434:layer1/prim_tch.c **** 		else if (tch_mode == SIG_ONLY_MODE)
 1283              		.loc 5 434 0
 1284 0118 1330DDE5 		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 1285 011c 000053E3 		cmp	r3, #0
 1286 0120 5400001A 		bne	.L130
 435:layer1/prim_tch.c **** 			data = pu_get_idle_frame();
 1287              		.loc 5 435 0
 1288 0124 FEFFFFEB 		bl	pu_get_idle_frame
 1289              	.LVL109:
 1290 0128 0010A0E1 		mov	r1, r0
 1291              	.LVL110:
 1292              	.L129:
 436:layer1/prim_tch.c **** 		else
 437:layer1/prim_tch.c **** 			data = NULL;
 438:layer1/prim_tch.c **** 
 439:layer1/prim_tch.c **** 		/* Do we really send something ? */
 440:layer1/prim_tch.c **** 		if (data) {
 1293              		.loc 5 440 0
 1294 012c 000051E3 		cmp	r1, #0
 1295 0130 5400000A 		beq	.L130
 441:layer1/prim_tch.c **** 			/* Fill data block header */
 442:layer1/prim_tch.c **** 			info_ptr[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1296              		.loc 5 442 0
 1297 0134 0239A0E3 		mov	r3, #32768
 1298 0138 B030C4E1 		strh	r3, [r4, #0]	@ movhi
 443:layer1/prim_tch.c **** 			info_ptr[1] = 0;		/* 2nd word: cleared. */
 1299              		.loc 5 443 0
 1300 013c 0030A0E3 		mov	r3, #0	@ movhi
 1301 0140 B230C4E1 		strh	r3, [r4, #2]	@ movhi
 444:layer1/prim_tch.c **** 			info_ptr[2] = 0;		/* 3nd word: cleared. */
 1302              		.loc 5 444 0
 1303 0144 B430C4E1 		strh	r3, [r4, #4]	@ movhi
 445:layer1/prim_tch.c **** 
 446:layer1/prim_tch.c **** 			/* Copy the actual data after the header */
 447:layer1/prim_tch.c **** 			dsp_memcpy_to_api(&info_ptr[3], data, 23, 0);
 1304              		.loc 5 447 0
 1305 0148 060084E2 		add	r0, r4, #6
 1306 014c 1720A0E3 		mov	r2, #23
 1307 0150 0030A0E3 		mov	r3, #0
 1308 0154 FEFFFFEB 		bl	dsp_memcpy_to_api
 1309              	.LVL111:
 1310              	.L130:
 448:layer1/prim_tch.c **** 		}
 449:layer1/prim_tch.c **** 
 450:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 451:layer1/prim_tch.c **** 		if (msg) {
 1311              		.loc 5 451 0
 1312 0158 000055E3 		cmp	r5, #0
 1313 015c 6200000A 		beq	.L124
 452:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 453:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_FACCH;
 1314              		.loc 5 453 0
 1315 0160 04C29FE5 		ldr	ip, .L148+20
 1316              		.loc 5 452 0
 1317 0164 F0119FE5 		ldr	r1, .L148+4
 1318              	.LVL112:
 1319              		.loc 5 453 0
 1320 0168 B020DCE1 		ldrh	r2, [ip, #0]
 1321              		.loc 5 452 0
 1322 016c FC319FE5 		ldr	r3, .L148+24
 1323 0170 BC10D1E1 		ldrh	r1, [r1, #12]
 1324              		.loc 5 453 0
 1325 0174 022082E3 		orr	r2, r2, #2
 454:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1326              		.loc 5 454 0
 1327 0178 0300A0E3 		mov	r0, #3
 1328              		.loc 5 452 0
 1329 017c B010C3E1 		strh	r1, [r3, #0]	@ movhi
 1330              		.loc 5 453 0
 1331 0180 B020CCE1 		strh	r2, [ip, #0]	@ movhi
 1332              		.loc 5 454 0
 1333 0184 FEFFFFEB 		bl	l1s_compl_sched
 455:layer1/prim_tch.c **** 		}
 456:layer1/prim_tch.c **** 
 457:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 458:layer1/prim_tch.c **** 		if (msg)
 459:layer1/prim_tch.c **** 			msgb_free(msg);
 1334              		.loc 5 459 0
 1335 0188 0500A0E1 		mov	r0, r5
 1336 018c FEFFFFEB 		bl	msgb_free
 1337              	.LVL113:
 1338              	.L124:
 1339              	.LBE16:
 460:layer1/prim_tch.c **** 	}
 461:layer1/prim_tch.c **** 
 462:layer1/prim_tch.c **** 	/* Traffic now ? */
 463:layer1/prim_tch.c **** 	if (tch_f_hn) {
 1340              		.loc 5 463 0
 1341 0190 1530DDE5 		ldrb	r3, [sp, #21]	@ zero_extendqisi2
 1342              	.LVL114:
 1343 0194 000053E3 		cmp	r3, #0
 1344 0198 6E00000A 		beq	.L134
 1345              	.L122:
 464:layer1/prim_tch.c **** 		/* TCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13)*/
 465:layer1/prim_tch.c **** 		traffic_tx_now = ((l1s.next_time.fn % 13) % 4) == 3;
 1346              		.loc 5 465 0
 1347 019c B8319FE5 		ldr	r3, .L148+4
 1348 01a0 0D10A0E3 		mov	r1, #13
 1349              	.LVL115:
 1350 01a4 0C0093E5 		ldr	r0, [r3, #12]
 1351 01a8 FEFFFFEB 		bl	__umodsi3
 1352 01ac 030000E2 		and	r0, r0, #3
 1353 01b0 030050E3 		cmp	r0, #3
 1354 01b4 0000A013 		movne	r0, #0
 1355 01b8 0100A003 		moveq	r0, #1
 1356              	.LVL116:
 1357 01bc 790000EA 		b	.L135
 1358              	.LVL117:
 1359              	.L134:
 466:layer1/prim_tch.c **** 	} else {
 467:layer1/prim_tch.c **** 		/* TCH/H0: B0(0,2,4,6),B1(4,6,8,10),B2(8,10,0,2) (mod 13) */
 468:layer1/prim_tch.c **** 		/*     H1: B0(1,3,5,7),B1(5,7,9,11),B2(9,11,1,3) (mod 13) */
 469:layer1/prim_tch.c **** 		traffic_tx_now = (((l1s.next_time.fn - tch_sub + 13) % 13) % 4) == 2;
 1360              		.loc 5 469 0
 1361 01c0 94319FE5 		ldr	r3, .L148+4
 1362 01c4 0C0093E5 		ldr	r0, [r3, #12]
 1363 01c8 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1364 01cc 000063E0 		rsb	r0, r3, r0
 1365 01d0 0D0080E2 		add	r0, r0, #13
 1366 01d4 0D10A0E3 		mov	r1, #13
 1367              	.LVL118:
 1368 01d8 FEFFFFEB 		bl	__umodsi3
 1369 01dc 030000E2 		and	r0, r0, #3
 1370 01e0 020050E3 		cmp	r0, #2
 1371 01e4 0000A013 		movne	r0, #0
 1372 01e8 0100A003 		moveq	r0, #1
 1373              	.LVL119:
 1374              	.L135:
 470:layer1/prim_tch.c **** 	}
 471:layer1/prim_tch.c **** 
 472:layer1/prim_tch.c **** 	if (traffic_tx_now) {
 1375              		.loc 5 472 0
 1376 01ec 000050E3 		cmp	r0, #0
 1377 01f0 AA00000A 		beq	.L136
 1378              	.LBB17:
 473:layer1/prim_tch.c **** 		volatile uint16_t *traffic_buf;
 474:layer1/prim_tch.c **** 		struct msgb *msg;
 475:layer1/prim_tch.c **** 		const uint8_t *data;
 476:layer1/prim_tch.c **** 
 477:layer1/prim_tch.c **** 		/* Reset play mode */
 478:layer1/prim_tch.c **** 		dsp_api.ndb->d_tch_mode &= ~B_PLAY_UL;
 1379              		.loc 5 478 0
 1380 01f4 68319FE5 		ldr	r3, .L148+12
 1381 01f8 000093E5 		ldr	r0, [r3, #0]
 1382              	.LVL120:
 1383 01fc B630D0E1 		ldrh	r3, [r0, #6]
 1384 0200 0830C3E3 		bic	r3, r3, #8
 1385 0204 B630C0E1 		strh	r3, [r0, #6]	@ movhi
 479:layer1/prim_tch.c **** 
 480:layer1/prim_tch.c **** 		/* Check l1s audio mode */
 481:layer1/prim_tch.c **** 		if (!(l1s.audio_mode & AUDIO_TX_TRAFFIC_REQ))
 1386              		.loc 5 481 0
 1387 0208 4C319FE5 		ldr	r3, .L148+4
 1388 020c 4C3AD3E5 		ldrb	r3, [r3, #2636]	@ zero_extendqisi2
 1389 0210 020013E3 		tst	r3, #2
 1390 0214 AA00000A 		beq	.L136
 482:layer1/prim_tch.c **** 			goto skip_tx_traffic;
 483:layer1/prim_tch.c **** 
 484:layer1/prim_tch.c **** 		/* Traffic buffer = !tch_sub */
 485:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_du_0 : dsp_api.ndb->a_du_1;
 1391              		.loc 5 485 0
 1392 0218 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1393 021c 000053E3 		cmp	r3, #0
 1394 0220 2A4E8012 		addne	r4, r0, #672
 1395              	.LVL121:
 1396 0224 4D4F8002 		addeq	r4, r0, #308
 486:layer1/prim_tch.c **** 
 487:layer1/prim_tch.c **** 		/* Pull Traffic data (if any) */
 488:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 1397              		.loc 5 488 0
 1398 0228 44019FE5 		ldr	r0, .L148+28
 1399 022c FEFFFFEB 		bl	msgb_dequeue
 489:layer1/prim_tch.c **** 
 490:layer1/prim_tch.c **** 		/**
 491:layer1/prim_tch.c **** 		 * Perform some bit conversations
 492:layer1/prim_tch.c **** 		 * FIXME: what about other (than FR) codecs?
 493:layer1/prim_tch.c **** 		 */
 494:layer1/prim_tch.c **** 		if (msg)
 1400              		.loc 5 494 0
 1401 0230 005050E2 		subs	r5, r0, #0
 1402              	.LVL122:
 1403 0234 AA00000A 		beq	.L136
 495:layer1/prim_tch.c **** 			tch_fr_bit_magic(msg->l2h, 0);
 1404              		.loc 5 495 0
 1405 0238 140095E5 		ldr	r0, [r5, #20]
 1406 023c 0010A0E3 		mov	r1, #0
 1407 0240 FEFFFFEB 		bl	tch_fr_bit_magic
 496:layer1/prim_tch.c **** 
 497:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 498:layer1/prim_tch.c **** 		if (msg) {
 499:layer1/prim_tch.c **** 			data = msg->l2h;
 500:layer1/prim_tch.c **** 			dsp_memcpy_to_api(&traffic_buf[3], data, 33, 1);
 1408              		.loc 5 500 0
 1409 0244 060084E2 		add	r0, r4, #6
 1410 0248 141095E5 		ldr	r1, [r5, #20]
 1411 024c 2120A0E3 		mov	r2, #33
 1412 0250 0130A0E3 		mov	r3, #1
 1413 0254 FEFFFFEB 		bl	dsp_memcpy_to_api
 501:layer1/prim_tch.c **** 
 502:layer1/prim_tch.c **** 			traffic_buf[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1414              		.loc 5 502 0
 1415 0258 0239A0E3 		mov	r3, #32768
 1416 025c B030C4E1 		strh	r3, [r4, #0]	@ movhi
 503:layer1/prim_tch.c **** 			traffic_buf[1] = 0;		/* 2nd word: cleared. */
 504:layer1/prim_tch.c **** 			traffic_buf[2] = 0;		/* 3nd word: cleared. */
 505:layer1/prim_tch.c **** 		}
 506:layer1/prim_tch.c **** 
 507:layer1/prim_tch.c **** 		if (msg)
 508:layer1/prim_tch.c **** 			dsp_api.ndb->d_tch_mode |= B_PLAY_UL;
 1417              		.loc 5 508 0
 1418 0260 FC309FE5 		ldr	r3, .L148+12
 1419 0264 001093E5 		ldr	r1, [r3, #0]
 1420              		.loc 5 503 0
 1421 0268 0030A0E3 		mov	r3, #0	@ movhi
 1422 026c B230C4E1 		strh	r3, [r4, #2]	@ movhi
 1423              		.loc 5 504 0
 1424 0270 B430C4E1 		strh	r3, [r4, #4]	@ movhi
 1425              		.loc 5 508 0
 1426 0274 B630D1E1 		ldrh	r3, [r1, #6]
 509:layer1/prim_tch.c **** 
 510:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 511:layer1/prim_tch.c **** 		if (msg) {
 512:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 513:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_TRAFFIC;
 1427              		.loc 5 513 0
 1428 0278 ECC09FE5 		ldr	ip, .L148+20
 1429              		.loc 5 508 0
 1430 027c 083083E3 		orr	r3, r3, #8
 1431              		.loc 5 513 0
 1432 0280 B020DCE1 		ldrh	r2, [ip, #0]
 1433              		.loc 5 508 0
 1434 0284 B630C1E1 		strh	r3, [r1, #6]	@ movhi
 1435              		.loc 5 512 0
 1436 0288 CC109FE5 		ldr	r1, .L148+4
 1437 028c DC309FE5 		ldr	r3, .L148+24
 1438 0290 BC10D1E1 		ldrh	r1, [r1, #12]
 1439              		.loc 5 513 0
 1440 0294 042082E3 		orr	r2, r2, #4
 514:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1441              		.loc 5 514 0
 1442 0298 0300A0E3 		mov	r0, #3
 1443              		.loc 5 512 0
 1444 029c B010C3E1 		strh	r1, [r3, #0]	@ movhi
 1445              		.loc 5 513 0
 1446 02a0 B020CCE1 		strh	r2, [ip, #0]	@ movhi
 1447              		.loc 5 514 0
 1448 02a4 FEFFFFEB 		bl	l1s_compl_sched
 515:layer1/prim_tch.c **** 		}
 516:layer1/prim_tch.c **** 
 517:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 518:layer1/prim_tch.c **** 		if (msg)
 519:layer1/prim_tch.c **** 			msgb_free(msg);
 1449              		.loc 5 519 0
 1450 02a8 0500A0E1 		mov	r0, r5
 1451 02ac FEFFFFEB 		bl	msgb_free
 1452              	.LVL123:
 1453              	.L136:
 1454              	.LVL124:
 1455              	.LBE17:
 520:layer1/prim_tch.c **** 	}
 521:layer1/prim_tch.c **** skip_tx_traffic:
 522:layer1/prim_tch.c **** 
 523:layer1/prim_tch.c **** 	/* Configure DSP for TX/RX */
 524:layer1/prim_tch.c **** 	l1s_tx_apc_helper(arfcn);
 1456              		.loc 5 524 0
 1457 02b0 B001DDE1 		ldrh	r0, [sp, #16]
 1458              	.LVL125:
 1459 02b4 FEFFFFEB 		bl	l1s_tx_apc_helper
 525:layer1/prim_tch.c **** 
 526:layer1/prim_tch.c **** 	dsp_load_tch_param(
 1460              		.loc 5 526 0
 1461 02b8 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 1462 02bc 98009FE5 		ldr	r0, .L148+4
 1463 02c0 000052E3 		cmp	r2, #0
 1464 02c4 50CAD0E5 		ldrb	ip, [r0, #2640]	@ zero_extendqisi2
 1465 02c8 16E0DDE5 		ldrb	lr, [sp, #22]	@ zero_extendqisi2
 1466 02cc 0220A003 		moveq	r2, #2
 1467 02d0 0120A013 		movne	r2, #1
 1468 02d4 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1469 02d8 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 1470 02dc 0C0080E2 		add	r0, r0, #12
 1471 02e0 00C08DE5 		str	ip, [sp, #0]
 1472 02e4 40408DE9 		stmib	sp, {r6, lr}	@ phole stm
 1473 02e8 FEFFFFEB 		bl	dsp_load_tch_param
 527:layer1/prim_tch.c **** 		&l1s.next_time,
 528:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 529:layer1/prim_tch.c **** 		l1s.tch_loop_mode, sync, tn
 530:layer1/prim_tch.c **** 	);
 531:layer1/prim_tch.c **** 
 532:layer1/prim_tch.c **** 	dsp_load_rx_task(
 1474              		.loc 5 532 0
 1475 02ec B011DDE1 		ldrh	r1, [sp, #16]
 1476 02f0 0020A0E3 		mov	r2, #0
 1477 02f4 0D00A0E3 		mov	r0, #13
 1478 02f8 FEFFFFEB 		bl	dsp_task_iq_swap
 1479              	.LVL126:
 1480 02fc 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1481 0300 0010A0E3 		mov	r1, #0
 1482 0304 FEFFFFEB 		bl	dsp_load_rx_task
 533:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHT_DSP_TASK, arfcn, 0),
 534:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCH */
 535:layer1/prim_tch.c **** 	);
 536:layer1/prim_tch.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 1483              		.loc 5 536 0
 1484 0308 B001DDE1 		ldrh	r0, [sp, #16]
 1485 030c 0310A0E3 		mov	r1, #3
 1486 0310 0020A0E3 		mov	r2, #0
 1487 0314 FEFFFFEB 		bl	l1s_rx_win_ctrl
 537:layer1/prim_tch.c **** 
 538:layer1/prim_tch.c **** 	dsp_load_tx_task(
 1488              		.loc 5 538 0
 1489 0318 B011DDE1 		ldrh	r1, [sp, #16]
 1490 031c 0120A0E3 		mov	r2, #1
 1491 0320 0D00A0E3 		mov	r0, #13
 1492 0324 FEFFFFEB 		bl	dsp_task_iq_swap
 1493 0328 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1494 032c 0010A0E3 		mov	r1, #0
 1495 0330 FEFFFFEB 		bl	dsp_load_tx_task
 539:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHT_DSP_TASK, arfcn, 1),
 540:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCH */
 541:layer1/prim_tch.c **** 	);
 542:layer1/prim_tch.c **** 	l1s_tx_win_ctrl(arfcn | ARFCN_UPLINK, L1_TXWIN_NB, 0, 3);
 1496              		.loc 5 542 0
 1497 0334 B001DDE1 		ldrh	r0, [sp, #16]
 1498 0338 0010A0E3 		mov	r1, #0
 1499 033c 010980E3 		orr	r0, r0, #16384
 1500 0340 0120A0E1 		mov	r2, r1
 1501 0344 0330A0E3 		mov	r3, #3
 1502 0348 FEFFFFEB 		bl	l1s_tx_win_ctrl
 543:layer1/prim_tch.c **** 
 544:layer1/prim_tch.c **** 	return 0;
 545:layer1/prim_tch.c **** }
 1503              		.loc 5 545 0
 1504 034c 0000A0E3 		mov	r0, #0
 1505 0350 18D08DE2 		add	sp, sp, #24
 1506 0354 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1507              	.L149:
 1508              		.align	2
 1509              	.L148:
 1510 0358 0C000000 		.word	l1s+12
 1511 035c 00000000 		.word	l1s
 1512 0360 04000000 		.word	icnt.4642
 1513 0364 00000000 		.word	dsp_api
 1514 0368 540A0000 		.word	l1s+2644
 1515 036c 74000000 		.word	last_tx_tch_type
 1516 0370 76000000 		.word	last_tx_tch_fn
 1517 0374 640A0000 		.word	l1s+2660
 1518              	.LFE74:
 1520              		.section	.text.l1s_tch_d_resp,"ax",%progbits
 1521              		.align	2
 1523              	l1s_tch_d_resp:
 1524              	.LFB75:
 546:layer1/prim_tch.c **** 
 547:layer1/prim_tch.c **** 
 548:layer1/prim_tch.c **** const struct tdma_sched_item tch_sched_set[] = {
 549:layer1/prim_tch.c **** 	SCHED_ITEM_DT(l1s_tch_cmd, 0, 0, 0),	SCHED_END_FRAME(),
 550:layer1/prim_tch.c **** 						SCHED_END_FRAME(),
 551:layer1/prim_tch.c **** 	SCHED_ITEM(l1s_tch_resp, 0, 0, -4),	SCHED_END_FRAME(),
 552:layer1/prim_tch.c **** 	SCHED_END_SET()
 553:layer1/prim_tch.c **** };
 554:layer1/prim_tch.c **** 
 555:layer1/prim_tch.c **** 
 556:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 557:layer1/prim_tch.c ****  * TCH/H: Dummy
 558:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 559:layer1/prim_tch.c **** 
 560:layer1/prim_tch.c **** /* This task is needed to perform some operation in the DSP when there is
 561:layer1/prim_tch.c ****  * no data to be exchanged */
 562:layer1/prim_tch.c **** 
 563:layer1/prim_tch.c **** static int l1s_tch_d_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 564:layer1/prim_tch.c **** {
 1525              		.loc 5 564 0
 1526              		@ args = 0, pretend = 0, frame = 0
 1527              		@ frame_needed = 0, uses_anonymous_args = 0
 1528              		@ link register save eliminated.
 1529              	.LVL127:
 565:layer1/prim_tch.c **** 	/* mark READ page as being used */
 566:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 1530              		.loc 5 566 0
 1531 0000 0C309FE5 		ldr	r3, .L152
 1532 0004 0120A0E3 		mov	r2, #1
 1533              	.LVL128:
 567:layer1/prim_tch.c **** 
 568:layer1/prim_tch.c **** 	return 0;
 569:layer1/prim_tch.c **** }
 1534              		.loc 5 569 0
 1535 0008 0000A0E3 		mov	r0, #0
 1536              	.LVL129:
 1537              		.loc 5 564 0
 1538              		@ lr needed for prologue
 1539              		.loc 5 566 0
 1540 000c 182083E5 		str	r2, [r3, #24]
 1541              		.loc 5 569 0
 1542 0010 1EFF2FE1 		bx	lr
 1543              	.L153:
 1544              		.align	2
 1545              	.L152:
 1546 0014 00000000 		.word	dsp_api
 1547              	.LFE75:
 1549              		.section	.text.l1s_tch_d_cmd,"ax",%progbits
 1550              		.align	2
 1552              	l1s_tch_d_cmd:
 1553              	.LFB76:
 570:layer1/prim_tch.c **** 
 571:layer1/prim_tch.c **** static int l1s_tch_d_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 572:layer1/prim_tch.c **** {
 1554              		.loc 5 572 0
 1555              		@ args = 0, pretend = 0, frame = 12
 1556              		@ frame_needed = 0, uses_anonymous_args = 0
 1557              	.LVL130:
 1558 0000 10402DE9 		stmfd	sp!, {r4, lr}
 1559              	.LCFI10:
 1560 0004 0248A0E1 		mov	r4, r2, asl #16
 1561 0008 18D04DE2 		sub	sp, sp, #24
 1562              	.LCFI11:
 1563              	.LVL131:
 1564              		.loc 5 572 0
 1565 000c 2448A0E1 		mov	r4, r4, lsr #16
 573:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 574:layer1/prim_tch.c **** 	uint8_t chan_nr;
 575:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 576:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 577:layer1/prim_tch.c **** 	uint32_t fn_report;
 578:layer1/prim_tch.c **** 
 579:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 580:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, NULL, &tsc, &tn);
 1566              		.loc 5 580 0
 1567 0010 17208DE2 		add	r2, sp, #23
 1568              	.LVL132:
 1569 0014 16308DE2 		add	r3, sp, #22
 1570 0018 9C009FE5 		ldr	r0, .L159
 1571              	.LVL133:
 1572 001c 0010A0E3 		mov	r1, #0
 1573              	.LVL134:
 581:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1574              		.loc 5 581 0
 1575 0020 FF4004E2 		and	r4, r4, #255
 1576              	.LVL135:
 1577              		.loc 5 580 0
 1578 0024 FEFFFFEB 		bl	rfch_get_params
 1579              	.LVL136:
 1580              		.loc 5 581 0
 1581 0028 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 1582 002c 0400A0E1 		mov	r0, r4
 1583 0030 FEFFFFEB 		bl	mframe_task2chan_nr
 582:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1584              		.loc 5 582 0
 1585 0034 14C08DE2 		add	ip, sp, #20
 1586              		.loc 5 581 0
 1587 0038 0010A0E1 		mov	r1, r0
 1588              		.loc 5 582 0
 1589 003c 0C208DE2 		add	r2, sp, #12
 1590 0040 15308DE2 		add	r3, sp, #21
 1591 0044 00C08DE5 		str	ip, [sp, #0]
 1592 0048 6C009FE5 		ldr	r0, .L159
 1593 004c 13C08DE2 		add	ip, sp, #19
 1594 0050 04C08DE5 		str	ip, [sp, #4]
 1595 0054 FEFFFFEB 		bl	tch_get_params
 1596              	.LVL137:
 583:layer1/prim_tch.c **** 
 584:layer1/prim_tch.c **** 	/* Configure DSP */
 585:layer1/prim_tch.c **** 	dsp_load_tch_param(
 1597              		.loc 5 585 0
 1598 0058 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 1599 005c 5C009FE5 		ldr	r0, .L159+4
 1600 0060 000052E3 		cmp	r2, #0
 1601 0064 50CAD0E5 		ldrb	ip, [r0, #2640]	@ zero_extendqisi2
 1602 0068 16E0DDE5 		ldrb	lr, [sp, #22]	@ zero_extendqisi2
 1603 006c 0220A003 		moveq	r2, #2
 1604 0070 0120A013 		movne	r2, #1
 1605 0074 0040A0E3 		mov	r4, #0
 1606              	.LVL138:
 1607 0078 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1608              	.LVL139:
 1609 007c 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 1610 0080 0C0080E2 		add	r0, r0, #12
 1611 0084 00C08DE5 		str	ip, [sp, #0]
 1612 0088 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1613 008c FEFFFFEB 		bl	dsp_load_tch_param
 586:layer1/prim_tch.c **** 		&l1s.next_time,
 587:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 588:layer1/prim_tch.c **** 		l1s.tch_loop_mode, 0, tn
 589:layer1/prim_tch.c **** 	);
 590:layer1/prim_tch.c **** 
 591:layer1/prim_tch.c **** 	dsp_load_rx_task(TCHD_DSP_TASK, 0, tsc); /* burst_id unused for TCH */
 1614              		.loc 5 591 0
 1615 0090 0410A0E1 		mov	r1, r4
 1616              	.LVL140:
 1617 0094 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1618 0098 1C00A0E3 		mov	r0, #28
 1619 009c FEFFFFEB 		bl	dsp_load_rx_task
 592:layer1/prim_tch.c **** 	dsp_load_tx_task(TCHD_DSP_TASK, 0, tsc); /* burst_id unused for TCH */
 1620              		.loc 5 592 0
 1621 00a0 1C00A0E3 		mov	r0, #28
 1622 00a4 0410A0E1 		mov	r1, r4
 1623 00a8 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1624 00ac FEFFFFEB 		bl	dsp_load_tx_task
 593:layer1/prim_tch.c **** 
 594:layer1/prim_tch.c **** 	return 0;
 595:layer1/prim_tch.c **** }
 1625              		.loc 5 595 0
 1626 00b0 0400A0E1 		mov	r0, r4
 1627 00b4 18D08DE2 		add	sp, sp, #24
 1628 00b8 1080BDE8 		ldmfd	sp!, {r4, pc}
 1629              	.L160:
 1630              		.align	2
 1631              	.L159:
 1632 00bc 0C000000 		.word	l1s+12
 1633 00c0 00000000 		.word	l1s
 1634              	.LFE76:
 1636              		.section	.text.l1s_tch_a_resp,"ax",%progbits
 1637              		.align	2
 1639              	l1s_tch_a_resp:
 1640              	.LFB77:
 596:layer1/prim_tch.c **** 
 597:layer1/prim_tch.c **** const struct tdma_sched_item tch_d_sched_set[] = {
 598:layer1/prim_tch.c **** 	SCHED_ITEM_DT(l1s_tch_d_cmd, 0, 0, 0),	SCHED_END_FRAME(),
 599:layer1/prim_tch.c **** 						SCHED_END_FRAME(),
 600:layer1/prim_tch.c **** 	SCHED_ITEM(l1s_tch_d_resp, 0, 0, -4),	SCHED_END_FRAME(),
 601:layer1/prim_tch.c **** 	SCHED_END_SET()
 602:layer1/prim_tch.c **** };
 603:layer1/prim_tch.c **** 
 604:layer1/prim_tch.c **** 
 605:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 606:layer1/prim_tch.c ****  * TCH: SACCH
 607:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 608:layer1/prim_tch.c **** 
 609:layer1/prim_tch.c **** /*
 610:layer1/prim_tch.c ****  * SACCH data are spread over 4 bursts, however they are so far apart that
 611:layer1/prim_tch.c ****  * we can't use the normal scheduler to schedule all them at once in a single
 612:layer1/prim_tch.c ****  * set.
 613:layer1/prim_tch.c ****  * Therefore, the task code itself decides in which burst it is, if it's the
 614:layer1/prim_tch.c ****  * start/end, and act appropriately.
 615:layer1/prim_tch.c ****  */
 616:layer1/prim_tch.c **** 
 617:layer1/prim_tch.c **** 
 618:layer1/prim_tch.c **** struct l1s_rx_tch_a_state {
 619:layer1/prim_tch.c **** 	struct l1s_meas_hdr meas[4];
 620:layer1/prim_tch.c **** 
 621:layer1/prim_tch.c **** 	struct msgb *msg;
 622:layer1/prim_tch.c **** 	struct l1ctl_info_dl *dl;
 623:layer1/prim_tch.c **** 	struct l1ctl_data_ind *di;
 624:layer1/prim_tch.c **** };
 625:layer1/prim_tch.c **** 
 626:layer1/prim_tch.c **** static struct l1s_rx_tch_a_state rx_tch_a;
 627:layer1/prim_tch.c **** 
 628:layer1/prim_tch.c **** 
 629:layer1/prim_tch.c **** static int l1s_tch_a_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 630:layer1/prim_tch.c **** {
 1641              		.loc 5 630 0
 1642              		@ args = 0, pretend = 0, frame = 24
 1643              		@ frame_needed = 0, uses_anonymous_args = 0
 1644              	.LVL141:
 1645 0000 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 1646              	.LCFI12:
 631:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 632:layer1/prim_tch.c **** 	struct gsm_time rx_time;
 633:layer1/prim_tch.c **** 	uint8_t chan_nr;
 634:layer1/prim_tch.c **** 	uint16_t arfcn;
 635:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 636:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub;
 637:layer1/prim_tch.c **** 	uint32_t fn_report;
 638:layer1/prim_tch.c **** 	uint8_t burst_id;
 639:layer1/prim_tch.c **** 
 640:layer1/prim_tch.c **** 	/* It may happen we've never gone through cmd(0) yet, skip until then */
 641:layer1/prim_tch.c **** 	if (!rx_tch_a.msg)
 1647              		.loc 5 641 0
 1648 0004 80829FE5 		ldr	r8, .L178
 1649 0008 203098E5 		ldr	r3, [r8, #32]
 1650              		.loc 5 630 0
 1651 000c 0228A0E1 		mov	r2, r2, asl #16
 1652              	.LVL142:
 1653 0010 2228A0E1 		mov	r2, r2, lsr #16
 1654              	.LVL143:
 1655              		.loc 5 641 0
 1656 0014 000053E3 		cmp	r3, #0
 1657              		.loc 5 630 0
 1658 0018 20D04DE2 		sub	sp, sp, #32
 1659              	.LCFI13:
 1660              	.LVL144:
 1661              		.loc 5 631 0
 1662 001c FF5002E2 		and	r5, r2, #255
 1663              	.LVL145:
 1664              		.loc 5 641 0
 1665 0020 9B00000A 		beq	.L162
 642:layer1/prim_tch.c **** 		goto skip;
 643:layer1/prim_tch.c **** 
 644:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 645:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 1666              		.loc 5 645 0
 1667 0024 64329FE5 		ldr	r3, .L178+4
 1668 0028 64029FE5 		ldr	r0, .L178+8
 1669              	.LVL146:
 1670 002c 003093E5 		ldr	r3, [r3, #0]
 1671 0030 60129FE5 		ldr	r1, .L178+12
 1672              	.LVL147:
 1673 0034 000083E0 		add	r0, r3, r0
 1674 0038 FEFFFFEB 		bl	__umodsi3
 1675              	.LVL148:
 1676 003c 08408DE2 		add	r4, sp, #8
 1677 0040 0010A0E1 		mov	r1, r0
 1678 0044 0400A0E1 		mov	r0, r4
 1679 0048 FEFFFFEB 		bl	gsm_fn2gsmtime
 646:layer1/prim_tch.c **** 	rfch_get_params(&rx_time, &arfcn, &tsc, &tn);
 1680              		.loc 5 646 0
 1681 004c 0400A0E1 		mov	r0, r4
 1682 0050 1F208DE2 		add	r2, sp, #31
 1683 0054 1E308DE2 		add	r3, sp, #30
 1684 0058 1A108DE2 		add	r1, sp, #26
 1685 005c FEFFFFEB 		bl	rfch_get_params
 647:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1686              		.loc 5 647 0
 1687 0060 0500A0E1 		mov	r0, r5
 1688              	.LVL149:
 1689 0064 1E10DDE5 		ldrb	r1, [sp, #30]	@ zero_extendqisi2
 1690 0068 FEFFFFEB 		bl	mframe_task2chan_nr
 648:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 1691              		.loc 5 648 0
 1692 006c 00A0A0E3 		mov	sl, #0
 1693 0070 1CC08DE2 		add	ip, sp, #28
 1694 0074 14208DE2 		add	r2, sp, #20
 1695              		.loc 5 647 0
 1696 0078 0010A0E1 		mov	r1, r0
 1697              		.loc 5 648 0
 1698 007c 1D308DE2 		add	r3, sp, #29
 1699 0080 0400A0E1 		mov	r0, r4
 1700 0084 00C08DE5 		str	ip, [sp, #0]
 1701 0088 04A08DE5 		str	sl, [sp, #4]
 1702 008c FEFFFFEB 		bl	tch_get_params
 1703              	.LVL150:
 649:layer1/prim_tch.c **** 	burst_id = (fn_report - 12) / 26;
 1704              		.loc 5 649 0
 1705 0090 14009DE5 		ldr	r0, [sp, #20]
 1706 0094 1A10A0E3 		mov	r1, #26
 1707 0098 0C0040E2 		sub	r0, r0, #12
 1708 009c FEFFFFEB 		bl	__udivsi3
 650:layer1/prim_tch.c **** 
 651:layer1/prim_tch.c **** 	/* Collect measurements */
 652:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 1709              		.loc 5 652 0
 1710 00a0 F4519FE5 		ldr	r5, .L178+16
 1711              	.LVL151:
 1712 00a4 043095E5 		ldr	r3, [r5, #4]
 1713              		.loc 5 649 0
 1714 00a8 FF7000E2 		and	r7, r0, #255
 1715              	.LVL152:
 1716              		.loc 5 652 0
 1717 00ac B011D3E1 		ldrh	r1, [r3, #16]
 1718 00b0 8761A0E1 		mov	r6, r7, asl #3
 1719 00b4 084086E0 		add	r4, r6, r8
 1720 00b8 B210C4E1 		strh	r1, [r4, #2]	@ movhi
 653:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].pm_dbm8 =
 1721              		.loc 5 653 0
 1722 00bc B201D3E1 		ldrh	r0, [r3, #18]
 1723 00c0 A001A0E1 		mov	r0, r0, lsr #3
 1724 00c4 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 654:layer1/prim_tch.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
 655:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].freq_err =
 1725              		.loc 5 655 0
 1726 00c8 041095E5 		ldr	r1, [r5, #4]
 1727              		.loc 5 653 0
 1728 00cc B400C4E1 		strh	r0, [r4, #4]	@ movhi
 1729              		.loc 5 655 0
 1730 00d0 C8319FE5 		ldr	r3, .L178+20
 1731 00d4 F421D1E1 		ldrsh	r2, [r1, #20]
 1732 00d8 920303E0 		mul	r3, r2, r3
 1733 00dc FF2C83E2 		add	r2, r3, #65280
 1734 00e0 FF2082E2 		add	r2, r2, #255
 1735 00e4 0A0053E1 		cmp	r3, sl
 1736 00e8 0230A0B1 		movlt	r3, r2
 1737              		.loc 5 653 0
 1738 00ec 044084E2 		add	r4, r4, #4
 1739              		.loc 5 655 0
 1740 00f0 4338A0E1 		mov	r3, r3, asr #16
 1741 00f4 B230C4E1 		strh	r3, [r4, #2]	@ movhi
 656:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 657:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 1742              		.loc 5 657 0
 1743 00f8 B631D1E1 		ldrh	r3, [r1, #22]
 1744 00fc B200D4E1 		ldrh	r0, [r4, #2]
 658:layer1/prim_tch.c **** 
 659:layer1/prim_tch.c **** 	/* feed computed frequency error into AFC loop */
 660:layer1/prim_tch.c **** 	if (rx_tch_a.meas[burst_id].snr > AFC_SNR_THRESHOLD)
 1745              		.loc 5 660 0
 1746 0100 0A0C53E3 		cmp	r3, #2560
 661:layer1/prim_tch.c **** 		afc_input(rx_tch_a.meas[burst_id].freq_err, arfcn, 1);
 1747              		.loc 5 661 0
 1748 0104 0008A081 		movhi	r0, r0, asl #16
 662:layer1/prim_tch.c **** 	else
 663:layer1/prim_tch.c **** 		afc_input(rx_tch_a.meas[burst_id].freq_err, arfcn, 0);
 1749              		.loc 5 663 0
 1750 0108 0008A091 		movls	r0, r0, asl #16
 1751              		.loc 5 661 0
 1752 010c 4008A081 		movhi	r0, r0, asr #16
 1753 0110 0120A083 		movhi	r2, #1
 1754              		.loc 5 663 0
 1755 0114 4008A091 		movls	r0, r0, asr #16
 1756 0118 0A20A091 		movls	r2, sl
 1757              	.LVL153:
 1758 011c BA11DDE1 		ldrh	r1, [sp, #26]
 664:layer1/prim_tch.c **** 
 665:layer1/prim_tch.c **** 	/* feed computed TOA into TA loop */
 666:layer1/prim_tch.c **** 	toa_input(rx_tch_a.meas[burst_id].toa_qbit << 2, rx_tch_a.meas[burst_id].snr);
 1759              		.loc 5 666 0
 1760 0120 64519FE5 		ldr	r5, .L178
 1761              		.loc 5 657 0
 1762 0124 B83086E1 		strh	r3, [r6, r8]	@ movhi
 1763              		.loc 5 663 0
 1764 0128 FEFFFFEB 		bl	afc_input
 1765              		.loc 5 666 0
 1766 012c 8731A0E1 		mov	r3, r7, asl #3
 1767 0130 054083E0 		add	r4, r3, r5
 1768 0134 F200D4E1 		ldrsh	r0, [r4, #2]
 1769 0138 B51093E1 		ldrh	r1, [r3, r5]
 1770 013c 0001A0E1 		mov	r0, r0, asl #2
 1771 0140 FEFFFFEB 		bl	toa_input
 667:layer1/prim_tch.c **** 
 668:layer1/prim_tch.c **** 	/* Tell the RF frontend to set the gain appropriately */
 669:layer1/prim_tch.c **** 	rffe_compute_gain(rx_tch_a.meas[burst_id].pm_dbm8 / 8,
 1772              		.loc 5 669 0
 1773 0144 F400D4E1 		ldrsh	r0, [r4, #4]
 1774 0148 000050E3 		cmp	r0, #0
 1775 014c 073080E2 		add	r3, r0, #7
 1776 0150 0300A0B1 		movlt	r0, r3
 1777 0154 C001A0E1 		mov	r0, r0, asr #3
 1778 0158 5010A0E3 		mov	r1, #80
 1779 015c FEFFFFEB 		bl	rffe_compute_gain
 670:layer1/prim_tch.c **** 		CAL_DSP_TGT_BB_LVL);
 671:layer1/prim_tch.c **** 
 672:layer1/prim_tch.c **** 	/* Last burst, read data & send to the up layer */
 673:layer1/prim_tch.c **** 	if ((burst_id == 3) && (dsp_api.ndb->a_cd[0] & (1<<B_BLUD))) {
 1780              		.loc 5 673 0
 1781 0160 030057E3 		cmp	r7, #3
 1782 0164 9B00001A 		bne	.L162
 1783 0168 2C319FE5 		ldr	r3, .L178+16
 1784 016c 002093E5 		ldr	r2, [r3, #0]
 1785 0170 7F3FA0E3 		mov	r3, #508
 1786 0174 F33092E1 		ldrsh	r3, [r2, r3]
 1787 0178 000053E3 		cmp	r3, #0
 1788 017c 9B0000AA 		bge	.L162
 1789 0180 00C0A0E3 		mov	ip, #0
 1790              	.LVL154:
 1791 0184 0500A0E1 		mov	r0, r5
 1792 0188 0CE0A0E1 		mov	lr, ip
 1793              	.LVL155:
 1794              	.L169:
 1795              	.LBB18:
 674:layer1/prim_tch.c **** 		unsigned int i;
 675:layer1/prim_tch.c **** 		uint16_t num_biterr;
 676:layer1/prim_tch.c **** 		uint32_t avg_snr = 0;
 677:layer1/prim_tch.c **** 		int32_t avg_dbm8 = 0;
 678:layer1/prim_tch.c **** 
 679:layer1/prim_tch.c **** 		/* Average SNR & RX level + error & crc status */
 680:layer1/prim_tch.c **** 		for (i=0; i<4; i++) {
 1796              		.loc 5 680 0
 1797 018c 10219FE5 		ldr	r2, .L178+24
 681:layer1/prim_tch.c **** 			avg_snr += rx_tch_a.meas[i].snr;
 1798              		.loc 5 681 0
 1799 0190 B030D0E1 		ldrh	r3, [r0, #0]
 682:layer1/prim_tch.c **** 			avg_dbm8 += rx_tch_a.meas[i].pm_dbm8;
 1800              		.loc 5 682 0
 1801 0194 F410D0E1 		ldrsh	r1, [r0, #4]
 1802 0198 080080E2 		add	r0, r0, #8
 1803              		.loc 5 680 0
 1804 019c 020050E1 		cmp	r0, r2
 1805              		.loc 5 681 0
 1806 01a0 03E08EE0 		add	lr, lr, r3
 1807              		.loc 5 682 0
 1808 01a4 01C08CE0 		add	ip, ip, r1
 1809              		.loc 5 680 0
 1810 01a8 6100001A 		bne	.L169
 683:layer1/prim_tch.c **** 		}
 684:layer1/prim_tch.c **** 		rx_tch_a.dl->snr = avg_snr / 4;
 1811              		.loc 5 684 0
 1812 01ac D8509FE5 		ldr	r5, .L178
 1813 01b0 242095E5 		ldr	r2, [r5, #36]
 1814 01b4 2E31A0E1 		mov	r3, lr, lsr #2
 685:layer1/prim_tch.c **** 		rx_tch_a.dl->rx_level = dbm2rxlev(avg_dbm8 / (8*4));
 1815              		.loc 5 685 0
 1816 01b8 00005CE3 		cmp	ip, #0
 1817 01bc 1F008CE2 		add	r0, ip, #31
 1818              		.loc 5 684 0
 1819 01c0 0930C2E5 		strb	r3, [r2, #9]
 1820              		.loc 5 685 0
 1821 01c4 0C00A0A1 		movge	r0, ip
 1822 01c8 C002A0E1 		mov	r0, r0, asr #5
 1823 01cc 244095E5 		ldr	r4, [r5, #36]
 1824 01d0 FEFFFFEB 		bl	dbm2rxlev
 1825              	.LVL156:
 686:layer1/prim_tch.c **** 
 687:layer1/prim_tch.c **** 		num_biterr = dsp_api.ndb->a_cd[2];
 1826              		.loc 5 687 0
 1827 01d4 C0309FE5 		ldr	r3, .L178+16
 1828              		.loc 5 685 0
 1829 01d8 0800C4E5 		strb	r0, [r4, #8]
 1830              		.loc 5 687 0
 1831 01dc 002093E5 		ldr	r2, [r3, #0]
 1832 01e0 023CA0E3 		mov	r3, #512
 1833 01e4 B33092E1 		ldrh	r3, [r2, r3]
 1834              	.LVL157:
 1835 01e8 242095E5 		ldr	r2, [r5, #36]
 688:layer1/prim_tch.c **** 		if (num_biterr > 0xff)
 1836              		.loc 5 688 0
 1837 01ec FF0053E3 		cmp	r3, #255
 689:layer1/prim_tch.c **** 			rx_tch_a.dl->num_biterr = 0xff;
 1838              		.loc 5 689 0
 1839 01f0 0030E083 		mvnhi	r3, #0
 1840              	.LVL158:
 1841              	.LVL159:
 690:layer1/prim_tch.c **** 		else
 691:layer1/prim_tch.c **** 			rx_tch_a.dl->num_biterr = num_biterr;
 1842              		.loc 5 691 0
 1843 01f4 0A30C2E5 		strb	r3, [r2, #10]
 692:layer1/prim_tch.c **** 
 693:layer1/prim_tch.c **** 		rx_tch_a.dl->fire_crc = ((dsp_api.ndb->a_cd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> 
 1844              		.loc 5 693 0
 1845 01f8 9C509FE5 		ldr	r5, .L178+16
 1846 01fc 003095E5 		ldr	r3, [r5, #0]
 1847              	.LVL160:
 1848 0200 7F6FA0E3 		mov	r6, #508
 1849 0204 80409FE5 		ldr	r4, .L178
 1850 0208 B63093E1 		ldrh	r3, [r3, r6]
 1851 020c 242094E5 		ldr	r2, [r4, #36]
 1852 0210 603003E2 		and	r3, r3, #96
 1853 0214 C332A0E1 		mov	r3, r3, asr #5
 1854 0218 0B30C2E5 		strb	r3, [r2, #11]
 694:layer1/prim_tch.c **** 
 695:layer1/prim_tch.c **** 		/* Update rx level for pm report */
 696:layer1/prim_tch.c **** 		pu_update_rx_level(rx_tch_a.dl->rx_level);
 1855              		.loc 5 696 0
 1856 021c 243094E5 		ldr	r3, [r4, #36]
 1857 0220 0800D3E5 		ldrb	r0, [r3, #8]	@ zero_extendqisi2
 1858 0224 FEFFFFEB 		bl	pu_update_rx_level
 697:layer1/prim_tch.c **** 
 698:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 699:layer1/prim_tch.c **** 		dsp_memcpy_from_api(rx_tch_a.di->data, &dsp_api.ndb->a_cd[3], 23, 0);
 1859              		.loc 5 699 0
 1860 0228 001095E5 		ldr	r1, [r5, #0]
 1861 022c 061081E0 		add	r1, r1, r6
 1862 0230 061081E2 		add	r1, r1, #6
 1863 0234 1720A0E3 		mov	r2, #23
 1864 0238 0030A0E3 		mov	r3, #0
 1865 023c 280094E5 		ldr	r0, [r4, #40]
 1866 0240 FEFFFFEB 		bl	dsp_memcpy_from_api
 700:layer1/prim_tch.c **** 
 701:layer1/prim_tch.c **** 		/* Give message to up layer */
 702:layer1/prim_tch.c **** 		l1_queue_for_l2(rx_tch_a.msg);
 1867              		.loc 5 702 0
 1868 0244 200094E5 		ldr	r0, [r4, #32]
 1869 0248 FEFFFFEB 		bl	l1_queue_for_l2
 703:layer1/prim_tch.c **** 		rx_tch_a.msg = NULL; rx_tch_a.dl = NULL; rx_tch_a.di = NULL;
 1870              		.loc 5 703 0
 1871 024c 0030A0E3 		mov	r3, #0
 704:layer1/prim_tch.c **** 
 705:layer1/prim_tch.c **** 		/* Reset header */
 706:layer1/prim_tch.c **** 		dsp_api.ndb->a_cd[0] = (1<<B_FIRE1);
 1872              		.loc 5 706 0
 1873 0250 002095E5 		ldr	r2, [r5, #0]
 1874              		.loc 5 703 0
 1875 0254 283084E5 		str	r3, [r4, #40]
 1876 0258 203084E5 		str	r3, [r4, #32]
 1877 025c 243084E5 		str	r3, [r4, #36]
 707:layer1/prim_tch.c **** 		dsp_api.ndb->a_cd[2] = 0xffff;
 1878              		.loc 5 707 0
 1879 0260 0010E0E3 		mvn	r1, #0	@ movhi
 1880 0264 023C83E2 		add	r3, r3, #512
 1881 0268 B31082E1 		strh	r1, [r2, r3]	@ movhi
 1882              		.loc 5 706 0
 1883 026c 4030A0E3 		mov	r3, #64	@ movhi
 1884 0270 B63082E1 		strh	r3, [r2, r6]	@ movhi
 1885              	.LVL161:
 1886              	.L162:
 1887              	.LBE18:
 708:layer1/prim_tch.c **** 	}
 709:layer1/prim_tch.c **** 
 710:layer1/prim_tch.c **** skip:
 711:layer1/prim_tch.c **** 	/* mark READ page as being used */
 712:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 1888              		.loc 5 712 0
 1889 0274 20309FE5 		ldr	r3, .L178+16
 1890 0278 0120A0E3 		mov	r2, #1
 1891              	.LVL162:
 713:layer1/prim_tch.c **** 
 714:layer1/prim_tch.c **** 	return 0;
 715:layer1/prim_tch.c **** }
 1892              		.loc 5 715 0
 1893 027c 0000A0E3 		mov	r0, #0
 1894              	.LVL163:
 1895              		.loc 5 712 0
 1896 0280 182083E5 		str	r2, [r3, #24]
 1897              		.loc 5 715 0
 1898 0284 20D08DE2 		add	sp, sp, #32
 1899 0288 F085BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, pc}
 1900              	.L179:
 1901              		.align	2
 1902              	.L178:
 1903 028c 08000000 		.word	rx_tch_a
 1904 0290 00000000 		.word	l1s
 1905 0294 FF6F2900 		.word	2715647
 1906 0298 00702900 		.word	2715648
 1907 029c 00000000 		.word	dsp_api
 1908 02a0 C0500100 		.word	86208
 1909 02a4 28000000 		.word	rx_tch_a+32
 1910              	.LFE77:
 1912              		.section	.rodata.str1.4
 1913 007d 000000   		.align	2
 1914              	.LC3:
 1915 0080 7463685F 		.ascii	"tch_a_cmd(0): unable to allocate msgb\000"
 1915      615F636D 
 1915      64283029 
 1915      3A20756E 
 1915      61626C65 
 1916 00a6 0000     		.section	.text.l1s_tch_a_cmd,"ax",%progbits
 1917              		.align	2
 1919              	l1s_tch_a_cmd:
 1920              	.LFB78:
 716:layer1/prim_tch.c **** 
 717:layer1/prim_tch.c **** static int l1s_tch_a_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 718:layer1/prim_tch.c **** {
 1921              		.loc 5 718 0
 1922              		@ args = 0, pretend = 0, frame = 12
 1923              		@ frame_needed = 0, uses_anonymous_args = 0
 1924              	.LVL164:
 1925 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1926              	.LCFI14:
 1927 0004 0248A0E1 		mov	r4, r2, asl #16
 1928 0008 18D04DE2 		sub	sp, sp, #24
 1929              	.LCFI15:
 1930              	.LVL165:
 1931              		.loc 5 718 0
 1932 000c 2448A0E1 		mov	r4, r4, lsr #16
 719:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 720:layer1/prim_tch.c **** 	uint8_t chan_nr;
 721:layer1/prim_tch.c **** 	uint16_t arfcn;
 722:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 723:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 724:layer1/prim_tch.c **** 	uint32_t fn_report;
 725:layer1/prim_tch.c **** 	uint8_t burst_id;
 726:layer1/prim_tch.c **** 
 727:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 728:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 1933              		.loc 5 728 0
 1934 0010 17208DE2 		add	r2, sp, #23
 1935              	.LVL166:
 1936 0014 16308DE2 		add	r3, sp, #22
 1937 0018 38029FE5 		ldr	r0, .L196
 1938              	.LVL167:
 1939 001c 10108DE2 		add	r1, sp, #16
 1940              	.LVL168:
 729:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1941              		.loc 5 729 0
 1942 0020 FF4004E2 		and	r4, r4, #255
 1943              	.LVL169:
 1944              		.loc 5 728 0
 1945 0024 FEFFFFEB 		bl	rfch_get_params
 1946              	.LVL170:
 1947              		.loc 5 729 0
 1948 0028 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 1949 002c 0400A0E1 		mov	r0, r4
 1950 0030 FEFFFFEB 		bl	mframe_task2chan_nr
 730:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1951              		.loc 5 730 0
 1952 0034 14C08DE2 		add	ip, sp, #20
 1953              	.LVL171:
 1954 0038 0010A0E1 		mov	r1, r0
 1955 003c 0C208DE2 		add	r2, sp, #12
 1956 0040 15308DE2 		add	r3, sp, #21
 1957 0044 00C08DE5 		str	ip, [sp, #0]
 1958              	.LVL172:
 1959              		.loc 5 729 0
 1960 0048 0060A0E1 		mov	r6, r0
 1961              		.loc 5 730 0
 1962 004c 13C08DE2 		add	ip, sp, #19
 1963 0050 00029FE5 		ldr	r0, .L196
 1964 0054 04C08DE5 		str	ip, [sp, #4]
 1965 0058 FEFFFFEB 		bl	tch_get_params
 1966              	.LVL173:
 1967              	.LVL174:
 731:layer1/prim_tch.c **** 	burst_id = (fn_report - 12) / 26;
 732:layer1/prim_tch.c **** 
 733:layer1/prim_tch.c **** 	/* Load SACCH data if we start a new burst */
 734:layer1/prim_tch.c **** 	if (burst_id == 0) {
 1968              		.loc 5 734 0
 1969 005c 0C009DE5 		ldr	r0, [sp, #12]
 1970 0060 1A10A0E3 		mov	r1, #26
 1971 0064 0C0040E2 		sub	r0, r0, #12
 1972 0068 FEFFFFEB 		bl	__udivsi3
 1973 006c FF0010E3 		tst	r0, #255
 1974 0070 6900001A 		bne	.L181
 1975              	.LBB19:
 735:layer1/prim_tch.c **** 		uint16_t *info_ptr = dsp_api.ndb->a_cu;
 1976              		.loc 5 735 0
 1977 0074 E0319FE5 		ldr	r3, .L196+4
 1978 0078 003093E5 		ldr	r3, [r3, #0]
 736:layer1/prim_tch.c **** 		struct msgb *msg;
 737:layer1/prim_tch.c **** 		const uint8_t *data;
 738:layer1/prim_tch.c **** 
 739:layer1/prim_tch.c **** 		/* If the TX queue is empty, send dummy measurement */
 740:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_SACCH]);
 1979              		.loc 5 740 0
 1980 007c DC019FE5 		ldr	r0, .L196+8
 1981              		.loc 5 735 0
 1982 0080 994F83E2 		add	r4, r3, #612
 1983              	.LVL175:
 1984              		.loc 5 740 0
 1985 0084 FEFFFFEB 		bl	msgb_dequeue
 741:layer1/prim_tch.c **** 		data = msg ? msg->l3h : pu_get_meas_frame();
 1986              		.loc 5 741 0
 1987 0088 005050E2 		subs	r5, r0, #0
 1988              	.LVL176:
 1989 008c 18109515 		ldrne	r1, [r5, #24]
 1990              	.LVL177:
 1991 0090 2500001A 		bne	.L185
 1992 0094 FEFFFFEB 		bl	pu_get_meas_frame
 1993              	.LVL178:
 1994 0098 0010A0E1 		mov	r1, r0
 1995              	.LVL179:
 1996              	.L185:
 742:layer1/prim_tch.c **** 
 743:layer1/prim_tch.c **** 		/* Fill data block header */
 744:layer1/prim_tch.c **** 		info_ptr[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1997              		.loc 5 744 0
 1998 009c 0239A0E3 		mov	r3, #32768
 1999 00a0 B030C4E1 		strh	r3, [r4, #0]	@ movhi
 745:layer1/prim_tch.c **** 		info_ptr[1] = 0;		/* 2nd word: cleared. */
 2000              		.loc 5 745 0
 2001 00a4 0030A0E3 		mov	r3, #0	@ movhi
 2002 00a8 B230C4E1 		strh	r3, [r4, #2]	@ movhi
 746:layer1/prim_tch.c **** 		info_ptr[2] = 0;		/* 3nd word: cleared. */
 2003              		.loc 5 746 0
 2004 00ac B430C4E1 		strh	r3, [r4, #4]	@ movhi
 747:layer1/prim_tch.c **** 
 748:layer1/prim_tch.c **** 		/* Copy the actual data after the header */
 749:layer1/prim_tch.c **** 		dsp_memcpy_to_api(&info_ptr[3], data, 23, 0);
 2005              		.loc 5 749 0
 2006 00b0 060084E2 		add	r0, r4, #6
 2007 00b4 1720A0E3 		mov	r2, #23
 2008 00b8 0030A0E3 		mov	r3, #0
 2009 00bc FEFFFFEB 		bl	dsp_memcpy_to_api
 2010              	.LVL180:
 750:layer1/prim_tch.c **** 
 751:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 752:layer1/prim_tch.c **** 		if (msg) {
 2011              		.loc 5 752 0
 2012 00c0 000055E3 		cmp	r5, #0
 2013 00c4 6400000A 		beq	.L186
 753:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 754:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_SACCH;
 2014              		.loc 5 754 0
 2015 00c8 94C19FE5 		ldr	ip, .L196+12
 2016              		.loc 5 753 0
 2017 00cc 94119FE5 		ldr	r1, .L196+16
 2018              		.loc 5 754 0
 2019 00d0 B020DCE1 		ldrh	r2, [ip, #0]
 2020              		.loc 5 753 0
 2021 00d4 90319FE5 		ldr	r3, .L196+20
 2022 00d8 BC10D1E1 		ldrh	r1, [r1, #12]
 2023              		.loc 5 754 0
 2024 00dc 012082E3 		orr	r2, r2, #1
 755:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 2025              		.loc 5 755 0
 2026 00e0 0300A0E3 		mov	r0, #3
 2027              		.loc 5 753 0
 2028 00e4 B010C3E1 		strh	r1, [r3, #0]	@ movhi
 2029              		.loc 5 754 0
 2030 00e8 B020CCE1 		strh	r2, [ip, #0]	@ movhi
 2031              		.loc 5 755 0
 2032 00ec FEFFFFEB 		bl	l1s_compl_sched
 756:layer1/prim_tch.c **** 		}
 757:layer1/prim_tch.c **** 
 758:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 759:layer1/prim_tch.c **** 		if (msg)
 760:layer1/prim_tch.c **** 			msgb_free(msg);
 2033              		.loc 5 760 0
 2034 00f0 0500A0E1 		mov	r0, r5
 2035 00f4 FEFFFFEB 		bl	msgb_free
 2036 00f8 640000EA 		b	.L186
 2037              	.L188:
 2038              	.LBE19:
 761:layer1/prim_tch.c **** 	}
 762:layer1/prim_tch.c **** 
 763:layer1/prim_tch.c **** 	/* Allocate RX burst */
 764:layer1/prim_tch.c **** 	if (burst_id == 0) {
 765:layer1/prim_tch.c **** 		/* Clear 'dangling' msgb */
 766:layer1/prim_tch.c **** 		if (rx_tch_a.msg) {
 767:layer1/prim_tch.c **** 			/* Can happen if the task was shutdown in the middle of
 768:layer1/prim_tch.c **** 			 * 4 bursts ... */
 769:layer1/prim_tch.c **** 			msgb_free(rx_tch_a.msg);
 2039              		.loc 5 769 0
 2040 00fc FEFFFFEB 		bl	msgb_free
 2041              	.L189:
 770:layer1/prim_tch.c **** 		}
 771:layer1/prim_tch.c **** 
 772:layer1/prim_tch.c **** 		/* Allocate burst */
 773:layer1/prim_tch.c **** 			/* FIXME: we actually want all allocation out of L1S! */
 774:layer1/prim_tch.c **** 		rx_tch_a.msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 2042              		.loc 5 774 0
 2043 0100 0300A0E3 		mov	r0, #3
 2044 0104 FEFFFFEB 		bl	l1ctl_msgb_alloc
 2045 0108 60419FE5 		ldr	r4, .L196+24
 2046              	.LVL181:
 775:layer1/prim_tch.c **** 		if (!rx_tch_a.msg)
 2047              		.loc 5 775 0
 2048 010c 000050E3 		cmp	r0, #0
 2049              		.loc 5 774 0
 2050 0110 200084E5 		str	r0, [r4, #32]
 2051              		.loc 5 775 0
 776:layer1/prim_tch.c **** 			printf("tch_a_cmd(0): unable to allocate msgb\n");
 2052              		.loc 5 776 0
 2053 0114 58019F05 		ldreq	r0, .L196+28
 2054 0118 FEFFFF0B 		bleq	puts
 2055              	.L190:
 777:layer1/prim_tch.c **** 
 778:layer1/prim_tch.c **** 		rx_tch_a.dl = (struct l1ctl_info_dl *) msgb_put(rx_tch_a.msg, sizeof(*rx_tch_a.dl));
 2056              		.loc 5 778 0
 2057 011c 0C10A0E3 		mov	r1, #12
 2058 0120 200094E5 		ldr	r0, [r4, #32]
 2059 0124 FEFFFFEB 		bl	msgb_put
 779:layer1/prim_tch.c **** 		rx_tch_a.di = (struct l1ctl_data_ind *) msgb_put(rx_tch_a.msg, sizeof(*rx_tch_a.di));
 2060              		.loc 5 779 0
 2061 0128 1710A0E3 		mov	r1, #23
 2062              		.loc 5 778 0
 2063 012c 240084E5 		str	r0, [r4, #36]
 2064              		.loc 5 779 0
 2065 0130 200094E5 		ldr	r0, [r4, #32]
 2066 0134 FEFFFFEB 		bl	msgb_put
 780:layer1/prim_tch.c **** 
 781:layer1/prim_tch.c **** 		/* Pre-fill DL header with some info about burst(0) */
 782:layer1/prim_tch.c **** 		rx_tch_a.dl->chan_nr = chan_nr;
 2067              		.loc 5 782 0
 2068 0138 243094E5 		ldr	r3, [r4, #36]
 2069              		.loc 5 779 0
 2070 013c 280084E5 		str	r0, [r4, #40]
 2071              		.loc 5 782 0
 2072 0140 0060C3E5 		strb	r6, [r3, #0]
 783:layer1/prim_tch.c **** 		rx_tch_a.dl->link_id = 0x40;	/* SACCH */
 2073              		.loc 5 783 0
 2074 0144 242094E5 		ldr	r2, [r4, #36]
 2075 0148 4030A0E3 		mov	r3, #64
 2076 014c 0130C2E5 		strb	r3, [r2, #1]
 2077              	.LVL182:
 784:layer1/prim_tch.c **** 		rx_tch_a.dl->band_arfcn = htons(arfcn);
 2078              		.loc 5 784 0
 2079 0150 B001DDE1 		ldrh	r0, [sp, #16]
 2080 0154 FEFFFFEB 		bl	__fswab16
 2081 0158 242094E5 		ldr	r2, [r4, #36]
 2082 015c 2034A0E1 		mov	r3, r0, lsr #8
 2083 0160 0330C2E5 		strb	r3, [r2, #3]
 2084 0164 0200C2E5 		strb	r0, [r2, #2]
 785:layer1/prim_tch.c **** 		rx_tch_a.dl->frame_nr = htonl(l1s.next_time.fn);
 2085              		.loc 5 785 0
 2086 0168 F8309FE5 		ldr	r3, .L196+16
 2087 016c 0C0093E5 		ldr	r0, [r3, #12]
 2088 0170 FEFFFFEB 		bl	__fswab32
 2089 0174 243094E5 		ldr	r3, [r4, #36]
 2090 0178 202CA0E1 		mov	r2, r0, lsr #24
 2091 017c 2014A0E1 		mov	r1, r0, lsr #8
 2092 0180 20C8A0E1 		mov	ip, r0, lsr #16
 2093 0184 0720C3E5 		strb	r2, [r3, #7]
 2094 0188 0510C3E5 		strb	r1, [r3, #5]
 2095 018c 06C0C3E5 		strb	ip, [r3, #6]
 2096 0190 0400C3E5 		strb	r0, [r3, #4]
 2097 0194 690000EA 		b	.L181
 2098              	.LVL183:
 2099              	.L186:
 2100              		.loc 5 766 0
 2101 0198 D0309FE5 		ldr	r3, .L196+24
 2102 019c 200093E5 		ldr	r0, [r3, #32]
 2103 01a0 000050E3 		cmp	r0, #0
 2104 01a4 3D00001A 		bne	.L188
 2105 01a8 3E0000EA 		b	.L189
 2106              	.LVL184:
 2107              	.L181:
 786:layer1/prim_tch.c **** 	}
 787:layer1/prim_tch.c **** 
 788:layer1/prim_tch.c **** 	/* Configure DSP for TX/RX */
 789:layer1/prim_tch.c **** 	l1s_tx_apc_helper(arfcn);
 2108              		.loc 5 789 0
 2109 01ac B001DDE1 		ldrh	r0, [sp, #16]
 2110 01b0 FEFFFFEB 		bl	l1s_tx_apc_helper
 2111              	.LVL185:
 790:layer1/prim_tch.c **** 
 791:layer1/prim_tch.c **** 	dsp_load_tch_param(
 2112              		.loc 5 791 0
 2113 01b4 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 2114 01b8 A8009FE5 		ldr	r0, .L196+16
 2115 01bc 000052E3 		cmp	r2, #0
 2116 01c0 50CAD0E5 		ldrb	ip, [r0, #2640]	@ zero_extendqisi2
 2117 01c4 16E0DDE5 		ldrb	lr, [sp, #22]	@ zero_extendqisi2
 2118 01c8 0220A003 		moveq	r2, #2
 2119 01cc 0120A013 		movne	r2, #1
 2120 01d0 0040A0E3 		mov	r4, #0
 2121              	.LVL186:
 2122 01d4 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 2123              	.LVL187:
 2124 01d8 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 2125 01dc 0C0080E2 		add	r0, r0, #12
 2126 01e0 00C08DE5 		str	ip, [sp, #0]
 2127 01e4 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 2128 01e8 FEFFFFEB 		bl	dsp_load_tch_param
 792:layer1/prim_tch.c **** 		&l1s.next_time,
 793:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 794:layer1/prim_tch.c **** 		l1s.tch_loop_mode, 0, tn
 795:layer1/prim_tch.c **** 	);
 796:layer1/prim_tch.c **** 
 797:layer1/prim_tch.c **** 	dsp_load_rx_task(
 2129              		.loc 5 797 0
 2130 01ec 0420A0E1 		mov	r2, r4
 2131 01f0 B011DDE1 		ldrh	r1, [sp, #16]
 2132 01f4 0E00A0E3 		mov	r0, #14
 2133 01f8 FEFFFFEB 		bl	dsp_task_iq_swap
 2134 01fc 0410A0E1 		mov	r1, r4
 2135              	.LVL188:
 2136 0200 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 2137 0204 FEFFFFEB 		bl	dsp_load_rx_task
 798:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHA_DSP_TASK, arfcn, 0),
 799:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCHA */
 800:layer1/prim_tch.c **** 	);
 801:layer1/prim_tch.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 2138              		.loc 5 801 0
 2139 0208 B001DDE1 		ldrh	r0, [sp, #16]
 2140 020c 0420A0E1 		mov	r2, r4
 2141 0210 0310A0E3 		mov	r1, #3
 2142 0214 FEFFFFEB 		bl	l1s_rx_win_ctrl
 802:layer1/prim_tch.c **** 
 803:layer1/prim_tch.c **** 	dsp_load_tx_task(
 2143              		.loc 5 803 0
 2144 0218 B011DDE1 		ldrh	r1, [sp, #16]
 2145 021c 0120A0E3 		mov	r2, #1
 2146 0220 0E00A0E3 		mov	r0, #14
 2147 0224 FEFFFFEB 		bl	dsp_task_iq_swap
 2148 0228 0410A0E1 		mov	r1, r4
 2149 022c 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 2150 0230 FEFFFFEB 		bl	dsp_load_tx_task
 804:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHA_DSP_TASK, arfcn, 1),
 805:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCHA */
 806:layer1/prim_tch.c **** 	);
 807:layer1/prim_tch.c **** 	l1s_tx_win_ctrl(arfcn | ARFCN_UPLINK, L1_TXWIN_NB, 0, 3);
 2151              		.loc 5 807 0
 2152 0234 B001DDE1 		ldrh	r0, [sp, #16]
 2153 0238 0410A0E1 		mov	r1, r4
 2154 023c 010980E3 		orr	r0, r0, #16384
 2155 0240 0420A0E1 		mov	r2, r4
 2156 0244 0330A0E3 		mov	r3, #3
 2157 0248 FEFFFFEB 		bl	l1s_tx_win_ctrl
 808:layer1/prim_tch.c **** 
 809:layer1/prim_tch.c **** 	return 0;
 810:layer1/prim_tch.c **** }
 2158              		.loc 5 810 0
 2159 024c 0400A0E1 		mov	r0, r4
 2160 0250 18D08DE2 		add	sp, sp, #24
 2161 0254 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 2162              	.L197:
 2163              		.align	2
 2164              	.L196:
 2165 0258 0C000000 		.word	l1s+12
 2166 025c 00000000 		.word	dsp_api
 2167 0260 5C0A0000 		.word	l1s+2652
 2168 0264 74000000 		.word	last_tx_tch_type
 2169 0268 00000000 		.word	l1s
 2170 026c 76000000 		.word	last_tx_tch_fn
 2171 0270 08000000 		.word	rx_tch_a
 2172 0274 80000000 		.word	.LC3
 2173              	.LFE78:
 2175              		.bss
 2176              		.align	2
 2177              	rx_tch_a:
 2178 0008 00000000 		.space	44
 2178      00000000 
 2178      00000000 
 2178      00000000 
 2178      00000000 
 2179              		.align	2
 2180              	rx_tch:
 2181 0034 00000000 		.space	64
 2181      00000000 
 2181      00000000 
 2181      00000000 
 2181      00000000 
 2182              		.align	1
 2183              	last_tx_tch_type:
 2184 0074 0000     		.space	2
 2185              		.align	1
 2186              	last_tx_tch_fn:
 2187 0076 0000     		.space	2
 2506              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prim_tch.c
     /tmp/ccL7s2N9.s:15     .rodata:0000000000000000 tch_a_sched_set
     /tmp/ccL7s2N9.s:16     .rodata:0000000000000000 $d
     /tmp/ccL7s2N9.s:1919   .text.l1s_tch_a_cmd:0000000000000000 l1s_tch_a_cmd
     /tmp/ccL7s2N9.s:1639   .text.l1s_tch_a_resp:0000000000000000 l1s_tch_a_resp
     /tmp/ccL7s2N9.s:48     .rodata:0000000000000048 tch_d_sched_set
     /tmp/ccL7s2N9.s:1552   .text.l1s_tch_d_cmd:0000000000000000 l1s_tch_d_cmd
     /tmp/ccL7s2N9.s:1523   .text.l1s_tch_d_resp:0000000000000000 l1s_tch_d_resp
     /tmp/ccL7s2N9.s:81     .rodata:0000000000000090 tch_sched_set
     /tmp/ccL7s2N9.s:1149   .text.l1s_tch_cmd:0000000000000000 l1s_tch_cmd
     /tmp/ccL7s2N9.s:641    .text.l1s_tch_resp:0000000000000000 l1s_tch_resp
     /tmp/ccL7s2N9.s:113    .text.__fswab16:0000000000000000 __fswab16
     /tmp/ccL7s2N9.s:121    .text.__fswab16:0000000000000000 $a
     /tmp/ccL7s2N9.s:140    .text.__fswab32:0000000000000000 __fswab32
     /tmp/ccL7s2N9.s:147    .text.__fswab32:0000000000000000 $a
     /tmp/ccL7s2N9.s:171    .text.msgb_tailroom:0000000000000000 msgb_tailroom
     /tmp/ccL7s2N9.s:179    .text.msgb_tailroom:0000000000000000 $a
     /tmp/ccL7s2N9.s:200    .text.msgb_put:0000000000000000 msgb_put
     /tmp/ccL7s2N9.s:206    .text.msgb_put:0000000000000000 $a
     /tmp/ccL7s2N9.s:248    .text.msgb_put:000000000000004c $d
     /tmp/ccL7s2N9.s:254    .text.dsp_task_iq_swap:0000000000000000 dsp_task_iq_swap
     /tmp/ccL7s2N9.s:261    .text.dsp_task_iq_swap:0000000000000000 $a
     /tmp/ccL7s2N9.s:287    .text.msb_get_bit:0000000000000000 msb_get_bit
     /tmp/ccL7s2N9.s:295    .text.msb_get_bit:0000000000000000 $a
     /tmp/ccL7s2N9.s:312    .text.msb_set_bit:0000000000000000 msb_set_bit
     /tmp/ccL7s2N9.s:320    .text.msb_set_bit:0000000000000000 $a
     /tmp/ccL7s2N9.s:337    .text.tch_fr_bit_magic:0000000000000000 tch_fr_bit_magic
     /tmp/ccL7s2N9.s:343    .text.tch_fr_bit_magic:0000000000000000 $a
     /tmp/ccL7s2N9.s:424    .text.tch_fr_bit_magic:00000000000000b4 $d
     /tmp/ccL7s2N9.s:431    .text.tch_get_params:0000000000000000 tch_get_params
     /tmp/ccL7s2N9.s:437    .text.tch_get_params:0000000000000000 $a
     /tmp/ccL7s2N9.s:533    .text.tch_get_params:00000000000000c4 $d
     /tmp/ccL7s2N9.s:539    .text.l1a_tx_tch_compl:0000000000000000 l1a_tx_tch_compl
     /tmp/ccL7s2N9.s:545    .text.l1a_tx_tch_compl:0000000000000000 $a
     /tmp/ccL7s2N9.s:593    .text.l1a_tx_tch_compl:0000000000000064 $d
     /tmp/ccL7s2N9.s:2183   .bss:0000000000000074 last_tx_tch_type
     /tmp/ccL7s2N9.s:2186   .bss:0000000000000076 last_tx_tch_fn
     /tmp/ccL7s2N9.s:600    .text.prim_tch_init:0000000000000000 prim_tch_init
     /tmp/ccL7s2N9.s:608    .text.prim_tch_init:0000000000000000 $a
     /tmp/ccL7s2N9.s:619    .text.prim_tch_init:0000000000000010 $d
     /tmp/ccL7s2N9.s:625    .ctors:0000000000000000 $d
     /tmp/ccL7s2N9.s:627    .bss:0000000000000000 meas_id.4463
     /tmp/ccL7s2N9.s:647    .text.l1s_tch_resp:0000000000000000 $a
     /tmp/ccL7s2N9.s:1129   .text.l1s_tch_resp:00000000000004c4 $d
     /tmp/ccL7s2N9.s:2180   .bss:0000000000000034 rx_tch
     /tmp/ccL7s2N9.s:1144   .bss:0000000000000004 icnt.4642
     /tmp/ccL7s2N9.s:1155   .text.l1s_tch_cmd:0000000000000000 $a
     /tmp/ccL7s2N9.s:1510   .text.l1s_tch_cmd:0000000000000358 $d
     /tmp/ccL7s2N9.s:1531   .text.l1s_tch_d_resp:0000000000000000 $a
     /tmp/ccL7s2N9.s:1546   .text.l1s_tch_d_resp:0000000000000014 $d
     /tmp/ccL7s2N9.s:1558   .text.l1s_tch_d_cmd:0000000000000000 $a
     /tmp/ccL7s2N9.s:1632   .text.l1s_tch_d_cmd:00000000000000bc $d
     /tmp/ccL7s2N9.s:1645   .text.l1s_tch_a_resp:0000000000000000 $a
     /tmp/ccL7s2N9.s:1903   .text.l1s_tch_a_resp:000000000000028c $d
     /tmp/ccL7s2N9.s:2177   .bss:0000000000000008 rx_tch_a
     /tmp/ccL7s2N9.s:1925   .text.l1s_tch_a_cmd:0000000000000000 $a
     /tmp/ccL7s2N9.s:2165   .text.l1s_tch_a_cmd:0000000000000258 $d

UNDEFINED SYMBOLS
tdma_end_set
osmo_panic
rffe_iq_swapped
memset
memcpy
gsm610_bitorder
__umodsi3
l1s
l1_create_l2_msg
l1_queue_for_l2
__udivsi3
__divsi3
gsm_fn2gsmtime
rfch_get_params
mframe_task2chan_nr
agc_inp_dbm8_by_pm
afc_input
toa_input
rffe_compute_gain
l1ctl_msgb_alloc
puts
dbm2rxlev
pu_update_rx_level
dsp_memcpy_from_api
dsp_api
msgb_dequeue
pu_get_idle_frame
dsp_memcpy_to_api
l1s_compl_sched
msgb_free
l1s_tx_apc_helper
dsp_load_tch_param
dsp_load_rx_task
l1s_rx_win_ctrl
dsp_load_tx_task
l1s_tx_win_ctrl
pu_get_meas_frame
