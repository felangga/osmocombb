   1              		.file	"prim_fbsb.c"
   9              	.Ltext0:
  10              		.data
  11              		.align	2
  14              	last_fb:
  15 0000 00000000 		.word	fbs
  16              		.section	.rodata
  17              		.align	2
  20              	sb_sched_set:
  21 0000 00000000 		.word	l1s_sbdet_cmd
  22 0004 00       		.byte	0
  23 0005 01       		.byte	1
  24 0006 0000     		.space	2
  25 0008 0000     		.short	0
  26 000a 0300     		.short	3
  27 000c 00000000 		.word	0
  28 0010 00       		.byte	0
  29 0011 00       		.byte	0
  30 0012 00000000 		.space	6
  30      0000
  31 0018 00000000 		.word	l1s_sbdet_cmd
  32 001c 00       		.byte	0
  33 001d 02       		.byte	2
  34 001e 0000     		.space	2
  35 0020 0000     		.short	0
  36 0022 0300     		.short	3
  37 0024 00000000 		.word	0
  38 0028 00       		.byte	0
  39 0029 00       		.byte	0
  40 002a 00000000 		.space	6
  40      0000
  41 0030 00000000 		.word	0
  42 0034 00       		.byte	0
  43 0035 00       		.byte	0
  44 0036 00000000 		.space	6
  44      0000
  45 003c 00000000 		.word	l1s_sbdet_resp
  46 0040 00       		.byte	0
  47 0041 01       		.byte	1
  48 0042 0000     		.space	2
  49 0044 FCFF     		.short	-4
  50 0046 0000     		.short	0
  51 0048 00000000 		.word	0
  52 004c 00       		.byte	0
  53 004d 00       		.byte	0
  54 004e 00000000 		.space	6
  54      0000
  55 0054 00000000 		.word	l1s_sbdet_resp
  56 0058 00       		.byte	0
  57 0059 02       		.byte	2
  58 005a 0000     		.space	2
  59 005c FCFF     		.short	-4
  60 005e 0000     		.short	0
  61 0060 00000000 		.word	0
  62 0064 00       		.byte	0
  63 0065 00       		.byte	0
  64 0066 00000000 		.space	6
  64      0000
  65 006c 00000000 		.word	tdma_end_set
  66 0070 00       		.byte	0
  67 0071 00       		.byte	0
  68 0072 00000000 		.space	6
  68      0000
  69              		.align	2
  72              	fb_sched_set:
  73 0078 00000000 		.word	l1s_fbdet_cmd
  74 007c 00       		.byte	0
  75 007d 00       		.byte	0
  76 007e 0000     		.space	2
  77 0080 0000     		.short	0
  78 0082 0300     		.short	3
  79 0084 00000000 		.word	0
  80 0088 00       		.byte	0
  81 0089 00       		.byte	0
  82 008a 00000000 		.space	6
  82      0000
  83 0090 00000000 		.word	0
  84 0094 00       		.byte	0
  85 0095 00       		.byte	0
  86 0096 00000000 		.space	6
  86      0000
  87 009c 00000000 		.word	l1s_fbdet_resp
  88 00a0 00       		.byte	0
  89 00a1 01       		.byte	1
  90 00a2 0000     		.space	2
  91 00a4 FCFF     		.short	-4
  92 00a6 0000     		.short	0
  93 00a8 00000000 		.word	0
  94 00ac 00       		.byte	0
  95 00ad 00       		.byte	0
  96 00ae 00000000 		.space	6
  96      0000
  97 00b4 00000000 		.word	l1s_fbdet_resp
  98 00b8 00       		.byte	0
  99 00b9 02       		.byte	2
 100 00ba 0000     		.space	2
 101 00bc FCFF     		.short	-4
 102 00be 0000     		.short	0
 103 00c0 00000000 		.word	0
 104 00c4 00       		.byte	0
 105 00c5 00       		.byte	0
 106 00c6 00000000 		.space	6
 106      0000
 107 00cc 00000000 		.word	l1s_fbdet_resp
 108 00d0 00       		.byte	0
 109 00d1 03       		.byte	3
 110 00d2 0000     		.space	2
 111 00d4 FCFF     		.short	-4
 112 00d6 0000     		.short	0
 113 00d8 00000000 		.word	0
 114 00dc 00       		.byte	0
 115 00dd 00       		.byte	0
 116 00de 00000000 		.space	6
 116      0000
 117 00e4 00000000 		.word	l1s_fbdet_resp
 118 00e8 00       		.byte	0
 119 00e9 04       		.byte	4
 120 00ea 0000     		.space	2
 121 00ec FCFF     		.short	-4
 122 00ee 0000     		.short	0
 123 00f0 00000000 		.word	0
 124 00f4 00       		.byte	0
 125 00f5 00       		.byte	0
 126 00f6 00000000 		.space	6
 126      0000
 127 00fc 00000000 		.word	l1s_fbdet_resp
 128 0100 00       		.byte	0
 129 0101 05       		.byte	5
 130 0102 0000     		.space	2
 131 0104 FCFF     		.short	-4
 132 0106 0000     		.short	0
 133 0108 00000000 		.word	0
 134 010c 00       		.byte	0
 135 010d 00       		.byte	0
 136 010e 00000000 		.space	6
 136      0000
 137 0114 00000000 		.word	l1s_fbdet_resp
 138 0118 00       		.byte	0
 139 0119 06       		.byte	6
 140 011a 0000     		.space	2
 141 011c FCFF     		.short	-4
 142 011e 0000     		.short	0
 143 0120 00000000 		.word	0
 144 0124 00       		.byte	0
 145 0125 00       		.byte	0
 146 0126 00000000 		.space	6
 146      0000
 147 012c 00000000 		.word	l1s_fbdet_resp
 148 0130 00       		.byte	0
 149 0131 07       		.byte	7
 150 0132 0000     		.space	2
 151 0134 FCFF     		.short	-4
 152 0136 0000     		.short	0
 153 0138 00000000 		.word	0
 154 013c 00       		.byte	0
 155 013d 00       		.byte	0
 156 013e 00000000 		.space	6
 156      0000
 157 0144 00000000 		.word	l1s_fbdet_resp
 158 0148 00       		.byte	0
 159 0149 08       		.byte	8
 160 014a 0000     		.space	2
 161 014c FCFF     		.short	-4
 162 014e 0000     		.short	0
 163 0150 00000000 		.word	0
 164 0154 00       		.byte	0
 165 0155 00       		.byte	0
 166 0156 00000000 		.space	6
 166      0000
 167 015c 00000000 		.word	l1s_fbdet_resp
 168 0160 00       		.byte	0
 169 0161 09       		.byte	9
 170 0162 0000     		.space	2
 171 0164 FCFF     		.short	-4
 172 0166 0000     		.short	0
 173 0168 00000000 		.word	0
 174 016c 00       		.byte	0
 175 016d 00       		.byte	0
 176 016e 00000000 		.space	6
 176      0000
 177 0174 00000000 		.word	l1s_fbdet_resp
 178 0178 00       		.byte	0
 179 0179 0A       		.byte	10
 180 017a 0000     		.space	2
 181 017c FCFF     		.short	-4
 182 017e 0000     		.short	0
 183 0180 00000000 		.word	0
 184 0184 00       		.byte	0
 185 0185 00       		.byte	0
 186 0186 00000000 		.space	6
 186      0000
 187 018c 00000000 		.word	l1s_fbdet_resp
 188 0190 00       		.byte	0
 189 0191 0B       		.byte	11
 190 0192 0000     		.space	2
 191 0194 FCFF     		.short	-4
 192 0196 0000     		.short	0
 193 0198 00000000 		.word	0
 194 019c 00       		.byte	0
 195 019d 00       		.byte	0
 196 019e 00000000 		.space	6
 196      0000
 197 01a4 00000000 		.word	l1s_fbdet_resp
 198 01a8 00       		.byte	0
 199 01a9 0C       		.byte	12
 200 01aa 0000     		.space	2
 201 01ac FCFF     		.short	-4
 202 01ae 0000     		.short	0
 203 01b0 00000000 		.word	0
 204 01b4 00       		.byte	0
 205 01b5 00       		.byte	0
 206 01b6 00000000 		.space	6
 206      0000
 207 01bc 00000000 		.word	tdma_end_set
 208 01c0 00       		.byte	0
 209 01c1 00       		.byte	0
 210 01c2 00000000 		.space	6
 210      0000
 211              		.section	.text.__fswab16,"ax",%progbits
 212              		.align	2
 214              	__fswab16:
 215              	.LFB3:
 216              		.file 1 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
 217              		.loc 1 47 0
 218              		@ args = 0, pretend = 0, frame = 0
 219              		@ frame_needed = 0, uses_anonymous_args = 0
 220              		@ link register save eliminated.
 221              	.LVL0:
 222 0000 0008A0E1 		mov	r0, r0, asl #16
 223              	.LVL1:
 224 0004 2008A0E1 		mov	r0, r0, lsr #16
 225              	.LVL2:
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
 226              		.loc 1 51 0
 227 0008 2034A0E1 		mov	r3, r0, lsr #8
 228 000c FF0000E2 		and	r0, r0, #255
 229              	.LVL3:
  52:include/swab.h **** #endif
  53:include/swab.h **** }
 230              		.loc 1 53 0
 231 0010 000483E1 		orr	r0, r3, r0, asl #8
 232              		.loc 1 47 0
 233              		@ lr needed for prologue
 234              		.loc 1 53 0
 235 0014 1EFF2FE1 		bx	lr
 236              	.LFE3:
 238              		.section	.text.msgb_tailroom,"ax",%progbits
 239              		.align	2
 241              	msgb_tailroom:
 242              	.LFB38:
 243              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 244              		.loc 2 151 0
 245              		@ args = 0, pretend = 0, frame = 0
 246              		@ frame_needed = 0, uses_anonymous_args = 0
 247              		@ link register save eliminated.
 248              	.LVL4:
 249 0000 B423D0E1 		ldrh	r2, [r0, #52]
 250 0004 383090E5 		ldr	r3, [r0, #56]
 251 0008 3C0090E5 		ldr	r0, [r0, #60]
 252              	.LVL5:
 253 000c 023083E0 		add	r3, r3, r2
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 254              		.loc 2 153 0
 255 0010 030060E0 		rsb	r0, r0, r3
 256              		.loc 2 151 0
 257              		@ lr needed for prologue
 258              		.loc 2 153 0
 259 0014 1EFF2FE1 		bx	lr
 260              	.LFE38:
 262              		.section	.rodata.str1.4,"aMS",%progbits,1
 263              		.align	2
 264              	.LC0:
 265 0000 28256C75 		.ascii	"(%lu:%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz\012\000"
 265      3A257529 
 265      3A20544F 
 265      413D2535 
 265      752C2050 
 266              		.section	.text.dump_mon_state,"ax",%progbits
 267              		.align	2
 269              	dump_mon_state:
 270              	.LFB67:
 271              		.file 3 "layer1/prim_fbsb.c"
   1:layer1/prim_fbsb.c **** /* Layer 1 - FCCH and SCH burst handling */
   2:layer1/prim_fbsb.c **** 
   3:layer1/prim_fbsb.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:layer1/prim_fbsb.c ****  *
   5:layer1/prim_fbsb.c ****  * All Rights Reserved
   6:layer1/prim_fbsb.c ****  *
   7:layer1/prim_fbsb.c ****  * This program is free software; you can redistribute it and/or modify
   8:layer1/prim_fbsb.c ****  * it under the terms of the GNU General Public License as published by
   9:layer1/prim_fbsb.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:layer1/prim_fbsb.c ****  * (at your option) any later version.
  11:layer1/prim_fbsb.c ****  *
  12:layer1/prim_fbsb.c ****  * This program is distributed in the hope that it will be useful,
  13:layer1/prim_fbsb.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:layer1/prim_fbsb.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:layer1/prim_fbsb.c ****  * GNU General Public License for more details.
  16:layer1/prim_fbsb.c ****  *
  17:layer1/prim_fbsb.c ****  * You should have received a copy of the GNU General Public License along
  18:layer1/prim_fbsb.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:layer1/prim_fbsb.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:layer1/prim_fbsb.c ****  *
  21:layer1/prim_fbsb.c ****  */
  22:layer1/prim_fbsb.c **** 
  23:layer1/prim_fbsb.c **** #include <stdint.h>
  24:layer1/prim_fbsb.c **** #include <stdio.h>
  25:layer1/prim_fbsb.c **** #include <string.h>
  26:layer1/prim_fbsb.c **** #include <stdlib.h>
  27:layer1/prim_fbsb.c **** #include <errno.h>
  28:layer1/prim_fbsb.c **** #include <inttypes.h>
  29:layer1/prim_fbsb.c **** #include <defines.h>
  30:layer1/prim_fbsb.c **** #include <debug.h>
  31:layer1/prim_fbsb.c **** #include <memory.h>
  32:layer1/prim_fbsb.c **** #include <byteorder.h>
  33:layer1/prim_fbsb.c **** #include <rffe.h>
  34:layer1/prim_fbsb.c **** #include <osmocom/gsm/gsm_utils.h>
  35:layer1/prim_fbsb.c **** #include <osmocom/core/msgb.h>
  36:layer1/prim_fbsb.c **** #include <calypso/dsp_api.h>
  37:layer1/prim_fbsb.c **** #include <calypso/irq.h>
  38:layer1/prim_fbsb.c **** #include <calypso/tpu.h>
  39:layer1/prim_fbsb.c **** #include <calypso/tsp.h>
  40:layer1/prim_fbsb.c **** #include <calypso/dsp.h>
  41:layer1/prim_fbsb.c **** #include <calypso/timer.h>
  42:layer1/prim_fbsb.c **** #include <comm/sercomm.h>
  43:layer1/prim_fbsb.c **** 
  44:layer1/prim_fbsb.c **** #include <layer1/sync.h>
  45:layer1/prim_fbsb.c **** #include <layer1/afc.h>
  46:layer1/prim_fbsb.c **** #include <layer1/toa.h>
  47:layer1/prim_fbsb.c **** #include <layer1/tdma_sched.h>
  48:layer1/prim_fbsb.c **** #include <layer1/mframe_sched.h>
  49:layer1/prim_fbsb.c **** #include <layer1/tpu_window.h>
  50:layer1/prim_fbsb.c **** #include <layer1/l23_api.h>
  51:layer1/prim_fbsb.c **** #include <layer1/agc.h>
  52:layer1/prim_fbsb.c **** 
  53:layer1/prim_fbsb.c **** #include <l1ctl_proto.h>
  54:layer1/prim_fbsb.c **** 
  55:layer1/prim_fbsb.c **** #define FB0_RETRY_COUNT		3
  56:layer1/prim_fbsb.c **** #define AFC_RETRY_COUNT		30
  57:layer1/prim_fbsb.c **** 
  58:layer1/prim_fbsb.c **** extern uint16_t rf_arfcn; // TODO
  59:layer1/prim_fbsb.c **** 
  60:layer1/prim_fbsb.c **** struct mon_state {
  61:layer1/prim_fbsb.c **** 	uint32_t fnr_report;	/* frame number when DSP reported it */
  62:layer1/prim_fbsb.c **** 	int attempt;		/* which attempt was this ? */
  63:layer1/prim_fbsb.c **** 
  64:layer1/prim_fbsb.c **** 	int16_t toa;
  65:layer1/prim_fbsb.c **** 	uint16_t pm;
  66:layer1/prim_fbsb.c **** 	uint16_t angle;
  67:layer1/prim_fbsb.c **** 	uint16_t snr;
  68:layer1/prim_fbsb.c **** 
  69:layer1/prim_fbsb.c **** 	/* computed values */
  70:layer1/prim_fbsb.c **** 	int16_t freq_diff;
  71:layer1/prim_fbsb.c **** 
  72:layer1/prim_fbsb.c **** 	/* Sync Burst (SB) */
  73:layer1/prim_fbsb.c **** 	uint8_t bsic;
  74:layer1/prim_fbsb.c **** 	struct gsm_time time;
  75:layer1/prim_fbsb.c **** };
  76:layer1/prim_fbsb.c **** 
  77:layer1/prim_fbsb.c **** struct l1a_fb_state {
  78:layer1/prim_fbsb.c **** 	struct mon_state mon;
  79:layer1/prim_fbsb.c **** 	struct l1ctl_fbsb_req req;
  80:layer1/prim_fbsb.c **** 	int16_t initial_freq_err;
  81:layer1/prim_fbsb.c **** 	uint8_t fb_retries;
  82:layer1/prim_fbsb.c **** 	uint8_t afc_retries;
  83:layer1/prim_fbsb.c **** };
  84:layer1/prim_fbsb.c **** 
  85:layer1/prim_fbsb.c **** static struct l1a_fb_state fbs;
  86:layer1/prim_fbsb.c **** static struct mon_state *last_fb = &fbs.mon;
  87:layer1/prim_fbsb.c **** 
  88:layer1/prim_fbsb.c **** static void dump_mon_state(struct mon_state *fb)
  89:layer1/prim_fbsb.c **** {
 272              		.loc 3 89 0
 273              		@ args = 0, pretend = 0, frame = 0
 274              		@ frame_needed = 0, uses_anonymous_args = 0
 275              	.LVL6:
 276 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 277              	.LCFI0:
 278 0004 0040A0E1 		mov	r4, r0
 279 0008 08D04DE2 		sub	sp, sp, #8
 280              	.LCFI1:
 281              	.LVL7:
  90:layer1/prim_fbsb.c **** #if 0
  91:layer1/prim_fbsb.c **** 	printf("(%"PRIu32":%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz, "
  92:layer1/prim_fbsb.c **** 		"SNR=%04x(%d.%u) OFFSET=%u SYNCHRO=%u\n",
  93:layer1/prim_fbsb.c **** 		fb->fnr_report, fb->attempt, fb->toa,
  94:layer1/prim_fbsb.c **** 		agc_inp_dbm8_by_pm(fb->pm)/8, ANGLE_TO_FREQ(fb->angle),
  95:layer1/prim_fbsb.c **** 		fb->snr, l1s_snr_int(fb->snr), l1s_snr_fract(fb->snr),
  96:layer1/prim_fbsb.c **** 		tpu_get_offset(), tpu_get_synchro());
  97:layer1/prim_fbsb.c **** #else
  98:layer1/prim_fbsb.c **** 	printf("(%"PRIu32":%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz\n",
 282              		.loc 3 98 0
 283 000c FA00D0E1 		ldrsh	r0, [r0, #10]
 284              	.LVL8:
 285 0010 600094E8 		ldmia	r4, {r5, r6}	@ phole ldm
 286 0014 F870D4E1 		ldrsh	r7, [r4, #8]
 287 0018 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 288 001c FC20D4E1 		ldrsh	r2, [r4, #12]
 289 0020 4C309FE5 		ldr	r3, .L7
 290 0024 92030EE0 		mul	lr, r2, r3
 291 0028 00C8A0E1 		mov	ip, r0, asl #16
 292 002c 4CC8A0E1 		mov	ip, ip, asr #16
 293 0030 FF3C8EE2 		add	r3, lr, #65280
 294 0034 07208CE2 		add	r2, ip, #7
 295 0038 00005CE3 		cmp	ip, #0
 296 003c 02C0A0B1 		movlt	ip, r2
 297 0040 FF3083E2 		add	r3, r3, #255
 298 0044 00005EE3 		cmp	lr, #0
 299 0048 03E0A0B1 		movlt	lr, r3
 300 004c CCC1A0E1 		mov	ip, ip, asr #3
 301 0050 4EE8A0E1 		mov	lr, lr, asr #16
 302 0054 0510A0E1 		mov	r1, r5
 303 0058 0620A0E1 		mov	r2, r6
 304 005c 0730A0E1 		mov	r3, r7
 305 0060 10009FE5 		ldr	r0, .L7+4
 306 0064 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 307 0068 FEFFFFEB 		bl	printf
  99:layer1/prim_fbsb.c **** 		fb->fnr_report, fb->attempt, fb->toa,
 100:layer1/prim_fbsb.c **** 		agc_inp_dbm8_by_pm(fb->pm)/8, ANGLE_TO_FREQ(fb->angle));
 101:layer1/prim_fbsb.c **** #endif
 102:layer1/prim_fbsb.c **** }
 308              		.loc 3 102 0
 309 006c 08D08DE2 		add	sp, sp, #8
 310 0070 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 311              	.L8:
 312              		.align	2
 313              	.L7:
 314 0074 C0500100 		.word	86208
 315 0078 00000000 		.word	.LC0
 316              	.LFE67:
 318              		.section	.rodata.str1.4
 319 002e 0000     		.align	2
 320              	.LC1:
 321 0030 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 321      28257029 
 321      3A204E6F 
 321      7420656E 
 321      6F756768 
 322 0062 00       		.ascii	"\000"
 323              		.section	.text.l1ctl_fbsb_resp,"ax",%progbits
 324              		.align	2
 326              	l1ctl_fbsb_resp:
 327              	.LFB68:
 103:layer1/prim_fbsb.c **** 
 104:layer1/prim_fbsb.c **** static int l1ctl_fbsb_resp(uint8_t res)
 105:layer1/prim_fbsb.c **** {
 328              		.loc 3 105 0
 329              		@ args = 0, pretend = 0, frame = 0
 330              		@ frame_needed = 0, uses_anonymous_args = 0
 331              	.LVL9:
 332 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 333              	.LCFI2:
 106:layer1/prim_fbsb.c **** 	struct msgb *msg;
 107:layer1/prim_fbsb.c **** 	struct l1ctl_fbsb_conf *resp;
 108:layer1/prim_fbsb.c **** 
 109:layer1/prim_fbsb.c **** 	msg = l1_create_l2_msg(L1CTL_FBSB_CONF, fbs.mon.time.fn,
 334              		.loc 3 109 0
 335 0004 A0609FE5 		ldr	r6, .L16
 336              		.loc 3 105 0
 337 0008 0030A0E1 		mov	r3, r0
 338              		.loc 3 109 0
 339 000c BE00D6E1 		ldrh	r0, [r6, #14]
 340              	.LVL10:
 341 0010 144096E5 		ldr	r4, [r6, #20]
 342              		.loc 3 105 0
 343 0014 FF7003E2 		and	r7, r3, #255
 344              		.loc 3 109 0
 345 0018 FEFFFFEB 		bl	l1s_snr_int
 346              	.LVL11:
 347 001c 0028A0E1 		mov	r2, r0, asl #16
 348 0020 0410A0E1 		mov	r1, r4
 349 0024 B032D6E1 		ldrh	r3, [r6, #32]
 350 0028 2228A0E1 		mov	r2, r2, lsr #16
 351 002c 0200A0E3 		mov	r0, #2
 352 0030 FEFFFFEB 		bl	l1_create_l2_msg
 110:layer1/prim_fbsb.c **** 				l1s_snr_int(fbs.mon.snr),
 111:layer1/prim_fbsb.c **** 				fbs.req.band_arfcn);
 112:layer1/prim_fbsb.c **** 	if (!msg)
 353              		.loc 3 112 0
 354 0034 004050E2 		subs	r4, r0, #0
 355              	.LVL12:
 356 0038 0B30E0E3 		mvn	r3, #11
 357 003c 2700000A 		beq	.L12
 358              	.LBB2:
 359              	.LBB3:
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 360              		.loc 2 182 0
 361 0040 FEFFFFEB 		bl	msgb_tailroom
 362 0044 030050E3 		cmp	r0, #3
 363 0048 0020A0E1 		mov	r2, r0
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 364              		.loc 2 183 0
 365 004c 0410A0E1 		mov	r1, r4
 366 0050 0430A0E3 		mov	r3, #4
 367 0054 54009FE5 		ldr	r0, .L16+4
 368              		.loc 2 181 0
 369 0058 3C5094E5 		ldr	r5, [r4, #60]
 370              	.LVL13:
 371              		.loc 2 182 0
 372              		.loc 2 183 0
 373 005c FEFFFFDB 		blle	osmo_panic
 374              	.LVL14:
 375              	.L13:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 376              		.loc 2 186 0
 377 0060 B633D4E1 		ldrh	r3, [r4, #54]
 378              		.loc 2 185 0
 379 0064 3C2094E5 		ldr	r2, [r4, #60]
 380              		.loc 2 186 0
 381 0068 043083E2 		add	r3, r3, #4
 382 006c B633C4E1 		strh	r3, [r4, #54]	@ movhi
 383              		.loc 2 185 0
 384 0070 042082E2 		add	r2, r2, #4
 385              	.LBE3:
 386              	.LBE2:
 113:layer1/prim_fbsb.c **** 		return -ENOMEM;
 114:layer1/prim_fbsb.c **** 
 115:layer1/prim_fbsb.c **** 	resp = (struct l1ctl_fbsb_conf *) msgb_put(msg, sizeof(*resp));
 116:layer1/prim_fbsb.c **** 	resp->initial_freq_err = htons(fbs.initial_freq_err);
 387              		.loc 3 116 0
 388 0074 BE02D6E1 		ldrh	r0, [r6, #46]
 389              	.LBB4:
 390              	.LBB5:
 391              		.loc 2 185 0
 392 0078 3C2084E5 		str	r2, [r4, #60]
 393              	.LBE5:
 394              	.LBE4:
 395              		.loc 3 116 0
 396 007c FEFFFFEB 		bl	__fswab16
 397 0080 2034A0E1 		mov	r3, r0, lsr #8
 398 0084 0000C5E5 		strb	r0, [r5, #0]
 399 0088 0130C5E5 		strb	r3, [r5, #1]
 117:layer1/prim_fbsb.c **** 	resp->result = res;
 400              		.loc 3 117 0
 401 008c 0270C5E5 		strb	r7, [r5, #2]
 118:layer1/prim_fbsb.c **** 	resp->bsic = fbs.mon.bsic;
 402              		.loc 3 118 0
 403 0090 1230D6E5 		ldrb	r3, [r6, #18]	@ zero_extendqisi2
 119:layer1/prim_fbsb.c **** 
 120:layer1/prim_fbsb.c **** 	/* no need to set BSIC, as it is never used here */
 121:layer1/prim_fbsb.c **** 	l1_queue_for_l2(msg);
 404              		.loc 3 121 0
 405 0094 0400A0E1 		mov	r0, r4
 406              		.loc 3 118 0
 407 0098 0330C5E5 		strb	r3, [r5, #3]
 408              		.loc 3 121 0
 409 009c FEFFFFEB 		bl	l1_queue_for_l2
 410 00a0 0030A0E3 		mov	r3, #0
 411              	.L12:
 122:layer1/prim_fbsb.c **** 
 123:layer1/prim_fbsb.c **** 	return 0;
 124:layer1/prim_fbsb.c **** }
 412              		.loc 3 124 0
 413 00a4 0300A0E1 		mov	r0, r3
 414 00a8 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 415              	.L17:
 416              		.align	2
 417              	.L16:
 418 00ac 00000000 		.word	fbs
 419 00b0 30000000 		.word	.LC1
 420              	.LFE68:
 422              		.section	.rodata.str1.4
 423 0063 00       		.align	2
 424              	.LC2:
 425 0064 53422564 		.ascii	"SB%d \000"
 425      2000
 426              		.global	__udivsi3
 427 006a 0000     		.align	2
 428              	.LC3:
 429 006c 3D3E2053 		.ascii	"=> SB 0x%08lx: BSIC=%u \000"
 429      42203078 
 429      2530386C 
 429      783A2042 
 429      5349433D 
 430              		.align	2
 431              	.LC4:
 432 0084 3D3E2044 		.ascii	"=> DSP reports SB in bit that is %d bits in the fut"
 432      53502072 
 432      65706F72 
 432      74732053 
 432      4220696E 
 433 00b7 7572653F 		.ascii	"ure?!?\012\000"
 433      213F0A00 
 434 00bf 00       		.align	2
 435              	.LC5:
 436 00c0 20716269 		.ascii	" qbits=%u\012\000"
 436      74733D25 
 436      750A00
 437              		.section	.text.l1s_sbdet_resp,"ax",%progbits
 438              		.align	2
 440              	l1s_sbdet_resp:
 441              	.LFB71:
 125:layer1/prim_fbsb.c **** 
 126:layer1/prim_fbsb.c **** /* SCH Burst Detection ********************************************************/
 127:layer1/prim_fbsb.c **** 
 128:layer1/prim_fbsb.c **** /* determine the GSM time and BSIC from a Sync Burst */
 129:layer1/prim_fbsb.c **** static uint8_t l1s_decode_sb(struct gsm_time *time, uint32_t sb)
 130:layer1/prim_fbsb.c **** {
 131:layer1/prim_fbsb.c **** 	uint8_t bsic = (sb >> 2) & 0x3f;
 132:layer1/prim_fbsb.c **** 	uint8_t t3p;
 133:layer1/prim_fbsb.c **** 
 134:layer1/prim_fbsb.c **** 	memset(time, 0, sizeof(*time));
 135:layer1/prim_fbsb.c **** 
 136:layer1/prim_fbsb.c **** 	/* TS 05.02 Chapter 3.3.2.2.1 SCH Frame Numbers */
 137:layer1/prim_fbsb.c **** 	time->t1 = ((sb >> 23) & 1) | ((sb >> 7) & 0x1fe) | ((sb << 9) & 0x600);
 138:layer1/prim_fbsb.c **** 	time->t2 = (sb >> 18) & 0x1f;
 139:layer1/prim_fbsb.c **** 	t3p = ((sb >> 24) & 1) | ((sb >> 15) & 6);
 140:layer1/prim_fbsb.c **** 	time->t3 = t3p*10 + 1;
 141:layer1/prim_fbsb.c **** 
 142:layer1/prim_fbsb.c **** 	/* TS 05.02 Chapter 4.3.3 TDMA frame number */
 143:layer1/prim_fbsb.c **** 	time->fn = gsm_gsmtime2fn(time);
 144:layer1/prim_fbsb.c **** 
 145:layer1/prim_fbsb.c **** 	time->tc = (time->fn / 51) % 8;
 146:layer1/prim_fbsb.c **** 
 147:layer1/prim_fbsb.c **** 	return bsic;
 148:layer1/prim_fbsb.c **** }
 149:layer1/prim_fbsb.c **** 
 150:layer1/prim_fbsb.c **** static void read_sb_result(struct mon_state *st, int attempt)
 151:layer1/prim_fbsb.c **** {
 152:layer1/prim_fbsb.c **** 	st->toa = dsp_api.db_r->a_serv_demod[D_TOA];
 153:layer1/prim_fbsb.c **** 	st->pm = dsp_api.db_r->a_serv_demod[D_PM]>>3;
 154:layer1/prim_fbsb.c **** 	st->angle = dsp_api.db_r->a_serv_demod[D_ANGLE];
 155:layer1/prim_fbsb.c **** 	st->snr = dsp_api.db_r->a_serv_demod[D_SNR];
 156:layer1/prim_fbsb.c **** 
 157:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(st->angle);
 158:layer1/prim_fbsb.c **** 	st->fnr_report = l1s.current_time.fn;
 159:layer1/prim_fbsb.c **** 	st->attempt = attempt;
 160:layer1/prim_fbsb.c **** 
 161:layer1/prim_fbsb.c **** 	dump_mon_state(st);
 162:layer1/prim_fbsb.c **** 
 163:layer1/prim_fbsb.c **** 	if (st->snr > AFC_SNR_THRESHOLD)
 164:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 1);
 165:layer1/prim_fbsb.c **** 	else
 166:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 0);
 167:layer1/prim_fbsb.c **** 
 168:layer1/prim_fbsb.c **** 	dsp_api.r_page_used = 1;
 169:layer1/prim_fbsb.c **** }
 170:layer1/prim_fbsb.c **** 
 171:layer1/prim_fbsb.c **** /* Note: When we get the SB response, it is 2 TDMA frames after the SB
 172:layer1/prim_fbsb.c ****  * actually happened, as it is a "C W W R" task */
 173:layer1/prim_fbsb.c **** #define SB2_LATENCY	2
 174:layer1/prim_fbsb.c **** 
 175:layer1/prim_fbsb.c **** static int l1s_sbdet_resp(__unused uint8_t p1, uint8_t attempt,
 176:layer1/prim_fbsb.c **** 			  __unused uint16_t p3)
 177:layer1/prim_fbsb.c **** {
 442              		.loc 3 177 0
 443              		@ args = 0, pretend = 0, frame = 0
 444              		@ frame_needed = 0, uses_anonymous_args = 0
 445              	.LVL15:
 446 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 447              	.LCFI3:
 178:layer1/prim_fbsb.c **** 	uint32_t sb;
 179:layer1/prim_fbsb.c **** 	int qbits, fn_offset;
 180:layer1/prim_fbsb.c **** 	struct l1_cell_info *cinfo = &l1s.serving_cell;
 181:layer1/prim_fbsb.c **** 	int fnr_delta, bits_delta;
 182:layer1/prim_fbsb.c **** 
 183:layer1/prim_fbsb.c **** 	putchart('s');
 184:layer1/prim_fbsb.c **** 
 185:layer1/prim_fbsb.c **** 	if (dsp_api.db_r->a_sch[0] & (1<<B_SCH_CRC)) {
 448              		.loc 3 185 0
 449 0004 C8429FE5 		ldr	r4, .L46
 450 0008 043094E5 		ldr	r3, [r4, #4]
 451 000c BE31D3E1 		ldrh	r3, [r3, #30]
 452 0010 015C13E2 		ands	r5, r3, #256
 453              		.loc 3 177 0
 454 0014 FF6001E2 		and	r6, r1, #255
 455              		.loc 3 185 0
 456 0018 0E00000A 		beq	.L19
 457              	.LVL16:
 186:layer1/prim_fbsb.c **** 		/* mark READ page as being used */
 187:layer1/prim_fbsb.c **** 		dsp_api.r_page_used = 1;
 458              		.loc 3 187 0
 459 001c 0130A0E3 		mov	r3, #1
 188:layer1/prim_fbsb.c **** 
 189:layer1/prim_fbsb.c **** 		/* after 2nd attempt, we failed */
 190:layer1/prim_fbsb.c **** 		if (attempt == 2) {
 460              		.loc 3 190 0
 461 0020 020056E3 		cmp	r6, #2
 462              		.loc 3 187 0
 463 0024 183084E5 		str	r3, [r4, #24]
 464              		.loc 3 190 0
 465 0028 B100001A 		bne	.L21
 191:layer1/prim_fbsb.c **** 			last_fb->attempt = 13;
 466              		.loc 3 191 0
 467 002c A4329FE5 		ldr	r3, .L46+4
 468 0030 002093E5 		ldr	r2, [r3, #0]
 469              	.LVL17:
 470 0034 0D30A0E3 		mov	r3, #13
 471 0038 043082E5 		str	r3, [r2, #4]
 472 003c AF0000EA 		b	.L37
 473              	.LVL18:
 474              	.L19:
 192:layer1/prim_fbsb.c **** 			l1s_compl_sched(L1_COMPL_FB);
 193:layer1/prim_fbsb.c **** 		}
 194:layer1/prim_fbsb.c **** 
 195:layer1/prim_fbsb.c **** 		/* after 1st attempt, we simply wait for 2nd */
 196:layer1/prim_fbsb.c **** 		return 0;
 197:layer1/prim_fbsb.c **** 	}
 198:layer1/prim_fbsb.c **** 
 199:layer1/prim_fbsb.c **** 	printf("SB%d ", attempt);
 475              		.loc 3 199 0
 476 0040 0610A0E1 		mov	r1, r6
 477 0044 90029FE5 		ldr	r0, .L46+8
 478              	.LVL19:
 479 0048 FEFFFFEB 		bl	printf
 480              	.LVL20:
 481              	.LBB6:
 482              	.LBB7:
 483              		.loc 3 152 0
 484 004c 041094E5 		ldr	r1, [r4, #4]
 485              	.LBE7:
 486              	.LBE6:
 200:layer1/prim_fbsb.c **** 	read_sb_result(last_fb, attempt);
 487              		.loc 3 200 0
 488 0050 80329FE5 		ldr	r3, .L46+4
 489 0054 004093E5 		ldr	r4, [r3, #0]
 490              	.LVL21:
 491              	.LBB8:
 492              	.LBB9:
 493              		.loc 3 152 0
 494 0058 B031D1E1 		ldrh	r3, [r1, #16]
 495 005c B830C4E1 		strh	r3, [r4, #8]	@ movhi
 496              		.loc 3 153 0
 497 0060 B231D1E1 		ldrh	r3, [r1, #18]
 498 0064 A331A0E1 		mov	r3, r3, lsr #3
 499 0068 BA30C4E1 		strh	r3, [r4, #10]	@ movhi
 500              		.loc 3 154 0
 501 006c B431D1E1 		ldrh	r3, [r1, #20]
 502 0070 BC30C4E1 		strh	r3, [r4, #12]	@ movhi
 503              		.loc 3 157 0
 504 0074 64329FE5 		ldr	r3, .L46+12
 505 0078 FC20D4E1 		ldrsh	r2, [r4, #12]
 506 007c 930202E0 		mul	r2, r3, r2
 507 0080 FF3C82E2 		add	r3, r2, #65280
 508 0084 000052E3 		cmp	r2, #0
 509 0088 FF3083E2 		add	r3, r3, #255
 510 008c 0320A0B1 		movlt	r2, r3
 511              		.loc 3 158 0
 512 0090 4C329FE5 		ldr	r3, .L46+16
 513              		.loc 3 155 0
 514 0094 B611D1E1 		ldrh	r1, [r1, #22]
 515              		.loc 3 158 0
 516 0098 003093E5 		ldr	r3, [r3, #0]
 517              		.loc 3 157 0
 518 009c 4228A0E1 		mov	r2, r2, asr #16
 519              		.loc 3 155 0
 520 00a0 BE10C4E1 		strh	r1, [r4, #14]	@ movhi
 521              		.loc 3 157 0
 522 00a4 B021C4E1 		strh	r2, [r4, #16]	@ movhi
 523              		.loc 3 158 0
 524 00a8 003084E5 		str	r3, [r4, #0]
 525              		.loc 3 161 0
 526 00ac 0400A0E1 		mov	r0, r4
 527              		.loc 3 159 0
 528 00b0 046084E5 		str	r6, [r4, #4]
 529              		.loc 3 161 0
 530 00b4 FEFFFFEB 		bl	dump_mon_state
 531              		.loc 3 163 0
 532 00b8 BE30D4E1 		ldrh	r3, [r4, #14]
 533 00bc B001D4E1 		ldrh	r0, [r4, #16]
 534 00c0 0A0C53E3 		cmp	r3, #2560
 535 00c4 1C329FE5 		ldr	r3, .L46+20
 536              		.loc 3 164 0
 537 00c8 0008A081 		movhi	r0, r0, asl #16
 538              		.loc 3 166 0
 539 00cc 0008A091 		movls	r0, r0, asl #16
 540              		.loc 3 164 0
 541 00d0 B010D381 		ldrhih	r1, [r3, #0]
 542              		.loc 3 166 0
 543 00d4 B010D391 		ldrlsh	r1, [r3, #0]
 544 00d8 0520A091 		movls	r2, r5
 545              		.loc 3 164 0
 546 00dc 4008A081 		movhi	r0, r0, asr #16
 547 00e0 0120A083 		movhi	r2, #1
 548              		.loc 3 166 0
 549 00e4 4008A091 		movls	r0, r0, asr #16
 550 00e8 FEFFFFEB 		bl	afc_input
 551              		.loc 3 168 0
 552 00ec E0C19FE5 		ldr	ip, .L46
 553              	.LBE9:
 554              	.LBE8:
 201:layer1/prim_fbsb.c **** 
 202:layer1/prim_fbsb.c **** 	sb = dsp_api.db_r->a_sch[3] | dsp_api.db_r->a_sch[4] << 16;
 555              		.loc 3 202 0
 556 00f0 04309CE5 		ldr	r3, [ip, #4]
 557 00f4 B622D3E1 		ldrh	r2, [r3, #38]
 558 00f8 B452D3E1 		ldrh	r5, [r3, #36]
 559              	.LBB10:
 560              	.LBB11:
 561              		.loc 3 168 0
 562 00fc 0130A0E3 		mov	r3, #1
 563              	.LBE11:
 564              	.LBE10:
 565              		.loc 3 202 0
 566 0100 025885E1 		orr	r5, r5, r2, asl #16
 567              	.LVL22:
 568              	.LBB12:
 569              	.LBB13:
 570              		.loc 3 168 0
 571 0104 18308CE5 		str	r3, [ip, #24]
 572              	.LBE13:
 573              	.LBE12:
 574              	.LBB14:
 575              	.LBB15:
 576              		.loc 3 134 0
 577 0108 0C20A0E3 		mov	r2, #12
 578 010c 0010A0E3 		mov	r1, #0
 579 0110 D4019FE5 		ldr	r0, .L46+24
 580 0114 FEFFFFEB 		bl	memset
 581              		.loc 3 140 0
 582 0118 A537A0E1 		mov	r3, r5, lsr #15
 583 011c 8523A0E1 		mov	r2, r5, asl #7
 584 0120 063003E2 		and	r3, r3, #6
 585 0124 A23F83E1 		orr	r3, r3, r2, lsr #31
 586 0128 0A20A0E3 		mov	r2, #10
 587 012c 93020CE0 		mul	ip, r3, r2
 588              		.loc 3 137 0
 589 0130 A533A0E1 		mov	r3, r5, lsr #7
 590 0134 7D2F82E2 		add	r2, r2, #500
 591 0138 022003E0 		and	r2, r3, r2
 592 013c 0514A0E1 		mov	r1, r5, asl #8
 593 0140 8534A0E1 		mov	r3, r5, asl #9
 594 0144 A4419FE5 		ldr	r4, .L46+28
 595              	.LVL23:
 596 0148 063C03E2 		and	r3, r3, #1536
 597 014c A12F82E1 		orr	r2, r2, r1, lsr #31
 598              		.loc 3 138 0
 599 0150 2519A0E1 		mov	r1, r5, lsr #18
 600              		.loc 3 137 0
 601 0154 032082E1 		orr	r2, r2, r3
 602              		.loc 3 140 0
 603 0158 01C08CE2 		add	ip, ip, #1
 604              		.loc 3 138 0
 605 015c 1F1001E2 		and	r1, r1, #31
 606              		.loc 3 137 0
 607 0160 B821C4E1 		strh	r2, [r4, #24]	@ movhi
 608              		.loc 3 140 0
 609 0164 1BC0C4E5 		strb	ip, [r4, #27]
 610              		.loc 3 138 0
 611 0168 1A10C4E5 		strb	r1, [r4, #26]
 612              		.loc 3 143 0
 613 016c 140084E2 		add	r0, r4, #20
 614 0170 FEFFFFEB 		bl	gsm_gsmtime2fn
 615              		.loc 3 145 0
 616 0174 3310A0E3 		mov	r1, #51
 617              		.loc 3 143 0
 618 0178 140084E5 		str	r0, [r4, #20]
 619              		.loc 3 145 0
 620 017c FEFFFFEB 		bl	__udivsi3
 621              	.LBE15:
 622              	.LBE14:
 203:layer1/prim_fbsb.c **** 	fbs.mon.bsic = l1s_decode_sb(&fbs.mon.time, sb);
 623              		.loc 3 203 0
 624 0180 2531A0E1 		mov	r3, r5, lsr #2
 625 0184 3F3003E2 		and	r3, r3, #63
 626              	.LBB16:
 627              	.LBB17:
 628              		.loc 3 145 0
 629 0188 07C000E2 		and	ip, r0, #7
 630              	.LBE17:
 631              	.LBE16:
 204:layer1/prim_fbsb.c **** 	printf("=> SB 0x%08"PRIx32": BSIC=%u ", sb, fbs.mon.bsic);
 632              		.loc 3 204 0
 633 018c 0320A0E1 		mov	r2, r3
 634              	.LBB18:
 635              	.LBB19:
 636              		.loc 3 145 0
 637 0190 1CC0C4E5 		strb	ip, [r4, #28]
 638              	.LBE19:
 639              	.LBE18:
 640              		.loc 3 203 0
 641 0194 1230C4E5 		strb	r3, [r4, #18]
 642              		.loc 3 204 0
 643 0198 0510A0E1 		mov	r1, r5
 644 019c 50019FE5 		ldr	r0, .L46+32
 645 01a0 FEFFFFEB 		bl	printf
 205:layer1/prim_fbsb.c **** 	l1s_time_dump(&fbs.mon.time);
 646              		.loc 3 205 0
 647 01a4 140084E2 		add	r0, r4, #20
 648 01a8 FEFFFFEB 		bl	l1s_time_dump
 206:layer1/prim_fbsb.c **** 
 207:layer1/prim_fbsb.c **** 	l1s.serving_cell.bsic = fbs.mon.bsic;
 649              		.loc 3 207 0
 650 01ac 1220D4E5 		ldrb	r2, [r4, #18]	@ zero_extendqisi2
 651 01b0 2C319FE5 		ldr	r3, .L46+16
 652 01b4 1A20C3E5 		strb	r2, [r3, #26]
 208:layer1/prim_fbsb.c **** 
 209:layer1/prim_fbsb.c **** 	/* calculate synchronisation value (TODO: only complete for qbits) */
 210:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 653              		.loc 3 210 0
 654 01b8 18319FE5 		ldr	r3, .L46+4
 655 01bc 00C093E5 		ldr	ip, [r3, #0]
 656 01c0 B830DCE1 		ldrh	r3, [ip, #8]
 657 01c4 173043E2 		sub	r3, r3, #23
 658 01c8 0338A0E1 		mov	r3, r3, asl #16
 659 01cc 2338A0E1 		mov	r3, r3, lsr #16
 211:layer1/prim_fbsb.c **** 	qbits = last_fb->toa * 4;
 660              		.loc 3 211 0
 661 01d0 0328A0E1 		mov	r2, r3, asl #16
 662 01d4 4207A0E1 		mov	r0, r2, asr #14
 663              	.LVL24:
 212:layer1/prim_fbsb.c **** 	fn_offset = l1s.current_time.fn; // TODO
 213:layer1/prim_fbsb.c **** 
 214:layer1/prim_fbsb.c **** 	if (qbits > QBITS_PER_TDMA) {
 664              		.loc 3 214 0
 665 01d8 18219FE5 		ldr	r2, .L46+36
 666 01dc 020050E1 		cmp	r0, r2
 215:layer1/prim_fbsb.c **** 		qbits -= QBITS_PER_TDMA;
 667              		.loc 3 215 0
 668 01e0 4E0D40C2 		subgt	r0, r0, #4992
 669              		.loc 3 210 0
 670 01e4 B830CCE1 		strh	r3, [ip, #8]	@ movhi
 671              		.loc 3 215 0
 672 01e8 080040C2 		subgt	r0, r0, #8
 673              		.loc 3 214 0
 674 01ec 7D0000CA 		bgt	.L28
 216:layer1/prim_fbsb.c **** 		fn_offset -= 1;
 217:layer1/prim_fbsb.c **** 	} else if (qbits < 0)  {
 675              		.loc 3 217 0
 676 01f0 000050E3 		cmp	r0, #0
 218:layer1/prim_fbsb.c **** 		qbits += QBITS_PER_TDMA;
 677              		.loc 3 218 0
 678 01f4 4E0D80B2 		addlt	r0, r0, #4992
 679 01f8 080080B2 		addlt	r0, r0, #8
 680              	.L28:
 219:layer1/prim_fbsb.c **** 		fn_offset += 1;
 220:layer1/prim_fbsb.c **** 	}
 221:layer1/prim_fbsb.c **** 
 222:layer1/prim_fbsb.c **** 	fnr_delta = last_fb->fnr_report - attempt;
 681              		.loc 3 222 0
 682 01fc 00109CE5 		ldr	r1, [ip, #0]
 223:layer1/prim_fbsb.c **** 	bits_delta = fnr_delta * BITS_PER_TDMA;
 683              		.loc 3 223 0
 684 0200 F4309FE5 		ldr	r3, .L46+40
 685              		.loc 3 222 0
 686 0204 011066E0 		rsb	r1, r6, r1
 687              	.LVL25:
 688              		.loc 3 223 0
 689 0208 91030EE0 		mul	lr, r1, r3
 690              	.LVL26:
 224:layer1/prim_fbsb.c **** 
 225:layer1/prim_fbsb.c **** 	cinfo->fn_offset = fnr_delta;
 226:layer1/prim_fbsb.c **** 	cinfo->time_alignment = qbits;
 227:layer1/prim_fbsb.c **** 	cinfo->arfcn = rf_arfcn;
 691              		.loc 3 227 0
 692 020c D4309FE5 		ldr	r3, .L46+20
 693              		.loc 3 225 0
 694 0210 CC209FE5 		ldr	r2, .L46+16
 695              		.loc 3 227 0
 696 0214 B030D3E1 		ldrh	r3, [r3, #0]
 697 0218 B831C2E1 		strh	r3, [r2, #24]	@ movhi
 228:layer1/prim_fbsb.c **** 
 229:layer1/prim_fbsb.c **** 	if (last_fb->toa > bits_delta)
 698              		.loc 3 229 0
 699 021c F830DCE1 		ldrsh	r3, [ip, #8]
 700 0220 0E0053E1 		cmp	r3, lr
 701              		.loc 3 225 0
 702 0224 1C1082E5 		str	r1, [r2, #28]
 703              		.loc 3 226 0
 704 0228 200082E5 		str	r0, [r2, #32]
 230:layer1/prim_fbsb.c **** 		printf("=> DSP reports SB in bit that is %d bits in the "
 705              		.loc 3 230 0
 706 022c 03106EC0 		rsbgt	r1, lr, r3
 707              	.LVL27:
 231:layer1/prim_fbsb.c **** 			"future?!?\n", last_fb->toa - bits_delta);
 232:layer1/prim_fbsb.c **** 	else
 233:layer1/prim_fbsb.c **** 		printf(" qbits=%u\n", qbits);
 708              		.loc 3 233 0
 709 0230 0010A0D1 		movle	r1, r0
 710              		.loc 3 230 0
 711 0234 C4009FC5 		ldrgt	r0, .L46+44
 712              	.LVL28:
 713              		.loc 3 233 0
 714 0238 C4009FD5 		ldrle	r0, .L46+48
 715 023c FEFFFFEB 		bl	printf
 716              	.LVL29:
 234:layer1/prim_fbsb.c **** 
 235:layer1/prim_fbsb.c **** 	synchronize_tdma(&l1s.serving_cell);
 717              		.loc 3 235 0
 718 0240 C0009FE5 		ldr	r0, .L46+52
 719 0244 FEFFFFEB 		bl	synchronize_tdma
 236:layer1/prim_fbsb.c **** 
 237:layer1/prim_fbsb.c **** 	/* if we have received a SYNC burst, update our local GSM time */
 238:layer1/prim_fbsb.c **** 	gsm_fn2gsmtime(&l1s.current_time, fbs.mon.time.fn + SB2_LATENCY);
 720              		.loc 3 238 0
 721 0248 A0309FE5 		ldr	r3, .L46+28
 722 024c 90409FE5 		ldr	r4, .L46+16
 723 0250 141093E5 		ldr	r1, [r3, #20]
 724 0254 0400A0E1 		mov	r0, r4
 725 0258 021081E2 		add	r1, r1, #2
 726 025c FEFFFFEB 		bl	gsm_fn2gsmtime
 239:layer1/prim_fbsb.c **** 	/* compute next time from new current time */
 240:layer1/prim_fbsb.c **** 	l1s.next_time = l1s.current_time;
 727              		.loc 3 240 0
 728 0260 070094E8 		ldmia	r4, {r0, r1, r2}
 729 0264 0C3084E2 		add	r3, r4, #12
 730 0268 070083E8 		stmia	r3, {r0, r1, r2}
 241:layer1/prim_fbsb.c **** 	l1s_time_inc(&l1s.next_time, 1);
 731              		.loc 3 241 0
 732 026c 0300A0E1 		mov	r0, r3
 733 0270 0110A0E3 		mov	r1, #1
 734 0274 FEFFFFEB 		bl	l1s_time_inc
 242:layer1/prim_fbsb.c **** 
 243:layer1/prim_fbsb.c **** 	/* If we call tdma_sched_reset(), which is only needed if there
 244:layer1/prim_fbsb.c **** 	 * are further l1s_sbdet_resp() scheduled, we will bring
 245:layer1/prim_fbsb.c **** 	 * dsp_api.db_r and dsp_api.db_w out of sync because we changed
 246:layer1/prim_fbsb.c **** 	 * dsp_api.db_w for l1s_sbdet_cmd() and canceled
 247:layer1/prim_fbsb.c **** 	 * l1s_sbdet_resp() which would change dsp_api.db_r. The DSP
 248:layer1/prim_fbsb.c **** 	 * however expects dsp_api.db_w and dsp_api.db_r to be in sync
 249:layer1/prim_fbsb.c **** 	 * (either "0 - 0" or "1 - 1"). So we have to bring dsp_api.db_w
 250:layer1/prim_fbsb.c **** 	 * and dsp_api.db_r into sync again, otherwise NB reading will
 251:layer1/prim_fbsb.c **** 	 * complain. We probably don't need the Abort command and could
 252:layer1/prim_fbsb.c **** 	 * just bring dsp_api.db_w and dsp_api.db_r into sync.  */
 253:layer1/prim_fbsb.c **** 	if (attempt != 2) {
 735              		.loc 3 253 0
 736 0278 020056E3 		cmp	r6, #2
 737 027c A000000A 		beq	.L33
 254:layer1/prim_fbsb.c **** 		tdma_sched_reset();
 738              		.loc 3 254 0
 739 0280 FEFFFFEB 		bl	tdma_sched_reset
 255:layer1/prim_fbsb.c **** 		l1s_dsp_abort();
 740              		.loc 3 255 0
 741 0284 FEFFFFEB 		bl	l1s_dsp_abort
 742              	.L33:
 256:layer1/prim_fbsb.c **** 	}
 257:layer1/prim_fbsb.c **** 
 258:layer1/prim_fbsb.c **** 	l1s_reset_hw();
 743              		.loc 3 258 0
 744 0288 FEFFFFEB 		bl	l1s_reset_hw
 259:layer1/prim_fbsb.c **** 	/* enable the MF Task for BCCH reading */
 260:layer1/prim_fbsb.c **** 	mframe_enable(MF_TASK_BCCH_NORM);
 745              		.loc 3 260 0
 746 028c 0000A0E3 		mov	r0, #0
 747 0290 FEFFFFEB 		bl	mframe_enable
 261:layer1/prim_fbsb.c **** 	if (l1s.serving_cell.ccch_mode == CCCH_MODE_COMBINED)
 748              		.loc 3 261 0
 749 0294 1B00D4E5 		ldrb	r0, [r4, #27]	@ zero_extendqisi2
 750 0298 020050E3 		cmp	r0, #2
 751 029c A800000A 		beq	.L45
 262:layer1/prim_fbsb.c **** 		mframe_enable(MF_TASK_CCCH_COMB);
 263:layer1/prim_fbsb.c **** 	else if (l1s.serving_cell.ccch_mode == CCCH_MODE_NON_COMBINED)
 752              		.loc 3 263 0
 753 02a0 010050E3 		cmp	r0, #1
 754 02a4 AA00001A 		bne	.L38
 755              	.L45:
 264:layer1/prim_fbsb.c **** 		mframe_enable(MF_TASK_CCCH);
 756              		.loc 3 264 0
 757 02a8 010080E2 		add	r0, r0, #1
 758 02ac AE0000EA 		b	.L44
 759              	.L38:
 265:layer1/prim_fbsb.c **** 	else if (l1s.serving_cell.ccch_mode == CCCH_MODE_COMBINED_CBCH) {
 760              		.loc 3 265 0
 761 02b0 030050E3 		cmp	r0, #3
 762 02b4 AF00001A 		bne	.L37
 266:layer1/prim_fbsb.c **** 		mframe_enable(MF_TASK_CCCH_COMB);
 763              		.loc 3 266 0
 764 02b8 FEFFFFEB 		bl	mframe_enable
 267:layer1/prim_fbsb.c **** 		mframe_enable(MF_TASK_SDCCH4_CBCH);
 765              		.loc 3 267 0
 766 02bc 1000A0E3 		mov	r0, #16
 767              	.L44:
 768 02c0 FEFFFFEB 		bl	mframe_enable
 769              	.LVL30:
 770              	.L37:
 268:layer1/prim_fbsb.c **** 	}
 269:layer1/prim_fbsb.c **** 
 270:layer1/prim_fbsb.c **** 	l1s_compl_sched(L1_COMPL_FB);
 771              		.loc 3 270 0
 772 02c4 0000A0E3 		mov	r0, #0
 773              	.LVL31:
 774 02c8 FEFFFFEB 		bl	l1s_compl_sched
 775              	.LVL32:
 776              	.L21:
 271:layer1/prim_fbsb.c **** 
 272:layer1/prim_fbsb.c **** 	return 0;
 273:layer1/prim_fbsb.c **** }
 777              		.loc 3 273 0
 778 02cc 0000A0E3 		mov	r0, #0
 779              	.LVL33:
 780 02d0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 781              	.L47:
 782              		.align	2
 783              	.L46:
 784 02d4 00000000 		.word	dsp_api
 785 02d8 00000000 		.word	last_fb
 786 02dc 64000000 		.word	.LC2
 787 02e0 C0500100 		.word	86208
 788 02e4 00000000 		.word	l1s
 789 02e8 00000000 		.word	rf_arfcn
 790 02ec 14000000 		.word	fbs+20
 791 02f0 00000000 		.word	fbs
 792 02f4 6C000000 		.word	.LC3
 793 02f8 88130000 		.word	5000
 794 02fc E2040000 		.word	1250
 795 0300 84000000 		.word	.LC4
 796 0304 C0000000 		.word	.LC5
 797 0308 18000000 		.word	l1s+24
 798              	.LFE71:
 800              		.section	.text.l1s_sbdet_cmd,"ax",%progbits
 801              		.align	2
 803              	l1s_sbdet_cmd:
 804              	.LFB72:
 274:layer1/prim_fbsb.c **** 
 275:layer1/prim_fbsb.c **** static int l1s_sbdet_cmd(__unused uint8_t p1, __unused uint8_t p2,
 276:layer1/prim_fbsb.c **** 			 __unused uint16_t p3)
 277:layer1/prim_fbsb.c **** {
 805              		.loc 3 277 0
 806              		@ args = 0, pretend = 0, frame = 0
 807              		@ frame_needed = 0, uses_anonymous_args = 0
 808              	.LVL34:
 809 0000 10402DE9 		stmfd	sp!, {r4, lr}
 810              	.LCFI4:
 278:layer1/prim_fbsb.c **** 	putchart('S');
 279:layer1/prim_fbsb.c **** 
 280:layer1/prim_fbsb.c **** 	fbs.mon.bsic = 0;
 281:layer1/prim_fbsb.c **** 	fbs.mon.time.fn = 0;
 282:layer1/prim_fbsb.c **** 
 283:layer1/prim_fbsb.c **** 	dsp_api.db_w->d_task_md = SB_DSP_TASK;
 811              		.loc 3 283 0
 812 0004 3C309FE5 		ldr	r3, .L50
 813              		.loc 3 280 0
 814 0008 3CC09FE5 		ldr	ip, .L50+4
 284:layer1/prim_fbsb.c **** 	dsp_api.ndb->d_fb_mode = 0; /* wideband search */
 815              		.loc 3 284 0
 816 000c 002093E5 		ldr	r2, [r3, #0]
 817              	.LVL35:
 818              		.loc 3 283 0
 819 0010 083093E5 		ldr	r3, [r3, #8]
 820              		.loc 3 280 0
 821 0014 0040A0E3 		mov	r4, #0
 822              		.loc 3 283 0
 823 0018 0610A0E3 		mov	r1, #6	@ movhi
 824              	.LVL36:
 825              		.loc 3 280 0
 826 001c 1240CCE5 		strb	r4, [ip, #18]
 827              		.loc 3 283 0
 828 0020 B810C3E1 		strh	r1, [r3, #8]	@ movhi
 829              		.loc 3 284 0
 830 0024 BA44C2E1 		strh	r4, [r2, #74]	@ movhi
 285:layer1/prim_fbsb.c **** 
 286:layer1/prim_fbsb.c **** 	/* Program TPU */
 287:layer1/prim_fbsb.c **** 	l1s_rx_win_ctrl(rf_arfcn, L1_RXWIN_SB, 0);
 831              		.loc 3 287 0
 832 0028 20309FE5 		ldr	r3, .L50+8
 833 002c 0210A0E3 		mov	r1, #2
 834 0030 B000D3E1 		ldrh	r0, [r3, #0]
 835              	.LVL37:
 836 0034 0420A0E1 		mov	r2, r4
 837              		.loc 3 281 0
 838 0038 14408CE5 		str	r4, [ip, #20]
 839              		.loc 3 287 0
 840 003c FEFFFFEB 		bl	l1s_rx_win_ctrl
 288:layer1/prim_fbsb.c **** 
 289:layer1/prim_fbsb.c **** 	return 0;
 290:layer1/prim_fbsb.c **** }
 841              		.loc 3 290 0
 842 0040 0400A0E1 		mov	r0, r4
 843 0044 1080BDE8 		ldmfd	sp!, {r4, pc}
 844              	.L51:
 845              		.align	2
 846              	.L50:
 847 0048 00000000 		.word	dsp_api
 848 004c 00000000 		.word	fbs
 849 0050 00000000 		.word	rf_arfcn
 850              	.LFE72:
 852              		.section	.text.l1s_sb_test,"ax",%progbits
 853              		.align	2
 854              		.global	l1s_sb_test
 856              	l1s_sb_test:
 857              	.LFB73:
 291:layer1/prim_fbsb.c **** 
 292:layer1/prim_fbsb.c **** /* This is how it is done by the TSM30 */
 293:layer1/prim_fbsb.c **** static const struct tdma_sched_item sb_sched_set[] = {
 294:layer1/prim_fbsb.c **** 	SCHED_ITEM_DT(l1s_sbdet_cmd, 0, 0, 1),	SCHED_END_FRAME(),
 295:layer1/prim_fbsb.c **** 	SCHED_ITEM_DT(l1s_sbdet_cmd, 0, 0, 2),	SCHED_END_FRAME(),
 296:layer1/prim_fbsb.c **** 						SCHED_END_FRAME(),
 297:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_sbdet_resp, -4, 0, 1),	SCHED_END_FRAME(),
 298:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_sbdet_resp, -4, 0, 2),	SCHED_END_FRAME(),
 299:layer1/prim_fbsb.c **** 	SCHED_END_SET()
 300:layer1/prim_fbsb.c **** };
 301:layer1/prim_fbsb.c **** 
 302:layer1/prim_fbsb.c **** void l1s_sb_test(uint8_t base_fn)
 303:layer1/prim_fbsb.c **** {
 858              		.loc 3 303 0
 859              		@ args = 0, pretend = 0, frame = 0
 860              		@ frame_needed = 0, uses_anonymous_args = 0
 861              		@ link register save eliminated.
 862              	.LVL38:
 304:layer1/prim_fbsb.c **** 	tdma_schedule_set(base_fn, sb_sched_set, 0);
 863              		.loc 3 304 0
 864 0000 08109FE5 		ldr	r1, .L54
 865              		.loc 3 303 0
 866 0004 FF0000E2 		and	r0, r0, #255
 867              		.loc 3 304 0
 868 0008 0020A0E3 		mov	r2, #0
 869              		.loc 3 303 0
 870              		@ lr needed for prologue
 305:layer1/prim_fbsb.c **** }
 871              		.loc 3 305 0
 872              		.loc 3 304 0
 873 000c FEFFFFEA 		b	tdma_schedule_set
 874              	.LVL39:
 875              	.L55:
 876              		.align	2
 877              	.L54:
 878 0010 00000000 		.word	sb_sched_set
 879              	.LFE73:
 881              		.global	__divsi3
 882              		.section	.rodata.str1.4
 883 00cb 00       		.align	2
 884              	.LC6:
 885 00cc 3D3E2044 		.ascii	"=> DSP reports FB in bit that is %d bits in the fut"
 885      53502072 
 885      65706F72 
 885      74732046 
 885      4220696E 
 886 00ff 7572653F 		.ascii	"ure?!?\012\000"
 886      213F0A00 
 887 0107 00       		.align	2
 888              	.LC7:
 889 0108 3D3E4642 		.ascii	"=>FB @ FNR %u fn_offset=%d qbits=%u\012\000"
 889      20402046 
 889      4E522025 
 889      7520666E 
 889      5F6F6666 
 890              		.section	.text.fbinfo2cellinfo,"ax",%progbits
 891              		.align	2
 893              	fbinfo2cellinfo:
 894              	.LFB75:
 306:layer1/prim_fbsb.c **** /* FCCH Burst *****************************************************************/
 307:layer1/prim_fbsb.c **** 
 308:layer1/prim_fbsb.c **** static int read_fb_result(struct mon_state *st, int attempt)
 309:layer1/prim_fbsb.c **** {
 310:layer1/prim_fbsb.c **** 	st->toa = dsp_api.ndb->a_sync_demod[D_TOA];
 311:layer1/prim_fbsb.c **** 	st->pm = dsp_api.ndb->a_sync_demod[D_PM]>>3;
 312:layer1/prim_fbsb.c **** 	st->angle = dsp_api.ndb->a_sync_demod[D_ANGLE];
 313:layer1/prim_fbsb.c **** 	st->snr = dsp_api.ndb->a_sync_demod[D_SNR];
 314:layer1/prim_fbsb.c **** 
 315:layer1/prim_fbsb.c **** 	//last_fb->angle = clip_int16(last_fb->angle, AFC_MAX_ANGLE);
 316:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(last_fb->angle);
 317:layer1/prim_fbsb.c **** 	st->fnr_report = l1s.current_time.fn;
 318:layer1/prim_fbsb.c **** 	st->attempt = attempt;
 319:layer1/prim_fbsb.c **** 
 320:layer1/prim_fbsb.c **** 	dump_mon_state(st);
 321:layer1/prim_fbsb.c **** 
 322:layer1/prim_fbsb.c **** 	dsp_api.ndb->d_fb_det = 0;
 323:layer1/prim_fbsb.c **** 	dsp_api.ndb->a_sync_demod[D_TOA] = 0; /* TSM30 does it (really needed ?) */
 324:layer1/prim_fbsb.c **** 
 325:layer1/prim_fbsb.c **** 	/* Update AFC with current frequency offset */
 326:layer1/prim_fbsb.c **** 	afc_correct(st->freq_diff, rf_arfcn);
 327:layer1/prim_fbsb.c **** 
 328:layer1/prim_fbsb.c **** 	//tpu_dsp_frameirq_enable();
 329:layer1/prim_fbsb.c **** 	return 1;
 330:layer1/prim_fbsb.c **** }
 331:layer1/prim_fbsb.c **** 
 332:layer1/prim_fbsb.c **** static void fbinfo2cellinfo(struct l1_cell_info *cinfo,
 333:layer1/prim_fbsb.c **** 			    const struct mon_state *mon)
 334:layer1/prim_fbsb.c **** {
 895              		.loc 3 334 0
 896              		@ args = 0, pretend = 0, frame = 0
 897              		@ frame_needed = 0, uses_anonymous_args = 0
 898              	.LVL40:
 899 0000 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 900              	.LCFI5:
 335:layer1/prim_fbsb.c **** 	int ntdma, qbits, fn_offset, fnr_delta, bits_delta;
 336:layer1/prim_fbsb.c **** 
 337:layer1/prim_fbsb.c **** 	/* FIXME: where did this magic 23 come from? */
 338:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 901              		.loc 3 338 0
 902 0004 D4309FE5 		ldr	r3, .L64
 903 0008 005093E5 		ldr	r5, [r3, #0]
 904 000c B820D5E1 		ldrh	r2, [r5, #8]
 905 0010 172042E2 		sub	r2, r2, #23
 906 0014 0228A0E1 		mov	r2, r2, asl #16
 907 0018 2228A0E1 		mov	r2, r2, lsr #16
 339:layer1/prim_fbsb.c **** 
 340:layer1/prim_fbsb.c **** 	if (last_fb->toa < 0) {
 908              		.loc 3 340 0
 909 001c 0238A0E1 		mov	r3, r2, asl #16
 910 0020 4348B0E1 		movs	r4, r3, asr #16
 341:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa + BITS_PER_TDMA) * 4;
 342:layer1/prim_fbsb.c **** 		ntdma = -1;
 343:layer1/prim_fbsb.c **** 	} else {
 344:layer1/prim_fbsb.c **** 		ntdma = (last_fb->toa) / BITS_PER_TDMA;
 911              		.loc 3 344 0
 912 0024 B8A09FE5 		ldr	sl, .L64+4
 913              		.loc 3 341 0
 914 0028 0431A0E1 		mov	r3, r4, asl #2
 915 002c 4E6D83E2 		add	r6, r3, #4992
 916              	.LVL41:
 917              		.loc 3 334 0
 918 0030 0070A0E1 		mov	r7, r0
 919              		.loc 3 344 0
 920 0034 0A10A0E1 		mov	r1, sl
 921              	.LVL42:
 922              		.loc 3 341 0
 923 0038 086086E2 		add	r6, r6, #8
 924 003c 0080E0E3 		mvn	r8, #0
 925              	.LVL43:
 926              		.loc 3 344 0
 927 0040 0400A0E1 		mov	r0, r4
 928              	.LVL44:
 929              		.loc 3 338 0
 930 0044 B820C5E1 		strh	r2, [r5, #8]	@ movhi
 931              		.loc 3 340 0
 932 0048 1700004A 		bmi	.L59
 933              		.loc 3 344 0
 934 004c FEFFFFEB 		bl	__divsi3
 935 0050 0008A0E1 		mov	r0, r0, asl #16
 936 0054 4088A0E1 		mov	r8, r0, asr #16
 345:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa - ntdma * BITS_PER_TDMA) * 4;
 937              		.loc 3 345 0
 938 0058 980A03E0 		mul	r3, r8, sl
 939 005c 043063E0 		rsb	r3, r3, r4
 940 0060 0361A0E1 		mov	r6, r3, asl #2
 941              	.L59:
 346:layer1/prim_fbsb.c **** 	}
 347:layer1/prim_fbsb.c **** 
 348:layer1/prim_fbsb.c **** 	fn_offset = l1s.current_time.fn - last_fb->attempt + ntdma;
 349:layer1/prim_fbsb.c **** 	fnr_delta = last_fb->fnr_report - last_fb->attempt;
 942              		.loc 3 349 0
 943 0064 044095E8 		ldmia	r5, {r2, lr}	@ phole ldm
 350:layer1/prim_fbsb.c **** 	bits_delta = fnr_delta * BITS_PER_TDMA;
 944              		.loc 3 350 0
 945 0068 74309FE5 		ldr	r3, .L64+4
 946              		.loc 3 349 0
 947 006c 02206EE0 		rsb	r2, lr, r2
 948              	.LVL45:
 949              		.loc 3 350 0
 950 0070 920304E0 		mul	r4, r2, r3
 951              	.LVL46:
 952              	.LBB20:
 351:layer1/prim_fbsb.c **** 
 352:layer1/prim_fbsb.c **** 	cinfo->fn_offset = fnr_delta;
 353:layer1/prim_fbsb.c **** 	cinfo->time_alignment = qbits;
 354:layer1/prim_fbsb.c **** 	cinfo->arfcn = rf_arfcn;
 355:layer1/prim_fbsb.c **** 
 356:layer1/prim_fbsb.c **** 	if (last_fb->toa > bits_delta)
 357:layer1/prim_fbsb.c **** 		printf("=> DSP reports FB in bit that is %d bits in "
 358:layer1/prim_fbsb.c **** 			"the future?!?\n", last_fb->toa - bits_delta);
 359:layer1/prim_fbsb.c **** 	else {
 360:layer1/prim_fbsb.c **** 		int fb_fnr = (last_fb->fnr_report - last_fb->attempt)
 361:layer1/prim_fbsb.c **** 				+ last_fb->toa/BITS_PER_TDMA;
 362:layer1/prim_fbsb.c **** 		printf("=>FB @ FNR %u fn_offset=%d qbits=%u\n",
 953              		.loc 3 362 0
 954 0074 0310A0E1 		mov	r1, r3
 955              	.LBE20:
 956              		.loc 3 354 0
 957 0078 68309FE5 		ldr	r3, .L64+8
 958 007c B030D3E1 		ldrh	r3, [r3, #0]
 959 0080 B030C7E1 		strh	r3, [r7, #0]	@ movhi
 960              		.loc 3 348 0
 961 0084 60309FE5 		ldr	r3, .L64+12
 962              		.loc 3 356 0
 963 0088 F8C0D5E1 		ldrsh	ip, [r5, #8]
 964              		.loc 3 348 0
 965 008c 003093E5 		ldr	r3, [r3, #0]
 966              		.loc 3 356 0
 967 0090 04005CE1 		cmp	ip, r4
 968              		.loc 3 348 0
 969 0094 03306EE0 		rsb	r3, lr, r3
 970              		.loc 3 357 0
 971 0098 50009FE5 		ldr	r0, .L64+16
 972              		.loc 3 348 0
 973 009c 088083E0 		add	r8, r3, r8
 974              	.LVL47:
 975              		.loc 3 352 0
 976 00a0 440087E9 		stmib	r7, {r2, r6}	@ phole stm
 977              		.loc 3 356 0
 978 00a4 2B0000DA 		ble	.L60
 979              		.loc 3 357 0
 980 00a8 0C1064E0 		rsb	r1, r4, ip
 363:layer1/prim_fbsb.c **** 			fb_fnr, fn_offset, qbits);
 364:layer1/prim_fbsb.c **** 	}
 365:layer1/prim_fbsb.c **** }
 981              		.loc 3 365 0
 982 00ac F045BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 983              		.loc 3 357 0
 984 00b0 FEFFFFEA 		b	printf
 985              	.LVL48:
 986              	.L60:
 987              	.LBB21:
 988              		.loc 3 362 0
 989 00b4 004095E5 		ldr	r4, [r5, #0]
 990              	.LVL49:
 991 00b8 0C00A0E1 		mov	r0, ip
 992 00bc 04406EE0 		rsb	r4, lr, r4
 993 00c0 FEFFFFEB 		bl	__divsi3
 994              	.LVL50:
 995 00c4 0018A0E1 		mov	r1, r0, asl #16
 996 00c8 24009FE5 		ldr	r0, .L64+20
 997 00cc 411884E0 		add	r1, r4, r1, asr #16
 998 00d0 0820A0E1 		mov	r2, r8
 999 00d4 0630A0E1 		mov	r3, r6
 1000              	.LBE21:
 1001              		.loc 3 365 0
 1002 00d8 F045BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 1003              	.LBB22:
 1004              		.loc 3 362 0
 1005 00dc FEFFFFEA 		b	printf
 1006              	.L65:
 1007              		.align	2
 1008              	.L64:
 1009 00e0 00000000 		.word	last_fb
 1010 00e4 E2040000 		.word	1250
 1011 00e8 00000000 		.word	rf_arfcn
 1012 00ec 00000000 		.word	l1s
 1013 00f0 CC000000 		.word	.LC6
 1014 00f4 08010000 		.word	.LC7
 1015              	.LBE22:
 1016              	.LFE75:
 1018              		.section	.text.l1s_fbdet_cmd,"ax",%progbits
 1019              		.align	2
 1021              	l1s_fbdet_cmd:
 1022              	.LFB76:
 366:layer1/prim_fbsb.c **** 
 367:layer1/prim_fbsb.c **** /* scheduler callback to issue a FB detection task to the DSP */
 368:layer1/prim_fbsb.c **** static int l1s_fbdet_cmd(__unused uint8_t p1, __unused uint8_t p2,
 369:layer1/prim_fbsb.c **** 			 uint16_t fb_mode)
 370:layer1/prim_fbsb.c **** {
 1023              		.loc 3 370 0
 1024              		@ args = 0, pretend = 0, frame = 0
 1025              		@ frame_needed = 0, uses_anonymous_args = 0
 1026              	.LVL51:
 1027 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 1028              	.LCFI6:
 371:layer1/prim_fbsb.c **** 	if (fb_mode == 0) {
 372:layer1/prim_fbsb.c **** 		putchart('F');
 373:layer1/prim_fbsb.c **** 	} else {
 374:layer1/prim_fbsb.c **** 		putchart('V');
 375:layer1/prim_fbsb.c **** 	}
 376:layer1/prim_fbsb.c **** 
 377:layer1/prim_fbsb.c **** 	l1s.fb.mode = fb_mode;
 1029              		.loc 3 377 0
 1030 0004 54309FE5 		ldr	r3, .L68
 1031              		.loc 3 370 0
 1032 0008 0248A0E1 		mov	r4, r2, asl #16
 378:layer1/prim_fbsb.c **** 
 379:layer1/prim_fbsb.c **** 	/* Tell the RF frontend to set the gain appropriately */
 380:layer1/prim_fbsb.c **** 	rffe_compute_gain(rxlev2dbm(fbs.req.rxlev_exp), CAL_DSP_TGT_BB_LVL);
 1033              		.loc 3 380 0
 1034 000c 50509FE5 		ldr	r5, .L68+4
 1035              		.loc 3 370 0
 1036 0010 2448A0E1 		mov	r4, r4, lsr #16
 1037              		.loc 3 377 0
 1038 0014 F44AC3E5 		strb	r4, [r3, #2804]
 1039              		.loc 3 380 0
 1040 0018 2C00D5E5 		ldrb	r0, [r5, #44]	@ zero_extendqisi2
 1041              	.LVL52:
 1042 001c FEFFFFEB 		bl	rxlev2dbm
 1043              	.LVL53:
 1044 0020 0008A0E1 		mov	r0, r0, asl #16
 1045 0024 4008A0E1 		mov	r0, r0, asr #16
 1046 0028 5010A0E3 		mov	r1, #80
 1047 002c FEFFFFEB 		bl	rffe_compute_gain
 381:layer1/prim_fbsb.c **** 
 382:layer1/prim_fbsb.c **** 	/* Program DSP */
 383:layer1/prim_fbsb.c **** 	dsp_api.db_w->d_task_md = FB_DSP_TASK;	/* maybe with I/Q swap? */
 1048              		.loc 3 383 0
 1049 0030 30309FE5 		ldr	r3, .L68+8
 384:layer1/prim_fbsb.c **** 	dsp_api.ndb->d_fb_mode = fb_mode;
 1050              		.loc 3 384 0
 1051 0034 002093E5 		ldr	r2, [r3, #0]
 1052              		.loc 3 383 0
 1053 0038 083093E5 		ldr	r3, [r3, #8]
 1054 003c 0510A0E3 		mov	r1, #5	@ movhi
 1055 0040 B810C3E1 		strh	r1, [r3, #8]	@ movhi
 1056              		.loc 3 384 0
 1057 0044 BA44C2E1 		strh	r4, [r2, #74]	@ movhi
 385:layer1/prim_fbsb.c **** 
 386:layer1/prim_fbsb.c **** 	/* Program TPU */
 387:layer1/prim_fbsb.c **** 	l1s_rx_win_ctrl(fbs.req.band_arfcn, L1_RXWIN_FB, 0);
 1058              		.loc 3 387 0
 1059 0048 0110A0E3 		mov	r1, #1
 1060 004c B002D5E1 		ldrh	r0, [r5, #32]
 1061 0050 0020A0E3 		mov	r2, #0
 1062 0054 FEFFFFEB 		bl	l1s_rx_win_ctrl
 388:layer1/prim_fbsb.c **** 
 389:layer1/prim_fbsb.c **** 	return 0;
 390:layer1/prim_fbsb.c **** }
 1063              		.loc 3 390 0
 1064 0058 0000A0E3 		mov	r0, #0
 1065 005c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 1066              	.L69:
 1067              		.align	2
 1068              	.L68:
 1069 0060 00000000 		.word	l1s
 1070 0064 00000000 		.word	fbs
 1071 0068 00000000 		.word	dsp_api
 1072              	.LFE76:
 1074              		.section	.rodata.str1.4
 1075 012d 000000   		.align	2
 1076              	.LC8:
 1077 0130 46422575 		.ascii	"FB%u \000"
 1077      2000
 1078 0136 0000     		.align	2
 1079              	.LC9:
 1080 0138 2020666E 		.ascii	"  fn_offset=%d (fn=%lu + attempt=%u + ntdma = %d)\012"
 1080      5F6F6666 
 1080      7365743D 
 1080      25642028 
 1080      666E3D25 
 1081 016a 00       		.ascii	"\000"
 1082 016b 00       		.align	2
 1083              	.LC10:
 1084 016c 20206465 		.ascii	"  delay=%d (fn_offset=%d + 11 - fn=%lu - 1\012\000"
 1084      6C61793D 
 1084      25642028 
 1084      666E5F6F 
 1084      66667365 
 1085              		.align	2
 1086              	.LC11:
 1087 0198 20207363 		.ascii	"  scheduling next FB/SB detection task with delay %"
 1087      68656475 
 1087      6C696E67 
 1087      206E6578 
 1087      74204642 
 1088 01cb 750A00   		.ascii	"u\012\000"
 1089 01ce 0000     		.section	.text.l1s_fbdet_resp,"ax",%progbits
 1090              		.align	2
 1092              	l1s_fbdet_resp:
 1093              	.LFB77:
 391:layer1/prim_fbsb.c **** 
 392:layer1/prim_fbsb.c **** #if 0
 393:layer1/prim_fbsb.c **** #define FB0_SNR_THRESH	2000
 394:layer1/prim_fbsb.c **** #define FB1_SNR_THRESH	3000
 395:layer1/prim_fbsb.c **** #else
 396:layer1/prim_fbsb.c **** #define FB0_SNR_THRESH	0
 397:layer1/prim_fbsb.c **** #define FB1_SNR_THRESH	0
 398:layer1/prim_fbsb.c **** #endif
 399:layer1/prim_fbsb.c **** 
 400:layer1/prim_fbsb.c **** static const struct tdma_sched_item fb_sched_set[];
 401:layer1/prim_fbsb.c **** 
 402:layer1/prim_fbsb.c **** /* scheduler callback to check for a FB detection response */
 403:layer1/prim_fbsb.c **** static int l1s_fbdet_resp(__unused uint8_t p1, uint8_t attempt,
 404:layer1/prim_fbsb.c **** 			  uint16_t fb_mode)
 405:layer1/prim_fbsb.c **** {
 1094              		.loc 3 405 0
 1095              		@ args = 0, pretend = 0, frame = 0
 1096              		@ frame_needed = 0, uses_anonymous_args = 0
 1097              	.LVL54:
 1098 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 1099              	.LCFI7:
 406:layer1/prim_fbsb.c **** 	putchart('f');
 407:layer1/prim_fbsb.c **** 
 408:layer1/prim_fbsb.c **** 	if (!dsp_api.ndb->d_fb_det) {
 1100              		.loc 3 408 0
 1101 0004 C4529FE5 		ldr	r5, .L99
 1102 0008 003095E5 		ldr	r3, [r5, #0]
 1103 000c B844D3E1 		ldrh	r4, [r3, #72]
 1104              		.loc 3 405 0
 1105 0010 0228A0E1 		mov	r2, r2, asl #16
 1106              	.LVL55:
 1107              		.loc 3 408 0
 1108 0014 000054E3 		cmp	r4, #0
 1109              		.loc 3 405 0
 1110 0018 04D04DE2 		sub	sp, sp, #4
 1111              	.LCFI8:
 1112              	.LVL56:
 1113              		.loc 3 405 0
 1114 001c FF7001E2 		and	r7, r1, #255
 1115 0020 2268A0E1 		mov	r6, r2, lsr #16
 1116              	.LVL57:
 1117              		.loc 3 408 0
 1118 0024 1D00001A 		bne	.L71
 1119              	.LVL58:
 409:layer1/prim_fbsb.c **** 		/* we did not detect a FB */
 410:layer1/prim_fbsb.c **** 
 411:layer1/prim_fbsb.c **** 		/* attempt < 12, do nothing */
 412:layer1/prim_fbsb.c **** 		if (attempt < 12)
 1120              		.loc 3 412 0
 1121 0028 0B0057E3 		cmp	r7, #11
 1122 002c AF00009A 		bls	.L73
 413:layer1/prim_fbsb.c **** 			return 0;
 414:layer1/prim_fbsb.c **** 
 415:layer1/prim_fbsb.c **** 		/* attempt >= 12, we simply don't find one */
 416:layer1/prim_fbsb.c **** 
 417:layer1/prim_fbsb.c **** 		/* If we don't reset here, we get DSP DMA errors */
 418:layer1/prim_fbsb.c **** 		tdma_sched_reset();
 419:layer1/prim_fbsb.c **** 
 420:layer1/prim_fbsb.c **** 		if (fbs.fb_retries < FB0_RETRY_COUNT) {
 1123              		.loc 3 420 0
 1124 0030 9C529FE5 		ldr	r5, .L99+4
 1125              		.loc 3 418 0
 1126 0034 FEFFFFEB 		bl	tdma_sched_reset
 1127              	.LVL59:
 1128              		.loc 3 420 0
 1129 0038 3030D5E5 		ldrb	r3, [r5, #48]	@ zero_extendqisi2
 1130 003c 020053E3 		cmp	r3, #2
 1131 0040 1700008A 		bhi	.L75
 421:layer1/prim_fbsb.c **** 			/* retry once more */
 422:layer1/prim_fbsb.c **** 			tdma_schedule_set(1, fb_sched_set, 0);
 1132              		.loc 3 422 0
 1133 0044 0420A0E1 		mov	r2, r4
 1134 0048 0100A0E3 		mov	r0, #1
 1135 004c 84129FE5 		ldr	r1, .L99+8
 1136 0050 FEFFFFEB 		bl	tdma_schedule_set
 423:layer1/prim_fbsb.c **** 			fbs.fb_retries++;
 1137              		.loc 3 423 0
 1138 0054 3030D5E5 		ldrb	r3, [r5, #48]	@ zero_extendqisi2
 1139 0058 013083E2 		add	r3, r3, #1
 1140 005c 3030C5E5 		strb	r3, [r5, #48]
 1141 0060 AF0000EA 		b	.L73
 1142              	.L75:
 424:layer1/prim_fbsb.c **** 		} else {
 425:layer1/prim_fbsb.c **** 			last_fb->attempt = 13;
 1143              		.loc 3 425 0
 1144 0064 70329FE5 		ldr	r3, .L99+12
 1145 0068 002093E5 		ldr	r2, [r3, #0]
 426:layer1/prim_fbsb.c **** 			l1s_compl_sched(L1_COMPL_FB);
 1146              		.loc 3 426 0
 1147 006c 0400A0E1 		mov	r0, r4
 1148              		.loc 3 425 0
 1149 0070 0D30A0E3 		mov	r3, #13
 1150 0074 043082E5 		str	r3, [r2, #4]
 1151 0078 AE0000EA 		b	.L89
 1152              	.LVL60:
 1153              	.L71:
 427:layer1/prim_fbsb.c **** 		}
 428:layer1/prim_fbsb.c **** 
 429:layer1/prim_fbsb.c **** 		return 0;
 430:layer1/prim_fbsb.c **** 	}
 431:layer1/prim_fbsb.c **** 
 432:layer1/prim_fbsb.c **** 	/* We found a frequency burst, reset everything */
 433:layer1/prim_fbsb.c **** 	l1s_reset_hw();
 1154              		.loc 3 433 0
 1155 007c FEFFFFEB 		bl	l1s_reset_hw
 1156              	.LVL61:
 434:layer1/prim_fbsb.c **** 
 435:layer1/prim_fbsb.c **** 	printf("FB%u ", dsp_api.ndb->d_fb_mode);
 1157              		.loc 3 435 0
 1158 0080 003095E5 		ldr	r3, [r5, #0]
 1159 0084 54029FE5 		ldr	r0, .L99+16
 1160 0088 BA14D3E1 		ldrh	r1, [r3, #74]
 1161 008c FEFFFFEB 		bl	printf
 436:layer1/prim_fbsb.c **** 	read_fb_result(last_fb, attempt);
 1162              		.loc 3 436 0
 1163 0090 44829FE5 		ldr	r8, .L99+12
 1164              	.LBB23:
 1165              	.LBB24:
 1166              		.loc 3 310 0
 1167 0094 001095E5 		ldr	r1, [r5, #0]
 1168              	.LBE24:
 1169              	.LBE23:
 1170              		.loc 3 436 0
 1171 0098 004098E5 		ldr	r4, [r8, #0]
 1172              	.LVL62:
 1173              	.LBB25:
 1174              	.LBB26:
 1175              		.loc 3 310 0
 1176 009c BC24D1E1 		ldrh	r2, [r1, #76]
 1177 00a0 B820C4E1 		strh	r2, [r4, #8]	@ movhi
 1178              		.loc 3 311 0
 1179 00a4 BE34D1E1 		ldrh	r3, [r1, #78]
 1180 00a8 A331A0E1 		mov	r3, r3, lsr #3
 1181 00ac BA30C4E1 		strh	r3, [r4, #10]	@ movhi
 1182              		.loc 3 312 0
 1183 00b0 B035D1E1 		ldrh	r3, [r1, #80]
 1184 00b4 BC30C4E1 		strh	r3, [r4, #12]	@ movhi
 1185              		.loc 3 316 0
 1186 00b8 24329FE5 		ldr	r3, .L99+20
 1187 00bc FC20D4E1 		ldrsh	r2, [r4, #12]
 1188 00c0 930202E0 		mul	r2, r3, r2
 1189 00c4 FF3C82E2 		add	r3, r2, #65280
 1190 00c8 000052E3 		cmp	r2, #0
 1191 00cc FF3083E2 		add	r3, r3, #255
 1192 00d0 0320A0B1 		movlt	r2, r3
 1193              		.loc 3 317 0
 1194 00d4 0C329FE5 		ldr	r3, .L99+24
 1195              		.loc 3 313 0
 1196 00d8 B215D1E1 		ldrh	r1, [r1, #82]
 1197              		.loc 3 317 0
 1198 00dc 003093E5 		ldr	r3, [r3, #0]
 1199              		.loc 3 316 0
 1200 00e0 4228A0E1 		mov	r2, r2, asr #16
 1201              		.loc 3 313 0
 1202 00e4 BE10C4E1 		strh	r1, [r4, #14]	@ movhi
 1203              		.loc 3 317 0
 1204 00e8 003084E5 		str	r3, [r4, #0]
 1205              		.loc 3 316 0
 1206 00ec B021C4E1 		strh	r2, [r4, #16]	@ movhi
 1207              		.loc 3 320 0
 1208 00f0 0400A0E1 		mov	r0, r4
 1209              		.loc 3 318 0
 1210 00f4 047084E5 		str	r7, [r4, #4]
 1211              		.loc 3 320 0
 1212 00f8 FEFFFFEB 		bl	dump_mon_state
 1213              		.loc 3 322 0
 1214 00fc 003095E5 		ldr	r3, [r5, #0]
 1215              		.loc 3 323 0
 1216 0100 0020A0E3 		mov	r2, #0	@ movhi
 1217 0104 BC24C3E1 		strh	r2, [r3, #76]	@ movhi
 1218              		.loc 3 322 0
 1219 0108 B824C3E1 		strh	r2, [r3, #72]	@ movhi
 1220              		.loc 3 326 0
 1221 010c D8319FE5 		ldr	r3, .L99+28
 1222              	.LBE26:
 1223              	.LBE25:
 437:layer1/prim_fbsb.c **** 
 438:layer1/prim_fbsb.c **** 	/* if this is the first success, save freq err */
 439:layer1/prim_fbsb.c **** 	if (!fbs.initial_freq_err)
 1224              		.loc 3 439 0
 1225 0110 BC519FE5 		ldr	r5, .L99+4
 1226              	.LBB27:
 1227              	.LBB28:
 1228              		.loc 3 326 0
 1229 0114 B010D3E1 		ldrh	r1, [r3, #0]
 1230 0118 F001D4E1 		ldrsh	r0, [r4, #16]
 1231 011c FEFFFFEB 		bl	afc_correct
 1232              	.LBE28:
 1233              	.LBE27:
 1234              		.loc 3 439 0
 1235 0120 FE32D5E1 		ldrsh	r3, [r5, #46]
 1236 0124 000053E3 		cmp	r3, #0
 440:layer1/prim_fbsb.c **** 		fbs.initial_freq_err = last_fb->freq_diff;
 1237              		.loc 3 440 0
 1238 0128 00309805 		ldreq	r3, [r8, #0]
 1239 012c B031D301 		ldreqh	r3, [r3, #16]
 1240 0130 BE32C501 		streqh	r3, [r5, #46]	@ movhi
 441:layer1/prim_fbsb.c **** 
 442:layer1/prim_fbsb.c **** 	/* If we don't reset here, we get DSP DMA errors */
 443:layer1/prim_fbsb.c **** 	tdma_sched_reset();
 1241              		.loc 3 443 0
 1242 0134 FEFFFFEB 		bl	tdma_sched_reset
 444:layer1/prim_fbsb.c **** 
 445:layer1/prim_fbsb.c **** 	/* Immediately schedule further TDMA tasklets, if requested. Doing
 446:layer1/prim_fbsb.c **** 	 * this directly from L1S means we can do this quickly without any
 447:layer1/prim_fbsb.c **** 	 * additional delays */
 448:layer1/prim_fbsb.c **** 	if (fb_mode == 0) {
 1243              		.loc 3 448 0
 1244 0138 000056E3 		cmp	r6, #0
 1245 013c 6F00001A 		bne	.L79
 449:layer1/prim_fbsb.c **** 		if (fbs.req.flags & L1CTL_FBSB_F_FB1) {
 1246              		.loc 3 449 0
 1247 0140 2930D5E5 		ldrb	r3, [r5, #41]	@ zero_extendqisi2
 1248 0144 020013E3 		tst	r3, #2
 450:layer1/prim_fbsb.c **** 			/* If we don't reset here, we get DSP DMA errors */
 451:layer1/prim_fbsb.c **** 			tdma_sched_reset();
 452:layer1/prim_fbsb.c **** 			/* FIXME: don't only use the last but an average */
 453:layer1/prim_fbsb.c **** 			if (abs(last_fb->freq_diff) < fbs.req.freq_err_thresh1 &&
 454:layer1/prim_fbsb.c **** 			    last_fb->snr > FB0_SNR_THRESH) {
 455:layer1/prim_fbsb.c **** 				/* continue with FB1 task in DSP */
 456:layer1/prim_fbsb.c **** 				tdma_schedule_set(1, fb_sched_set, 1);
 457:layer1/prim_fbsb.c **** 			} else {
 458:layer1/prim_fbsb.c **** 				if (fbs.afc_retries < AFC_RETRY_COUNT) {
 459:layer1/prim_fbsb.c **** 					tdma_schedule_set(1, fb_sched_set, 0);
 460:layer1/prim_fbsb.c **** 					fbs.afc_retries++;
 461:layer1/prim_fbsb.c **** 				} else {
 462:layer1/prim_fbsb.c **** 					/* Abort */
 463:layer1/prim_fbsb.c **** 					last_fb->attempt = 13;
 464:layer1/prim_fbsb.c **** 					l1s_compl_sched(L1_COMPL_FB);
 465:layer1/prim_fbsb.c **** 				}
 466:layer1/prim_fbsb.c **** 			}
 467:layer1/prim_fbsb.c **** 		} else
 468:layer1/prim_fbsb.c **** 			l1s_compl_sched(L1_COMPL_FB);
 1249              		.loc 3 468 0
 1250 0148 0600A001 		moveq	r0, r6
 1251              		.loc 3 449 0
 1252 014c AE00000A 		beq	.L89
 1253              	.LVL63:
 1254              		.loc 3 451 0
 1255 0150 FEFFFFEB 		bl	tdma_sched_reset
 1256              	.LVL64:
 1257              		.loc 3 453 0
 1258 0154 004098E5 		ldr	r4, [r8, #0]
 1259              	.LVL65:
 1260 0158 F031D4E1 		ldrsh	r3, [r4, #16]
 1261 015c B422D5E1 		ldrh	r2, [r5, #36]
 1262 0160 000053E3 		cmp	r3, #0
 1263 0164 003063B2 		rsblt	r3, r3, #0
 1264 0168 020053E1 		cmp	r3, r2
 1265 016c 600000AA 		bge	.L83
 1266 0170 BE30D4E1 		ldrh	r3, [r4, #14]
 1267 0174 000053E3 		cmp	r3, #0
 1268              		.loc 3 456 0
 1269 0178 0100A013 		movne	r0, #1
 1270 017c 54119F15 		ldrne	r1, .L99+8
 1271 0180 0020A011 		movne	r2, r0
 1272 0184 AC00001A 		bne	.L98
 1273              	.L83:
 1274              		.loc 3 458 0
 1275 0188 44519FE5 		ldr	r5, .L99+4
 1276 018c 3130D5E5 		ldrb	r3, [r5, #49]	@ zero_extendqisi2
 1277 0190 1D0053E3 		cmp	r3, #29
 1278              		.loc 3 463 0
 1279 0194 0D30A083 		movhi	r3, #13
 1280 0198 04308485 		strhi	r3, [r4, #4]
 1281              		.loc 3 464 0
 1282 019c 0000A083 		movhi	r0, #0
 1283              		.loc 3 458 0
 1284 01a0 AE00008A 		bhi	.L89
 1285              		.loc 3 459 0
 1286 01a4 0100A0E3 		mov	r0, #1
 1287 01a8 28119FE5 		ldr	r1, .L99+8
 1288 01ac 0020A0E3 		mov	r2, #0
 1289 01b0 FEFFFFEB 		bl	tdma_schedule_set
 1290              		.loc 3 460 0
 1291 01b4 3130D5E5 		ldrb	r3, [r5, #49]	@ zero_extendqisi2
 1292 01b8 013083E2 		add	r3, r3, #1
 1293 01bc 3130C5E5 		strb	r3, [r5, #49]
 1294 01c0 AF0000EA 		b	.L73
 1295              	.LVL66:
 1296              	.L79:
 469:layer1/prim_fbsb.c **** 	} else if (fb_mode == 1) {
 1297              		.loc 3 469 0
 1298 01c4 010056E3 		cmp	r6, #1
 1299 01c8 AF00001A 		bne	.L73
 470:layer1/prim_fbsb.c **** 		if (fbs.req.flags & L1CTL_FBSB_F_SB) {
 1300              		.loc 3 470 0
 1301 01cc 2930D5E5 		ldrb	r3, [r5, #41]	@ zero_extendqisi2
 1302 01d0 040013E2 		ands	r0, r3, #4
 1303 01d4 AE00000A 		beq	.L89
 1304              	.LBB29:
 471:layer1/prim_fbsb.c **** 
 472:layer1/prim_fbsb.c **** 	int ntdma, qbits;
 473:layer1/prim_fbsb.c **** 	/* FIXME: where did this magic 23 come from? */
 474:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 1305              		.loc 3 474 0
 1306 01d8 004098E5 		ldr	r4, [r8, #0]
 1307              	.LVL67:
 1308 01dc B830D4E1 		ldrh	r3, [r4, #8]
 1309 01e0 173043E2 		sub	r3, r3, #23
 1310 01e4 0338A0E1 		mov	r3, r3, asl #16
 1311 01e8 2338A0E1 		mov	r3, r3, lsr #16
 475:layer1/prim_fbsb.c **** 
 476:layer1/prim_fbsb.c **** 	if (last_fb->toa < 0) {
 1312              		.loc 3 476 0
 1313 01ec 0328A0E1 		mov	r2, r3, asl #16
 1314 01f0 4208B0E1 		movs	r0, r2, asr #16
 1315              		.loc 3 474 0
 1316 01f4 B830C4E1 		strh	r3, [r4, #8]	@ movhi
 1317              		.loc 3 476 0
 1318 01f8 00C0E043 		mvnmi	ip, #0
 1319              	.LVL68:
 1320 01fc 8200004A 		bmi	.L93
 477:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa + BITS_PER_TDMA) * 4;
 478:layer1/prim_fbsb.c **** 		ntdma = -1;
 479:layer1/prim_fbsb.c **** 	} else {
 480:layer1/prim_fbsb.c **** 		ntdma = (last_fb->toa) / BITS_PER_TDMA;
 1321              		.loc 3 480 0
 1322 0200 E8109FE5 		ldr	r1, .L99+32
 1323 0204 FEFFFFEB 		bl	__divsi3
 1324              	.LVL69:
 1325 0208 0008A0E1 		mov	r0, r0, asl #16
 1326 020c 40C8A0E1 		mov	ip, r0, asr #16
 1327              	.LVL70:
 1328              	.L93:
 481:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa - ntdma * BITS_PER_TDMA) * 4;
 482:layer1/prim_fbsb.c **** 	}
 483:layer1/prim_fbsb.c **** 
 484:layer1/prim_fbsb.c **** 
 485:layer1/prim_fbsb.c **** 			int fn_offset = l1s.current_time.fn - last_fb->attempt + ntdma;
 1329              		.loc 3 485 0
 1330 0210 D0609FE5 		ldr	r6, .L99+24
 1331              	.LVL71:
 1332 0214 043094E5 		ldr	r3, [r4, #4]
 1333 0218 002096E5 		ldr	r2, [r6, #0]
 1334 021c 024063E0 		rsb	r4, r3, r2
 1335 0220 0C4084E0 		add	r4, r4, ip
 1336              	.LVL72:
 486:layer1/prim_fbsb.c **** 			int delay = fn_offset + 11 - l1s.current_time.fn - 1;
 1337              		.loc 3 486 0
 1338 0224 041062E0 		rsb	r1, r2, r4
 1339 0228 0A5081E2 		add	r5, r1, #10
 1340              	.LVL73:
 487:layer1/prim_fbsb.c **** 			printf("  fn_offset=%d (fn=%"PRIu32" + attempt=%u + ntdma = %d)\n",
 1341              		.loc 3 487 0
 1342 022c C0009FE5 		ldr	r0, .L99+36
 1343 0230 0410A0E1 		mov	r1, r4
 1344 0234 00C08DE5 		str	ip, [sp, #0]
 1345 0238 FEFFFFEB 		bl	printf
 1346              	.LVL74:
 488:layer1/prim_fbsb.c **** 				fn_offset, l1s.current_time.fn, last_fb->attempt, ntdma);
 489:layer1/prim_fbsb.c **** 			printf("  delay=%d (fn_offset=%d + 11 - fn=%"PRIu32" - 1\n", delay,
 1347              		.loc 3 489 0
 1348 023c 0420A0E1 		mov	r2, r4
 1349 0240 003096E5 		ldr	r3, [r6, #0]
 1350 0244 0510A0E1 		mov	r1, r5
 1351 0248 A8009FE5 		ldr	r0, .L99+40
 1352 024c FEFFFFEB 		bl	printf
 490:layer1/prim_fbsb.c **** 				fn_offset, l1s.current_time.fn);
 491:layer1/prim_fbsb.c **** 			printf("  scheduling next FB/SB detection task with delay %u\n", delay);
 1353              		.loc 3 491 0
 1354 0250 0510A0E1 		mov	r1, r5
 1355 0254 A0009FE5 		ldr	r0, .L99+44
 1356 0258 FEFFFFEB 		bl	printf
 492:layer1/prim_fbsb.c **** 			if (abs(last_fb->freq_diff) < fbs.req.freq_err_thresh2 &&
 1357              		.loc 3 492 0
 1358 025c 78309FE5 		ldr	r3, .L99+12
 1359 0260 001093E5 		ldr	r1, [r3, #0]
 1360 0264 68209FE5 		ldr	r2, .L99+4
 1361 0268 F031D1E1 		ldrsh	r3, [r1, #16]
 1362 026c B622D2E1 		ldrh	r2, [r2, #38]
 1363 0270 000053E3 		cmp	r3, #0
 1364 0274 003063B2 		rsblt	r3, r3, #0
 1365 0278 020053E1 		cmp	r3, r2
 1366 027c A90000AA 		bge	.L94
 1367 0280 BE30D1E1 		ldrh	r3, [r1, #14]
 1368 0284 000053E3 		cmp	r3, #0
 1369 0288 A900000A 		beq	.L94
 493:layer1/prim_fbsb.c **** 			    last_fb->snr > FB1_SNR_THRESH) {
 494:layer1/prim_fbsb.c **** 				/* synchronize before reading SB */
 495:layer1/prim_fbsb.c **** 				fbinfo2cellinfo(&l1s.serving_cell, last_fb);
 1370              		.loc 3 495 0
 1371 028c 180086E2 		add	r0, r6, #24
 1372 0290 FEFFFFEB 		bl	fbinfo2cellinfo
 496:layer1/prim_fbsb.c **** 				synchronize_tdma(&l1s.serving_cell);
 1373              		.loc 3 496 0
 1374 0294 180086E2 		add	r0, r6, #24
 1375 0298 FEFFFFEB 		bl	synchronize_tdma
 497:layer1/prim_fbsb.c **** 				tdma_schedule_set(delay, sb_sched_set, 0);
 1376              		.loc 3 497 0
 1377 029c 5C109FE5 		ldr	r1, .L99+48
 1378 02a0 FF0005E2 		and	r0, r5, #255
 1379 02a4 0020A0E3 		mov	r2, #0
 1380 02a8 AC0000EA 		b	.L98
 1381              	.L94:
 498:layer1/prim_fbsb.c **** 			} else
 499:layer1/prim_fbsb.c **** 				tdma_schedule_set(delay, fb_sched_set, 1);
 1382              		.loc 3 499 0
 1383 02ac 24109FE5 		ldr	r1, .L99+8
 1384 02b0 FF0005E2 		and	r0, r5, #255
 1385 02b4 0120A0E3 		mov	r2, #1
 1386              	.LVL75:
 1387              	.L98:
 1388 02b8 FEFFFFEB 		bl	tdma_schedule_set
 1389 02bc AF0000EA 		b	.L73
 1390              	.LVL76:
 1391              	.L89:
 1392              	.LBE29:
 500:layer1/prim_fbsb.c **** 		} else
 501:layer1/prim_fbsb.c **** 			l1s_compl_sched(L1_COMPL_FB);
 1393              		.loc 3 501 0
 1394 02c0 FEFFFFEB 		bl	l1s_compl_sched
 1395              	.LVL77:
 1396              	.L73:
 502:layer1/prim_fbsb.c **** 	}
 503:layer1/prim_fbsb.c **** 
 504:layer1/prim_fbsb.c **** 	return 0;
 505:layer1/prim_fbsb.c **** }
 1397              		.loc 3 505 0
 1398 02c4 0000A0E3 		mov	r0, #0
 1399              	.LVL78:
 1400 02c8 04D08DE2 		add	sp, sp, #4
 1401 02cc F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 1402              	.L100:
 1403              		.align	2
 1404              	.L99:
 1405 02d0 00000000 		.word	dsp_api
 1406 02d4 00000000 		.word	fbs
 1407 02d8 78000000 		.word	fb_sched_set
 1408 02dc 00000000 		.word	last_fb
 1409 02e0 30010000 		.word	.LC8
 1410 02e4 C0500100 		.word	86208
 1411 02e8 00000000 		.word	l1s
 1412 02ec 00000000 		.word	rf_arfcn
 1413 02f0 E2040000 		.word	1250
 1414 02f4 38010000 		.word	.LC9
 1415 02f8 6C010000 		.word	.LC10
 1416 02fc 98010000 		.word	.LC11
 1417 0300 00000000 		.word	sb_sched_set
 1418              	.LFE77:
 1420              		.section	.text.l1a_fb_compl,"ax",%progbits
 1421              		.align	2
 1423              	l1a_fb_compl:
 1424              	.LFB78:
 506:layer1/prim_fbsb.c **** 
 507:layer1/prim_fbsb.c **** /* FB detection */
 508:layer1/prim_fbsb.c **** static const struct tdma_sched_item fb_sched_set[] = {
 509:layer1/prim_fbsb.c **** 	SCHED_ITEM_DT(l1s_fbdet_cmd, 0, 0, 0),	SCHED_END_FRAME(),
 510:layer1/prim_fbsb.c **** 						SCHED_END_FRAME(),
 511:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 1),	SCHED_END_FRAME(),
 512:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 2),	SCHED_END_FRAME(),
 513:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 3),	SCHED_END_FRAME(),
 514:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 4),	SCHED_END_FRAME(),
 515:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 5),	SCHED_END_FRAME(),
 516:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 6),	SCHED_END_FRAME(),
 517:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 7),	SCHED_END_FRAME(),
 518:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 8),	SCHED_END_FRAME(),
 519:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 9),	SCHED_END_FRAME(),
 520:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 10),	SCHED_END_FRAME(),
 521:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 11),	SCHED_END_FRAME(),
 522:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 12),	SCHED_END_FRAME(),
 523:layer1/prim_fbsb.c **** 	SCHED_END_SET()
 524:layer1/prim_fbsb.c **** };
 525:layer1/prim_fbsb.c **** 
 526:layer1/prim_fbsb.c **** /* Asynchronous completion handler for FB detection */
 527:layer1/prim_fbsb.c **** static void l1a_fb_compl(__unused enum l1_compl c)
 528:layer1/prim_fbsb.c **** {
 1425              		.loc 3 528 0
 1426              		@ args = 0, pretend = 0, frame = 0
 1427              		@ frame_needed = 0, uses_anonymous_args = 0
 1428              	.LVL79:
 1429 0000 04E02DE5 		str	lr, [sp, #-4]!
 1430              	.LCFI9:
 529:layer1/prim_fbsb.c **** 	if (last_fb->attempt >= 13) {
 1431              		.loc 3 529 0
 1432 0004 28309FE5 		ldr	r3, .L107
 1433 0008 003093E5 		ldr	r3, [r3, #0]
 530:layer1/prim_fbsb.c **** 		/* FB detection failed, signal this via L1CTL */
 531:layer1/prim_fbsb.c **** 		l1ctl_fbsb_resp(255);
 532:layer1/prim_fbsb.c **** 		return;
 533:layer1/prim_fbsb.c **** 	}
 534:layer1/prim_fbsb.c **** 
 535:layer1/prim_fbsb.c **** 	/* FIXME: use l1s.neigh_cell[fbs.cinfo_idx] */
 536:layer1/prim_fbsb.c **** 	fbinfo2cellinfo(&l1s.serving_cell, last_fb);
 1434              		.loc 3 536 0
 1435 000c 0310A0E1 		mov	r1, r3
 1436              		.loc 3 529 0
 1437 0010 043093E5 		ldr	r3, [r3, #4]
 1438 0014 0C0053E3 		cmp	r3, #12
 1439              		.loc 3 536 0
 1440 0018 18009FE5 		ldr	r0, .L107+4
 1441              	.LVL80:
 1442              		.loc 3 531 0
 1443 001c FF00A0C3 		movgt	r0, #255
 1444              		.loc 3 529 0
 1445 0020 090000CA 		bgt	.L106
 1446              		.loc 3 536 0
 1447 0024 FEFFFFEB 		bl	fbinfo2cellinfo
 537:layer1/prim_fbsb.c **** 
 538:layer1/prim_fbsb.c **** 	/* send FBSB_CONF success message via L1CTL */
 539:layer1/prim_fbsb.c **** 	l1ctl_fbsb_resp(0);
 1448              		.loc 3 539 0
 1449 0028 0000A0E3 		mov	r0, #0
 1450              	.L106:
 540:layer1/prim_fbsb.c **** }
 1451              		.loc 3 540 0
 1452 002c 04E09DE4 		ldr	lr, [sp], #4
 1453              		.loc 3 539 0
 1454 0030 FEFFFFEA 		b	l1ctl_fbsb_resp
 1455              	.L108:
 1456              		.align	2
 1457              	.L107:
 1458 0034 00000000 		.word	last_fb
 1459 0038 18000000 		.word	l1s+24
 1460              	.LFE78:
 1462              		.section	.text.l1s_fbsb_req,"ax",%progbits
 1463              		.align	2
 1464              		.global	l1s_fbsb_req
 1466              	l1s_fbsb_req:
 1467              	.LFB79:
 541:layer1/prim_fbsb.c **** 
 542:layer1/prim_fbsb.c **** void l1s_fbsb_req(uint8_t base_fn, struct l1ctl_fbsb_req *req)
 543:layer1/prim_fbsb.c **** {
 1468              		.loc 3 543 0
 1469              		@ args = 0, pretend = 0, frame = 0
 1470              		@ frame_needed = 0, uses_anonymous_args = 0
 1471              	.LVL81:
 1472 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1473              	.LCFI10:
 1474              		.loc 3 543 0
 1475 0004 0140A0E1 		mov	r4, r1
 544:layer1/prim_fbsb.c **** 	/* copy + endian convert request data */
 545:layer1/prim_fbsb.c **** 	fbs.req.band_arfcn = ntohs(req->band_arfcn);
 1476              		.loc 3 545 0
 1477 0008 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1478 000c 0010D1E5 		ldrb	r1, [r1, #0]	@ zero_extendqisi2
 1479              	.LVL82:
 1480              		.loc 3 543 0
 1481 0010 0020A0E1 		mov	r2, r0
 1482              		.loc 3 545 0
 1483 0014 030481E1 		orr	r0, r1, r3, asl #8
 1484              	.LVL83:
 1485              		.loc 3 543 0
 1486 0018 FF6002E2 		and	r6, r2, #255
 1487              		.loc 3 545 0
 1488 001c FEFFFFEB 		bl	__fswab16
 1489              	.LVL84:
 1490 0020 BC509FE5 		ldr	r5, .L119
 1491 0024 B002C5E1 		strh	r0, [r5, #32]	@ movhi
 546:layer1/prim_fbsb.c **** 	fbs.req.timeout = ntohs(req->timeout);
 1492              		.loc 3 546 0
 1493 0028 0230D4E5 		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1494 002c 0300D4E5 		ldrb	r0, [r4, #3]	@ zero_extendqisi2
 1495 0030 000483E1 		orr	r0, r3, r0, asl #8
 1496 0034 FEFFFFEB 		bl	__fswab16
 1497 0038 B202C5E1 		strh	r0, [r5, #34]	@ movhi
 547:layer1/prim_fbsb.c **** 	fbs.req.freq_err_thresh1 = ntohs(req->freq_err_thresh1);
 1498              		.loc 3 547 0
 1499 003c 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1500 0040 0500D4E5 		ldrb	r0, [r4, #5]	@ zero_extendqisi2
 1501 0044 000483E1 		orr	r0, r3, r0, asl #8
 1502 0048 FEFFFFEB 		bl	__fswab16
 1503 004c B402C5E1 		strh	r0, [r5, #36]	@ movhi
 548:layer1/prim_fbsb.c **** 	fbs.req.freq_err_thresh2 = ntohs(req->freq_err_thresh2);
 1504              		.loc 3 548 0
 1505 0050 0630D4E5 		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 1506 0054 0700D4E5 		ldrb	r0, [r4, #7]	@ zero_extendqisi2
 1507 0058 000483E1 		orr	r0, r3, r0, asl #8
 1508 005c FEFFFFEB 		bl	__fswab16
 549:layer1/prim_fbsb.c **** 	fbs.req.num_freqerr_avg = req->num_freqerr_avg;
 1509              		.loc 3 549 0
 1510 0060 0830D4E5 		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 550:layer1/prim_fbsb.c **** 	fbs.req.flags = req->flags;
 1511              		.loc 3 550 0
 1512 0064 0920D4E5 		ldrb	r2, [r4, #9]	@ zero_extendqisi2
 551:layer1/prim_fbsb.c **** 	fbs.req.sync_info_idx = req->sync_info_idx;
 1513              		.loc 3 551 0
 1514 0068 0A10D4E5 		ldrb	r1, [r4, #10]	@ zero_extendqisi2
 552:layer1/prim_fbsb.c **** 	fbs.req.rxlev_exp = req->rxlev_exp;
 1515              		.loc 3 552 0
 1516 006c 0CE0D4E5 		ldrb	lr, [r4, #12]	@ zero_extendqisi2
 553:layer1/prim_fbsb.c **** 
 554:layer1/prim_fbsb.c **** 	/* clear initial frequency error */
 555:layer1/prim_fbsb.c **** 	fbs.initial_freq_err = 0;
 1517              		.loc 3 555 0
 1518 0070 0040A0E3 		mov	r4, #0
 1519              	.LVL85:
 1520              		.loc 3 548 0
 1521 0074 B602C5E1 		strh	r0, [r5, #38]	@ movhi
 1522              		.loc 3 549 0
 1523 0078 2830C5E5 		strb	r3, [r5, #40]
 1524              		.loc 3 550 0
 1525 007c 2920C5E5 		strb	r2, [r5, #41]
 1526              		.loc 3 551 0
 1527 0080 2A10C5E5 		strb	r1, [r5, #42]
 1528              		.loc 3 552 0
 1529 0084 2CE0C5E5 		strb	lr, [r5, #44]
 556:layer1/prim_fbsb.c **** 	fbs.fb_retries = 0;
 1530              		.loc 3 556 0
 1531 0088 3040C5E5 		strb	r4, [r5, #48]
 1532              		.loc 3 555 0
 1533 008c BE42C5E1 		strh	r4, [r5, #46]	@ movhi
 557:layer1/prim_fbsb.c **** 	fbs.afc_retries = 0;
 1534              		.loc 3 557 0
 1535 0090 3140C5E5 		strb	r4, [r5, #49]
 558:layer1/prim_fbsb.c **** 
 559:layer1/prim_fbsb.c **** 	/* Make sure we start at a 'center' AFCDAC output value */
 560:layer1/prim_fbsb.c **** 	afc_reset();
 1536              		.loc 3 560 0
 1537 0094 FEFFFFEB 		bl	afc_reset
 561:layer1/prim_fbsb.c **** 
 562:layer1/prim_fbsb.c **** 	/* Reset the TOA loop counters */
 563:layer1/prim_fbsb.c **** 	toa_reset();
 1538              		.loc 3 563 0
 1539 0098 FEFFFFEB 		bl	toa_reset
 564:layer1/prim_fbsb.c **** 
 565:layer1/prim_fbsb.c **** 	if (fbs.req.flags & L1CTL_FBSB_F_FB0)
 1540              		.loc 3 565 0
 1541 009c 2930D5E5 		ldrb	r3, [r5, #41]	@ zero_extendqisi2
 1542 00a0 01C013E2 		ands	ip, r3, #1
 566:layer1/prim_fbsb.c **** 		tdma_schedule_set(base_fn, fb_sched_set, 0);
 1543              		.loc 3 566 0
 1544 00a4 0600A0E1 		mov	r0, r6
 1545 00a8 0420A0E1 		mov	r2, r4
 1546 00ac 34109FE5 		ldr	r1, .L119+4
 1547              		.loc 3 565 0
 1548 00b0 3500001A 		bne	.L118
 1549              	.LVL86:
 567:layer1/prim_fbsb.c **** 	else if (fbs.req.flags & L1CTL_FBSB_F_FB1)
 568:layer1/prim_fbsb.c **** 		tdma_schedule_set(base_fn, fb_sched_set, 0);
 1550              		.loc 3 568 0
 1551 00b4 0C20A0E1 		mov	r2, ip
 1552              		.loc 3 567 0
 1553 00b8 02C013E2 		ands	ip, r3, #2
 1554              		.loc 3 568 0
 1555 00bc 0600A0E1 		mov	r0, r6
 1556 00c0 20109FE5 		ldr	r1, .L119+4
 1557              		.loc 3 567 0
 1558 00c4 3500001A 		bne	.L118
 569:layer1/prim_fbsb.c **** 	else if (fbs.req.flags & L1CTL_FBSB_F_SB)
 1559              		.loc 3 569 0
 1560 00c8 040013E3 		tst	r3, #4
 570:layer1/prim_fbsb.c **** 		tdma_schedule_set(base_fn, sb_sched_set, 0);
 1561              		.loc 3 570 0
 1562 00cc 0600A0E1 		mov	r0, r6
 1563 00d0 0C20A0E1 		mov	r2, ip
 1564 00d4 10109FE5 		ldr	r1, .L119+8
 1565              		.loc 3 569 0
 1566 00d8 7080BD08 		ldmeqfd	sp!, {r4, r5, r6, pc}
 1567              	.L118:
 571:layer1/prim_fbsb.c **** 
 572:layer1/prim_fbsb.c **** }
 1568              		.loc 3 572 0
 1569 00dc 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1570              		.loc 3 570 0
 1571 00e0 FEFFFFEA 		b	tdma_schedule_set
 1572              	.LVL87:
 1573              	.L120:
 1574              		.align	2
 1575              	.L119:
 1576 00e4 00000000 		.word	fbs
 1577 00e8 78000000 		.word	fb_sched_set
 1578 00ec 00000000 		.word	sb_sched_set
 1579              	.LFE79:
 1581              		.section	.text.l1s_prim_fbsb_init,"ax",%progbits
 1582              		.align	2
 1584              	l1s_prim_fbsb_init:
 1585              	.LFB80:
 573:layer1/prim_fbsb.c **** 
 574:layer1/prim_fbsb.c **** static __attribute__ ((constructor)) void l1s_prim_fbsb_init(void)
 575:layer1/prim_fbsb.c **** {
 1586              		.loc 3 575 0
 1587              		@ args = 0, pretend = 0, frame = 0
 1588              		@ frame_needed = 0, uses_anonymous_args = 0
 1589              		@ link register save eliminated.
 1590              	.LVL88:
 576:layer1/prim_fbsb.c **** 	l1s.completion[L1_COMPL_FB] = &l1a_fb_compl;
 1591              		.loc 3 576 0
 1592 0000 08209FE5 		ldr	r2, .L123
 1593 0004 08309FE5 		ldr	r3, .L123+4
 1594              		.loc 3 575 0
 1595              		@ lr needed for prologue
 1596              		.loc 3 576 0
 1597 0008 742A83E5 		str	r2, [r3, #2676]
 577:layer1/prim_fbsb.c **** }
 1598              		.loc 3 577 0
 1599 000c 1EFF2FE1 		bx	lr
 1600              	.L124:
 1601              		.align	2
 1602              	.L123:
 1603 0010 00000000 		.word	l1a_fb_compl
 1604 0014 00000000 		.word	l1s
 1605              	.LFE80:
 1607              		.section	.ctors,"aw",%progbits
 1608              		.align	2
 1609 0000 00000000 		.word	l1s_prim_fbsb_init
 1610              		.bss
 1611              		.align	2
 1612              	fbs:
 1613 0000 00000000 		.space	52
 1613      00000000 
 1613      00000000 
 1613      00000000 
 1613      00000000 
 1862              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prim_fbsb.c
     /tmp/ccLdB5OY.s:14     .data:0000000000000000 last_fb
     /tmp/ccLdB5OY.s:15     .data:0000000000000000 $d
     /tmp/ccLdB5OY.s:1612   .bss:0000000000000000 fbs
     /tmp/ccLdB5OY.s:20     .rodata:0000000000000000 sb_sched_set
     /tmp/ccLdB5OY.s:21     .rodata:0000000000000000 $d
     /tmp/ccLdB5OY.s:803    .text.l1s_sbdet_cmd:0000000000000000 l1s_sbdet_cmd
     /tmp/ccLdB5OY.s:440    .text.l1s_sbdet_resp:0000000000000000 l1s_sbdet_resp
     /tmp/ccLdB5OY.s:72     .rodata:0000000000000078 fb_sched_set
     /tmp/ccLdB5OY.s:1021   .text.l1s_fbdet_cmd:0000000000000000 l1s_fbdet_cmd
     /tmp/ccLdB5OY.s:1092   .text.l1s_fbdet_resp:0000000000000000 l1s_fbdet_resp
     /tmp/ccLdB5OY.s:214    .text.__fswab16:0000000000000000 __fswab16
     /tmp/ccLdB5OY.s:222    .text.__fswab16:0000000000000000 $a
     /tmp/ccLdB5OY.s:241    .text.msgb_tailroom:0000000000000000 msgb_tailroom
     /tmp/ccLdB5OY.s:249    .text.msgb_tailroom:0000000000000000 $a
     /tmp/ccLdB5OY.s:269    .text.dump_mon_state:0000000000000000 dump_mon_state
     /tmp/ccLdB5OY.s:276    .text.dump_mon_state:0000000000000000 $a
     /tmp/ccLdB5OY.s:314    .text.dump_mon_state:0000000000000074 $d
     /tmp/ccLdB5OY.s:326    .text.l1ctl_fbsb_resp:0000000000000000 l1ctl_fbsb_resp
     /tmp/ccLdB5OY.s:332    .text.l1ctl_fbsb_resp:0000000000000000 $a
     /tmp/ccLdB5OY.s:418    .text.l1ctl_fbsb_resp:00000000000000ac $d
     /tmp/ccLdB5OY.s:446    .text.l1s_sbdet_resp:0000000000000000 $a
     /tmp/ccLdB5OY.s:784    .text.l1s_sbdet_resp:00000000000002d4 $d
     /tmp/ccLdB5OY.s:809    .text.l1s_sbdet_cmd:0000000000000000 $a
     /tmp/ccLdB5OY.s:847    .text.l1s_sbdet_cmd:0000000000000048 $d
     /tmp/ccLdB5OY.s:856    .text.l1s_sb_test:0000000000000000 l1s_sb_test
     /tmp/ccLdB5OY.s:864    .text.l1s_sb_test:0000000000000000 $a
     /tmp/ccLdB5OY.s:878    .text.l1s_sb_test:0000000000000010 $d
     /tmp/ccLdB5OY.s:893    .text.fbinfo2cellinfo:0000000000000000 fbinfo2cellinfo
     /tmp/ccLdB5OY.s:899    .text.fbinfo2cellinfo:0000000000000000 $a
     /tmp/ccLdB5OY.s:1009   .text.fbinfo2cellinfo:00000000000000e0 $d
     /tmp/ccLdB5OY.s:1027   .text.l1s_fbdet_cmd:0000000000000000 $a
     /tmp/ccLdB5OY.s:1069   .text.l1s_fbdet_cmd:0000000000000060 $d
     /tmp/ccLdB5OY.s:1098   .text.l1s_fbdet_resp:0000000000000000 $a
     /tmp/ccLdB5OY.s:1405   .text.l1s_fbdet_resp:00000000000002d0 $d
     /tmp/ccLdB5OY.s:1423   .text.l1a_fb_compl:0000000000000000 l1a_fb_compl
     /tmp/ccLdB5OY.s:1429   .text.l1a_fb_compl:0000000000000000 $a
     /tmp/ccLdB5OY.s:1458   .text.l1a_fb_compl:0000000000000034 $d
     /tmp/ccLdB5OY.s:1466   .text.l1s_fbsb_req:0000000000000000 l1s_fbsb_req
     /tmp/ccLdB5OY.s:1472   .text.l1s_fbsb_req:0000000000000000 $a
     /tmp/ccLdB5OY.s:1576   .text.l1s_fbsb_req:00000000000000e4 $d
     /tmp/ccLdB5OY.s:1584   .text.l1s_prim_fbsb_init:0000000000000000 l1s_prim_fbsb_init
     /tmp/ccLdB5OY.s:1592   .text.l1s_prim_fbsb_init:0000000000000000 $a
     /tmp/ccLdB5OY.s:1603   .text.l1s_prim_fbsb_init:0000000000000010 $d
     /tmp/ccLdB5OY.s:1609   .ctors:0000000000000000 $d

UNDEFINED SYMBOLS
tdma_end_set
agc_inp_dbm8_by_pm
printf
l1s_snr_int
l1_create_l2_msg
osmo_panic
l1_queue_for_l2
__udivsi3
afc_input
memset
gsm_gsmtime2fn
l1s_time_dump
synchronize_tdma
gsm_fn2gsmtime
l1s_time_inc
tdma_sched_reset
l1s_dsp_abort
l1s_reset_hw
mframe_enable
l1s_compl_sched
dsp_api
l1s
rf_arfcn
l1s_rx_win_ctrl
tdma_schedule_set
__divsi3
rxlev2dbm
rffe_compute_gain
afc_correct
afc_reset
toa_reset
