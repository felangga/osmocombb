   1              		.file	"prim_rx_nb.c"
   9              	.Ltext0:
  10              		.global	nb_sched_set
  11              		.section	.rodata
  12              		.align	2
  15              	nb_sched_set:
  16 0000 00000000 		.word	l1s_nb_cmd
  17 0004 00       		.byte	0
  18 0005 00       		.byte	0
  19 0006 0000     		.space	2
  20 0008 0000     		.short	0
  21 000a 0300     		.short	3
  22 000c 00000000 		.word	0
  23 0010 00       		.byte	0
  24 0011 00       		.byte	0
  25 0012 00000000 		.space	6
  25      0000
  26 0018 00000000 		.word	l1s_nb_cmd
  27 001c 00       		.byte	0
  28 001d 01       		.byte	1
  29 001e 0000     		.space	2
  30 0020 0000     		.short	0
  31 0022 0300     		.short	3
  32 0024 00000000 		.word	0
  33 0028 00       		.byte	0
  34 0029 00       		.byte	0
  35 002a 00000000 		.space	6
  35      0000
  36 0030 00000000 		.word	l1s_nb_resp
  37 0034 00       		.byte	0
  38 0035 00       		.byte	0
  39 0036 0000     		.space	2
  40 0038 FCFF     		.short	-4
  41 003a 0000     		.short	0
  42 003c 00000000 		.word	l1s_nb_cmd
  43 0040 00       		.byte	0
  44 0041 02       		.byte	2
  45 0042 0000     		.space	2
  46 0044 0000     		.short	0
  47 0046 0300     		.short	3
  48 0048 00000000 		.word	0
  49 004c 00       		.byte	0
  50 004d 00       		.byte	0
  51 004e 00000000 		.space	6
  51      0000
  52 0054 00000000 		.word	l1s_nb_resp
  53 0058 00       		.byte	0
  54 0059 01       		.byte	1
  55 005a 0000     		.space	2
  56 005c FCFF     		.short	-4
  57 005e 0000     		.short	0
  58 0060 00000000 		.word	l1s_nb_cmd
  59 0064 00       		.byte	0
  60 0065 03       		.byte	3
  61 0066 0000     		.space	2
  62 0068 0000     		.short	0
  63 006a 0300     		.short	3
  64 006c 00000000 		.word	0
  65 0070 00       		.byte	0
  66 0071 00       		.byte	0
  67 0072 00000000 		.space	6
  67      0000
  68 0078 00000000 		.word	l1s_nb_resp
  69 007c 00       		.byte	0
  70 007d 02       		.byte	2
  71 007e 0000     		.space	2
  72 0080 FCFF     		.short	-4
  73 0082 0000     		.short	0
  74 0084 00000000 		.word	0
  75 0088 00       		.byte	0
  76 0089 00       		.byte	0
  77 008a 00000000 		.space	6
  77      0000
  78 0090 00000000 		.word	l1s_nb_resp
  79 0094 00       		.byte	0
  80 0095 03       		.byte	3
  81 0096 0000     		.space	2
  82 0098 FCFF     		.short	-4
  83 009a 0000     		.short	0
  84 009c 00000000 		.word	0
  85 00a0 00       		.byte	0
  86 00a1 00       		.byte	0
  87 00a2 00000000 		.space	6
  87      0000
  88 00a8 00000000 		.word	tdma_end_set
  89 00ac 00       		.byte	0
  90 00ad 00       		.byte	0
  91 00ae 00000000 		.space	6
  91      0000
  92              		.section	.text.msgb_tailroom,"ax",%progbits
  93              		.align	2
  95              	msgb_tailroom:
  96              	.LFB38:
  97              		.file 1 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
  98              		.loc 1 151 0
  99              		@ args = 0, pretend = 0, frame = 0
 100              		@ frame_needed = 0, uses_anonymous_args = 0
 101              		@ link register save eliminated.
 102              	.LVL0:
 103 0000 B423D0E1 		ldrh	r2, [r0, #52]
 104 0004 383090E5 		ldr	r3, [r0, #56]
 105 0008 3C0090E5 		ldr	r0, [r0, #60]
 106              	.LVL1:
 107 000c 023083E0 		add	r3, r3, r2
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 108              		.loc 1 153 0
 109 0010 030060E0 		rsb	r0, r0, r3
 110              		.loc 1 151 0
 111              		@ lr needed for prologue
 112              		.loc 1 153 0
 113 0014 1EFF2FE1 		bx	lr
 114              	.LFE38:
 116              		.section	.rodata.str1.4,"aMS",%progbits,1
 117              		.align	2
 118              	.LC0:
 119 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 119      28257029 
 119      3A204E6F 
 119      7420656E 
 119      6F756768 
 120 0032 00       		.ascii	"\000"
 121              		.section	.text.msgb_put,"ax",%progbits
 122              		.align	2
 124              	msgb_put:
 125              	.LFB40:
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 126              		.loc 1 180 0
 127              		@ args = 0, pretend = 0, frame = 0
 128              		@ frame_needed = 0, uses_anonymous_args = 0
 129              	.LVL2:
 130 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 131              	.LCFI0:
 132              		.loc 1 180 0
 133 0004 0150A0E1 		mov	r5, r1
 134 0008 0040A0E1 		mov	r4, r0
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 135              		.loc 1 182 0
 136 000c FEFFFFEB 		bl	msgb_tailroom
 137              	.LVL3:
 138 0010 050050E1 		cmp	r0, r5
 139 0014 0020A0E1 		mov	r2, r0
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 140              		.loc 1 183 0
 141 0018 0410A0E1 		mov	r1, r4
 142 001c 28009FE5 		ldr	r0, .L7
 143 0020 0530A0E1 		mov	r3, r5
 144              		.loc 1 181 0
 145 0024 3C6094E5 		ldr	r6, [r4, #60]
 146              	.LVL4:
 147              		.loc 1 182 0
 148              	.LVL5:
 149              		.loc 1 183 0
 150 0028 FEFFFFBB 		bllt	osmo_panic
 151              	.LVL6:
 152              	.L4:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 153              		.loc 1 185 0
 154 002c 3C2094E5 		ldr	r2, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 155              		.loc 1 186 0
 156 0030 B633D4E1 		ldrh	r3, [r4, #54]
 157              		.loc 1 185 0
 158 0034 052082E0 		add	r2, r2, r5
 159              		.loc 1 186 0
 160 0038 053083E0 		add	r3, r3, r5
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 161              		.loc 1 188 0
 162 003c 0600A0E1 		mov	r0, r6
 163              		.loc 1 186 0
 164 0040 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 165              		.loc 1 185 0
 166 0044 3C2084E5 		str	r2, [r4, #60]
 167              		.loc 1 188 0
 168 0048 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 169              	.L8:
 170              		.align	2
 171              	.L7:
 172 004c 00000000 		.word	.LC0
 173              	.LFE40:
 175              		.section	.rodata.str1.4
 176 0033 00       		.align	2
 177              	.LC1:
 178 0034 454D5054 		.ascii	"EMPTY\012\000"
 178      590A00
 179 003b 00       		.align	2
 180              	.LC2:
 181 003c 42555253 		.ascii	"BURST ID %u!=%u\012\000"
 181      54204944 
 181      20257521 
 181      3D25750A 
 181      00
 182              		.section	.text.l1s_nb_resp,"ax",%progbits
 183              		.align	2
 185              	l1s_nb_resp:
 186              	.LFB67:
 187              		.file 2 "layer1/prim_rx_nb.c"
   1:layer1/prim_rx_nb.c **** /* Layer 1 - Receiving Normal Bursts */
   2:layer1/prim_rx_nb.c **** 
   3:layer1/prim_rx_nb.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:layer1/prim_rx_nb.c ****  *
   5:layer1/prim_rx_nb.c ****  * All Rights Reserved
   6:layer1/prim_rx_nb.c ****  *
   7:layer1/prim_rx_nb.c ****  * This program is free software; you can redistribute it and/or modify
   8:layer1/prim_rx_nb.c ****  * it under the terms of the GNU General Public License as published by
   9:layer1/prim_rx_nb.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:layer1/prim_rx_nb.c ****  * (at your option) any later version.
  11:layer1/prim_rx_nb.c ****  *
  12:layer1/prim_rx_nb.c ****  * This program is distributed in the hope that it will be useful,
  13:layer1/prim_rx_nb.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:layer1/prim_rx_nb.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:layer1/prim_rx_nb.c ****  * GNU General Public License for more details.
  16:layer1/prim_rx_nb.c ****  *
  17:layer1/prim_rx_nb.c ****  * You should have received a copy of the GNU General Public License along
  18:layer1/prim_rx_nb.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:layer1/prim_rx_nb.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:layer1/prim_rx_nb.c ****  *
  21:layer1/prim_rx_nb.c ****  */
  22:layer1/prim_rx_nb.c **** 
  23:layer1/prim_rx_nb.c **** #include <stdint.h>
  24:layer1/prim_rx_nb.c **** #include <stdio.h>
  25:layer1/prim_rx_nb.c **** #include <string.h>
  26:layer1/prim_rx_nb.c **** #include <stdlib.h>
  27:layer1/prim_rx_nb.c **** 
  28:layer1/prim_rx_nb.c **** #include <defines.h>
  29:layer1/prim_rx_nb.c **** #include <debug.h>
  30:layer1/prim_rx_nb.c **** #include <memory.h>
  31:layer1/prim_rx_nb.c **** #include <byteorder.h>
  32:layer1/prim_rx_nb.c **** #include <rffe.h>
  33:layer1/prim_rx_nb.c **** #include <osmocom/gsm/gsm_utils.h>
  34:layer1/prim_rx_nb.c **** #include <osmocom/core/msgb.h>
  35:layer1/prim_rx_nb.c **** #include <calypso/dsp_api.h>
  36:layer1/prim_rx_nb.c **** #include <calypso/irq.h>
  37:layer1/prim_rx_nb.c **** #include <calypso/tpu.h>
  38:layer1/prim_rx_nb.c **** #include <calypso/tsp.h>
  39:layer1/prim_rx_nb.c **** #include <calypso/dsp.h>
  40:layer1/prim_rx_nb.c **** #include <calypso/timer.h>
  41:layer1/prim_rx_nb.c **** #include <comm/sercomm.h>
  42:layer1/prim_rx_nb.c **** 
  43:layer1/prim_rx_nb.c **** #include <layer1/sync.h>
  44:layer1/prim_rx_nb.c **** #include <layer1/afc.h>
  45:layer1/prim_rx_nb.c **** #include <layer1/toa.h>
  46:layer1/prim_rx_nb.c **** #include <layer1/tdma_sched.h>
  47:layer1/prim_rx_nb.c **** #include <layer1/mframe_sched.h>
  48:layer1/prim_rx_nb.c **** #include <layer1/tpu_window.h>
  49:layer1/prim_rx_nb.c **** #include <layer1/l23_api.h>
  50:layer1/prim_rx_nb.c **** #include <layer1/rfch.h>
  51:layer1/prim_rx_nb.c **** #include <layer1/prim.h>
  52:layer1/prim_rx_nb.c **** #include <layer1/agc.h>
  53:layer1/prim_rx_nb.c **** 
  54:layer1/prim_rx_nb.c **** #include <l1ctl_proto.h>
  55:layer1/prim_rx_nb.c **** 
  56:layer1/prim_rx_nb.c **** struct l1s_rxnb_state {
  57:layer1/prim_rx_nb.c **** 	struct l1s_meas_hdr meas[4];
  58:layer1/prim_rx_nb.c **** 
  59:layer1/prim_rx_nb.c **** 	struct msgb *msg;
  60:layer1/prim_rx_nb.c **** 	struct l1ctl_info_dl *dl;
  61:layer1/prim_rx_nb.c **** 	struct l1ctl_data_ind *di;
  62:layer1/prim_rx_nb.c **** };
  63:layer1/prim_rx_nb.c **** 
  64:layer1/prim_rx_nb.c **** static struct l1s_rxnb_state rxnb;
  65:layer1/prim_rx_nb.c **** 
  66:layer1/prim_rx_nb.c **** static int l1s_nb_resp(__unused uint8_t p1, uint8_t burst_id, uint16_t p3)
  67:layer1/prim_rx_nb.c **** {
 188              		.loc 2 67 0
 189              		@ args = 0, pretend = 0, frame = 16
 190              		@ frame_needed = 0, uses_anonymous_args = 0
 191              	.LVL7:
 192 0000 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 193              	.LCFI1:
  68:layer1/prim_rx_nb.c **** 	struct gsm_time rx_time;
  69:layer1/prim_rx_nb.c **** 	uint8_t mf_task_id = p3 & 0xff;
  70:layer1/prim_rx_nb.c **** 	uint8_t mf_task_flags = p3 >> 8;
  71:layer1/prim_rx_nb.c **** 	uint16_t rf_arfcn;
  72:layer1/prim_rx_nb.c **** 	uint8_t tsc, tn;
  73:layer1/prim_rx_nb.c **** 
  74:layer1/prim_rx_nb.c **** 	putchart('n');
  75:layer1/prim_rx_nb.c **** 
  76:layer1/prim_rx_nb.c **** 	/* just for debugging, d_task_d should not be 0 */
  77:layer1/prim_rx_nb.c **** 	if (dsp_api.db_r->d_task_d == 0) {
 194              		.loc 2 77 0
 195 0004 F0829FE5 		ldr	r8, .L34
 196 0008 040098E5 		ldr	r0, [r8, #4]
 197              	.LVL8:
 198 000c B030D0E1 		ldrh	r3, [r0, #0]
 199              		.loc 2 67 0
 200 0010 0228A0E1 		mov	r2, r2, asl #16
 201              	.LVL9:
 202              		.loc 2 77 0
 203 0014 000053E3 		cmp	r3, #0
 204              		.loc 2 67 0
 205 0018 2238A0E1 		mov	r3, r2, lsr #16
 206              	.LVL10:
 207 001c 10D04DE2 		sub	sp, sp, #16
 208              	.LCFI2:
 209              	.LVL11:
 210              		.loc 2 67 0
 211 0020 FF7001E2 		and	r7, r1, #255
 212              		.loc 2 69 0
 213 0024 FF9003E2 		and	r9, r3, #255
 214              	.LVL12:
 215              		.loc 2 70 0
 216 0028 22ACA0E1 		mov	sl, r2, lsr #24
 217              	.LVL13:
 218              		.loc 2 77 0
 219 002c 0D00001A 		bne	.L10
 220              	.LVL14:
  78:layer1/prim_rx_nb.c **** 		puts("EMPTY\n");
 221              		.loc 2 78 0
 222 0030 C8029FE5 		ldr	r0, .L34+4
 223 0034 FEFFFFEB 		bl	puts
 224              	.LVL15:
 225 0038 BA0000EA 		b	.L12
 226              	.LVL16:
 227              	.L10:
  79:layer1/prim_rx_nb.c **** 		return 0;
  80:layer1/prim_rx_nb.c **** 	}
  81:layer1/prim_rx_nb.c **** 
  82:layer1/prim_rx_nb.c **** 	/* DSP burst ID needs to correspond with what we expect */
  83:layer1/prim_rx_nb.c **** 	if (dsp_api.db_r->d_burst_d != burst_id) {
 228              		.loc 2 83 0
 229 003c B210D0E1 		ldrh	r1, [r0, #2]
 230 0040 070051E1 		cmp	r1, r7
 231 0044 1400000A 		beq	.L13
  84:layer1/prim_rx_nb.c **** 		printf("BURST ID %u!=%u\n", dsp_api.db_r->d_burst_d, burst_id);
 232              		.loc 2 84 0
 233 0048 0720A0E1 		mov	r2, r7
 234 004c B0029FE5 		ldr	r0, .L34+8
 235 0050 FEFFFFEB 		bl	printf
 236              	.LVL17:
 237 0054 BA0000EA 		b	.L12
 238              	.LVL18:
 239              	.L13:
  85:layer1/prim_rx_nb.c **** 		return 0;
  86:layer1/prim_rx_nb.c **** 	}
  87:layer1/prim_rx_nb.c **** 
  88:layer1/prim_rx_nb.c **** 	/* get radio parameters for _this_ burst */
  89:layer1/prim_rx_nb.c **** 	gsm_fn2gsmtime(&rx_time, l1s.current_time.fn - 1);
 240              		.loc 2 89 0
 241 0058 A8329FE5 		ldr	r3, .L34+12
 242              	.LVL19:
 243 005c 001093E5 		ldr	r1, [r3, #0]
 244 0060 0D00A0E1 		mov	r0, sp
 245 0064 011041E2 		sub	r1, r1, #1
 246 0068 FEFFFFEB 		bl	gsm_fn2gsmtime
  90:layer1/prim_rx_nb.c **** 	rfch_get_params(&rx_time, &rf_arfcn, &tsc, &tn);
 247              		.loc 2 90 0
 248 006c 0C108DE2 		add	r1, sp, #12
 249 0070 0D00A0E1 		mov	r0, sp
 250 0074 0F208DE2 		add	r2, sp, #15
 251 0078 0E308DE2 		add	r3, sp, #14
 252 007c FEFFFFEB 		bl	rfch_get_params
  91:layer1/prim_rx_nb.c **** 
  92:layer1/prim_rx_nb.c **** 	/* collect measurements */
  93:layer1/prim_rx_nb.c **** 	rxnb.meas[burst_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 253              		.loc 2 93 0
 254 0080 043098E5 		ldr	r3, [r8, #4]
 255 0084 80629FE5 		ldr	r6, .L34+16
 256 0088 B021D3E1 		ldrh	r2, [r3, #16]
 257 008c 8751A0E1 		mov	r5, r7, asl #3
 258 0090 064085E0 		add	r4, r5, r6
 259 0094 B220C4E1 		strh	r2, [r4, #2]	@ movhi
  94:layer1/prim_rx_nb.c **** 	rxnb.meas[burst_id].pm_dbm8 =
 260              		.loc 2 94 0
 261 0098 B201D3E1 		ldrh	r0, [r3, #18]
 262 009c A001A0E1 		mov	r0, r0, lsr #3
 263 00a0 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
  95:layer1/prim_rx_nb.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
  96:layer1/prim_rx_nb.c **** 	rxnb.meas[burst_id].freq_err =
 264              		.loc 2 96 0
 265 00a4 041098E5 		ldr	r1, [r8, #4]
 266              		.loc 2 94 0
 267 00a8 B400C4E1 		strh	r0, [r4, #4]	@ movhi
 268              		.loc 2 96 0
 269 00ac 5C329FE5 		ldr	r3, .L34+20
 270 00b0 F421D1E1 		ldrsh	r2, [r1, #20]
 271 00b4 920303E0 		mul	r3, r2, r3
 272 00b8 FF2C83E2 		add	r2, r3, #65280
 273 00bc FF2082E2 		add	r2, r2, #255
 274 00c0 000053E3 		cmp	r3, #0
 275 00c4 0230A0B1 		movlt	r3, r2
 276              		.loc 2 94 0
 277 00c8 044084E2 		add	r4, r4, #4
 278              		.loc 2 96 0
 279 00cc 4338A0E1 		mov	r3, r3, asr #16
 280 00d0 B230C4E1 		strh	r3, [r4, #2]	@ movhi
  97:layer1/prim_rx_nb.c **** 			ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
  98:layer1/prim_rx_nb.c **** 	rxnb.meas[burst_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 281              		.loc 2 98 0
 282 00d4 B631D1E1 		ldrh	r3, [r1, #22]
 283 00d8 B200D4E1 		ldrh	r0, [r4, #2]
  99:layer1/prim_rx_nb.c **** 
 100:layer1/prim_rx_nb.c **** 	/* feed computed frequency error into AFC loop */
 101:layer1/prim_rx_nb.c **** 	if (rxnb.meas[burst_id].snr > AFC_SNR_THRESHOLD)
 284              		.loc 2 101 0
 285 00dc 0A0C53E3 		cmp	r3, #2560
 102:layer1/prim_rx_nb.c **** 		afc_input(rxnb.meas[burst_id].freq_err, rf_arfcn, 1);
 286              		.loc 2 102 0
 287 00e0 0008A081 		movhi	r0, r0, asl #16
 103:layer1/prim_rx_nb.c **** 	else
 104:layer1/prim_rx_nb.c **** 		afc_input(rxnb.meas[burst_id].freq_err, rf_arfcn, 0);
 288              		.loc 2 104 0
 289 00e4 0008A091 		movls	r0, r0, asl #16
 290              		.loc 2 102 0
 291 00e8 4008A081 		movhi	r0, r0, asr #16
 292 00ec 0120A083 		movhi	r2, #1
 293              		.loc 2 104 0
 294 00f0 4008A091 		movls	r0, r0, asr #16
 295 00f4 0020A093 		movls	r2, #0
 296              		.loc 2 98 0
 297 00f8 B63085E1 		strh	r3, [r5, r6]	@ movhi
 298              	.LVL20:
 299 00fc BC10DDE1 		ldrh	r1, [sp, #12]
 105:layer1/prim_rx_nb.c **** 
 106:layer1/prim_rx_nb.c **** 	/* feed computed TOA into TA loop */
 107:layer1/prim_rx_nb.c **** 	toa_input(rxnb.meas[burst_id].toa_qbit << 2, rxnb.meas[burst_id].snr);
 300              		.loc 2 107 0
 301 0100 04529FE5 		ldr	r5, .L34+16
 302              		.loc 2 104 0
 303 0104 FEFFFFEB 		bl	afc_input
 304              		.loc 2 107 0
 305 0108 8731A0E1 		mov	r3, r7, asl #3
 306 010c 054083E0 		add	r4, r3, r5
 307 0110 F200D4E1 		ldrsh	r0, [r4, #2]
 308 0114 B51093E1 		ldrh	r1, [r3, r5]
 309 0118 0001A0E1 		mov	r0, r0, asl #2
 310 011c FEFFFFEB 		bl	toa_input
 108:layer1/prim_rx_nb.c **** 
 109:layer1/prim_rx_nb.c **** 	/* Tell the RF frontend to set the gain appropriately */
 110:layer1/prim_rx_nb.c **** 	rffe_compute_gain(rxnb.meas[burst_id].pm_dbm8/8, CAL_DSP_TGT_BB_LVL);
 311              		.loc 2 110 0
 312 0120 F400D4E1 		ldrsh	r0, [r4, #4]
 313 0124 073080E2 		add	r3, r0, #7
 314 0128 000050E3 		cmp	r0, #0
 315 012c 0300A0B1 		movlt	r0, r3
 316 0130 C001A0E1 		mov	r0, r0, asr #3
 317 0134 5010A0E3 		mov	r1, #80
 318 0138 FEFFFFEB 		bl	rffe_compute_gain
 111:layer1/prim_rx_nb.c **** 
 112:layer1/prim_rx_nb.c **** 	/* 4th burst, get frame data */
 113:layer1/prim_rx_nb.c **** 	if (dsp_api.db_r->d_burst_d == 3) {
 319              		.loc 2 113 0
 320 013c B8319FE5 		ldr	r3, .L34
 321 0140 043093E5 		ldr	r3, [r3, #4]
 322 0144 B230D3E1 		ldrh	r3, [r3, #2]
 323 0148 030053E3 		cmp	r3, #3
 324 014c B700001A 		bne	.L18
 325              	.LBB2:
 114:layer1/prim_rx_nb.c **** 		uint8_t i;
 115:layer1/prim_rx_nb.c **** 		uint16_t num_biterr;
 116:layer1/prim_rx_nb.c **** 		uint32_t avg_snr = 0;
 117:layer1/prim_rx_nb.c **** 		int32_t avg_dbm8 = 0;
 118:layer1/prim_rx_nb.c **** 
 119:layer1/prim_rx_nb.c **** 		/* Get radio parameters for the first burst */
 120:layer1/prim_rx_nb.c **** 		gsm_fn2gsmtime(&rx_time, l1s.current_time.fn - 4);
 326              		.loc 2 120 0
 327 0150 B0319FE5 		ldr	r3, .L34+12
 328 0154 001093E5 		ldr	r1, [r3, #0]
 329 0158 0D00A0E1 		mov	r0, sp
 330 015c 041041E2 		sub	r1, r1, #4
 331 0160 FEFFFFEB 		bl	gsm_fn2gsmtime
 121:layer1/prim_rx_nb.c **** 		rfch_get_params(&rx_time, &rf_arfcn, &tsc, &tn);
 332              		.loc 2 121 0
 333 0164 0F208DE2 		add	r2, sp, #15
 334 0168 0E308DE2 		add	r3, sp, #14
 335 016c 0D00A0E1 		mov	r0, sp
 336 0170 0C108DE2 		add	r1, sp, #12
 337 0174 FEFFFFEB 		bl	rfch_get_params
 338              	.LVL21:
 122:layer1/prim_rx_nb.c **** 
 123:layer1/prim_rx_nb.c **** 		/* Set Channel Number depending on MFrame Task ID */
 124:layer1/prim_rx_nb.c **** 		rxnb.dl->chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 339              		.loc 2 124 0
 340 0178 0E10DDE5 		ldrb	r1, [sp, #14]	@ zero_extendqisi2
 341 017c 0900A0E1 		mov	r0, r9
 342 0180 244095E5 		ldr	r4, [r5, #36]
 343 0184 FEFFFFEB 		bl	mframe_task2chan_nr
 344 0188 0000C4E5 		strb	r0, [r4, #0]
 125:layer1/prim_rx_nb.c **** 
 126:layer1/prim_rx_nb.c **** 		/* Set SACCH indication in Link IDentifier */
 127:layer1/prim_rx_nb.c **** 		if (mf_task_flags & MF_F_SACCH)
 345              		.loc 2 127 0
 346 018c 01001AE3 		tst	sl, #1
 128:layer1/prim_rx_nb.c **** 			rxnb.dl->link_id = 0x40;
 347              		.loc 2 128 0
 348 0190 24209515 		ldrne	r2, [r5, #36]
 349 0194 4030A013 		movne	r3, #64
 350 0198 0130C215 		strneb	r3, [r2, #1]
 129:layer1/prim_rx_nb.c **** 		if (mf_task_flags & MF_F_PTCCH)
 351              		.loc 2 129 0
 352 019c 02301AE2 		ands	r3, sl, #2
 353 01a0 242095E5 		ldr	r2, [r5, #36]
 130:layer1/prim_rx_nb.c **** 			rxnb.dl->link_id = 0x80;
 354              		.loc 2 130 0
 355 01a4 7F30E013 		mvnne	r3, #127
 131:layer1/prim_rx_nb.c **** 		else
 132:layer1/prim_rx_nb.c **** 			rxnb.dl->link_id = 0x00;
 356              		.loc 2 132 0
 357 01a8 0130C2E5 		strb	r3, [r2, #1]
 358              	.LBB3:
 359              	.LBB4:
 360              		.file 3 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
 361              		.loc 3 51 0
 362 01ac BC30DDE1 		ldrh	r3, [sp, #12]
 363              	.LBE4:
 364              	.LBE3:
 133:layer1/prim_rx_nb.c **** 
 134:layer1/prim_rx_nb.c **** 		rxnb.dl->band_arfcn = htons(rf_arfcn);
 365              		.loc 2 134 0
 366 01b0 54E19FE5 		ldr	lr, .L34+16
 367 01b4 2324A0E1 		mov	r2, r3, lsr #8
 368 01b8 FF3003E2 		and	r3, r3, #255
 369 01bc 24109EE5 		ldr	r1, [lr, #36]
 370 01c0 032482E1 		orr	r2, r2, r3, asl #8
 371 01c4 2234A0E1 		mov	r3, r2, lsr #8
 372 01c8 0330C1E5 		strb	r3, [r1, #3]
 373 01cc 0220C1E5 		strb	r2, [r1, #2]
 135:layer1/prim_rx_nb.c **** 
 136:layer1/prim_rx_nb.c **** 		rxnb.dl->frame_nr = htonl(rx_time.fn);
 374              		.loc 2 136 0
 375 01d0 00209DE5 		ldr	r2, [sp, #0]
 376              	.LBB5:
 377              	.LBB6:
 378              	.LBB7:
 379              	.LBB8:
 380              		.file 4 "include/asm/swab.h"
   1:include/asm/swab.h **** /*
   2:include/asm/swab.h ****  *  arch/arm/include/asm/byteorder.h
   3:include/asm/swab.h ****  *
   4:include/asm/swab.h ****  * ARM Endian-ness.  In little endian mode, the data bus is connected such
   5:include/asm/swab.h ****  * that byte accesses appear as:
   6:include/asm/swab.h ****  *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
   7:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
   8:include/asm/swab.h ****  *  d0...d31
   9:include/asm/swab.h ****  *
  10:include/asm/swab.h ****  * When in big endian mode, byte accesses appear as:
  11:include/asm/swab.h ****  *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
  12:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
  13:include/asm/swab.h ****  *  d0...d31
  14:include/asm/swab.h ****  */
  15:include/asm/swab.h **** #ifndef __ASM_ARM_SWAB_H
  16:include/asm/swab.h **** #define __ASM_ARM_SWAB_H
  17:include/asm/swab.h **** 
  18:include/asm/swab.h **** #include <stdint.h>
  19:include/asm/swab.h **** #include <defines.h>
  20:include/asm/swab.h **** 
  21:include/asm/swab.h **** static inline uint32_t __arch_swab32(uint32_t x)
  22:include/asm/swab.h **** {
  23:include/asm/swab.h **** 	uint32_t t;
  24:include/asm/swab.h **** 
  25:include/asm/swab.h **** #ifndef __thumb__
  26:include/asm/swab.h **** 	if (!__builtin_constant_p(x)) {
  27:include/asm/swab.h **** 		/*
  28:include/asm/swab.h **** 		 * The compiler needs a bit of a hint here to always do the
  29:include/asm/swab.h **** 		 * right thing and not screw it up to different degrees
  30:include/asm/swab.h **** 		 * depending on the gcc version.
  31:include/asm/swab.h **** 		 */
  32:include/asm/swab.h **** 		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
 381              		.loc 4 32 0
 382 01d4 623822E0 		eor	r3, r2, r2, ror #16
 383              	.LVL22:
 384              	.LBE8:
 385              	.LBE7:
 386              	.LBE6:
 387              	.LBE5:
 388              		.loc 2 136 0
 389 01d8 FF38C3E3 		bic	r3, r3, #16711680
 390              	.LVL23:
 391 01dc 2334A0E1 		mov	r3, r3, lsr #8
 392 01e0 623423E0 		eor	r3, r3, r2, ror #8
 393 01e4 24209EE5 		ldr	r2, [lr, #36]
 394 01e8 23C8A0E1 		mov	ip, r3, lsr #16
 395 01ec 231CA0E1 		mov	r1, r3, lsr #24
 396 01f0 2304A0E1 		mov	r0, r3, lsr #8
 397 01f4 06C0C2E5 		strb	ip, [r2, #6]
 398 01f8 0710C2E5 		strb	r1, [r2, #7]
 399 01fc 00C0A0E3 		mov	ip, #0
 400              	.LVL24:
 401 0200 0430C2E5 		strb	r3, [r2, #4]
 402 0204 0500C2E5 		strb	r0, [r2, #5]
 403 0208 0C00A0E1 		mov	r0, ip
 404              	.LVL25:
 405              	.L25:
 137:layer1/prim_rx_nb.c **** 
 138:layer1/prim_rx_nb.c **** 		/* compute average snr and rx level */
 139:layer1/prim_rx_nb.c **** 		for (i = 0; i < 4; ++i) {
 406              		.loc 2 139 0
 407 020c 00219FE5 		ldr	r2, .L34+24
 140:layer1/prim_rx_nb.c **** 			avg_snr += rxnb.meas[i].snr;
 408              		.loc 2 140 0
 409 0210 B030DEE1 		ldrh	r3, [lr, #0]
 141:layer1/prim_rx_nb.c **** 			avg_dbm8 += rxnb.meas[i].pm_dbm8;
 410              		.loc 2 141 0
 411 0214 F410DEE1 		ldrsh	r1, [lr, #4]
 412 0218 08E08EE2 		add	lr, lr, #8
 413              		.loc 2 139 0
 414 021c 02005EE1 		cmp	lr, r2
 415              		.loc 2 140 0
 416 0220 030080E0 		add	r0, r0, r3
 417              		.loc 2 141 0
 418 0224 01C08CE0 		add	ip, ip, r1
 419              		.loc 2 139 0
 420 0228 8100001A 		bne	.L25
 142:layer1/prim_rx_nb.c **** 		}
 143:layer1/prim_rx_nb.c **** 		rxnb.dl->snr = avg_snr / 4;
 421              		.loc 2 143 0
 422 022c D8509FE5 		ldr	r5, .L34+16
 423 0230 242095E5 		ldr	r2, [r5, #36]
 144:layer1/prim_rx_nb.c **** 		rxnb.dl->rx_level = dbm2rxlev(avg_dbm8 / (8*4));
 424              		.loc 2 144 0
 425 0234 00005CE3 		cmp	ip, #0
 426              		.loc 2 143 0
 427 0238 2031A0E1 		mov	r3, r0, lsr #2
 428 023c 0930C2E5 		strb	r3, [r2, #9]
 429              		.loc 2 144 0
 430 0240 1F008CE2 		add	r0, ip, #31
 431              	.LVL26:
 432 0244 0C00A0A1 		movge	r0, ip
 433 0248 C002A0E1 		mov	r0, r0, asr #5
 434 024c 244095E5 		ldr	r4, [r5, #36]
 435 0250 FEFFFFEB 		bl	dbm2rxlev
 436              	.LVL27:
 145:layer1/prim_rx_nb.c **** 
 146:layer1/prim_rx_nb.c **** 		num_biterr = dsp_api.ndb->a_cd[2] & 0xffff;
 437              		.loc 2 146 0
 438 0254 A0309FE5 		ldr	r3, .L34
 439              		.loc 2 144 0
 440 0258 0800C4E5 		strb	r0, [r4, #8]
 441              		.loc 2 146 0
 442 025c 002093E5 		ldr	r2, [r3, #0]
 443 0260 023CA0E3 		mov	r3, #512
 444 0264 B33092E1 		ldrh	r3, [r2, r3]
 445              	.LVL28:
 446 0268 242095E5 		ldr	r2, [r5, #36]
 147:layer1/prim_rx_nb.c **** 		if (num_biterr > 0xff)
 447              		.loc 2 147 0
 448 026c FF0053E3 		cmp	r3, #255
 148:layer1/prim_rx_nb.c **** 			rxnb.dl->num_biterr = 0xff;
 449              		.loc 2 148 0
 450 0270 0030E083 		mvnhi	r3, #0
 451              	.LVL29:
 452              	.LVL30:
 149:layer1/prim_rx_nb.c **** 		else
 150:layer1/prim_rx_nb.c **** 			rxnb.dl->num_biterr = num_biterr;
 453              		.loc 2 150 0
 454 0274 0A30C2E5 		strb	r3, [r2, #10]
 151:layer1/prim_rx_nb.c **** 
 152:layer1/prim_rx_nb.c **** 		rxnb.dl->fire_crc = ((dsp_api.ndb->a_cd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> B_FI
 455              		.loc 2 152 0
 456 0278 7C509FE5 		ldr	r5, .L34
 457 027c 002095E5 		ldr	r2, [r5, #0]
 458 0280 7F3FA0E3 		mov	r3, #508
 459              	.LVL31:
 460 0284 80409FE5 		ldr	r4, .L34+16
 461 0288 B33092E1 		ldrh	r3, [r2, r3]
 462 028c 242094E5 		ldr	r2, [r4, #36]
 463 0290 603003E2 		and	r3, r3, #96
 464 0294 C332A0E1 		mov	r3, r3, asr #5
 465 0298 0B30C2E5 		strb	r3, [r2, #11]
 153:layer1/prim_rx_nb.c **** 
 154:layer1/prim_rx_nb.c **** 		/* update rx level for pm report */
 155:layer1/prim_rx_nb.c **** 		pu_update_rx_level(rxnb.dl->rx_level);
 466              		.loc 2 155 0
 467 029c 243094E5 		ldr	r3, [r4, #36]
 468 02a0 0800D3E5 		ldrb	r0, [r3, #8]	@ zero_extendqisi2
 469 02a4 FEFFFFEB 		bl	pu_update_rx_level
 156:layer1/prim_rx_nb.c **** 
 157:layer1/prim_rx_nb.c **** 		/* copy actual data, skipping the information block [0,1,2] */
 158:layer1/prim_rx_nb.c **** 		dsp_memcpy_from_api(rxnb.di->data, &dsp_api.ndb->a_cd[3], 23, 0);
 470              		.loc 2 158 0
 471 02a8 001095E5 		ldr	r1, [r5, #0]
 472 02ac 7F1F81E2 		add	r1, r1, #508
 473 02b0 1720A0E3 		mov	r2, #23
 474 02b4 0030A0E3 		mov	r3, #0
 475 02b8 061081E2 		add	r1, r1, #6
 476 02bc 280094E5 		ldr	r0, [r4, #40]
 477 02c0 FEFFFFEB 		bl	dsp_memcpy_from_api
 159:layer1/prim_rx_nb.c **** 
 160:layer1/prim_rx_nb.c **** 		l1_queue_for_l2(rxnb.msg);
 478              		.loc 2 160 0
 479 02c4 200094E5 		ldr	r0, [r4, #32]
 480 02c8 FEFFFFEB 		bl	l1_queue_for_l2
 161:layer1/prim_rx_nb.c **** 		rxnb.msg = NULL; rxnb.dl = NULL; rxnb.di = NULL;
 162:layer1/prim_rx_nb.c **** 
 163:layer1/prim_rx_nb.c **** 		/* clear downlink task */
 164:layer1/prim_rx_nb.c **** 		dsp_api.db_w->d_task_d = 0;
 481              		.loc 2 164 0
 482 02cc 082095E5 		ldr	r2, [r5, #8]
 483              		.loc 2 161 0
 484 02d0 0030A0E3 		mov	r3, #0
 485              		.loc 2 164 0
 486 02d4 B030C2E1 		strh	r3, [r2, #0]	@ movhi
 487              		.loc 2 161 0
 488 02d8 283084E5 		str	r3, [r4, #40]
 489 02dc 203084E5 		str	r3, [r4, #32]
 490 02e0 243084E5 		str	r3, [r4, #36]
 491              	.L18:
 492              	.LBE2:
 165:layer1/prim_rx_nb.c **** 	}
 166:layer1/prim_rx_nb.c **** 
 167:layer1/prim_rx_nb.c **** 	/* mark READ page as being used */
 168:layer1/prim_rx_nb.c **** 	dsp_api.r_page_used = 1;
 493              		.loc 2 168 0
 494 02e4 10309FE5 		ldr	r3, .L34
 495 02e8 0120A0E3 		mov	r2, #1
 496 02ec 182083E5 		str	r2, [r3, #24]
 497              	.L12:
 169:layer1/prim_rx_nb.c **** 
 170:layer1/prim_rx_nb.c **** 	return 0;
 171:layer1/prim_rx_nb.c **** }
 498              		.loc 2 171 0
 499 02f0 0000A0E3 		mov	r0, #0
 500 02f4 10D08DE2 		add	sp, sp, #16
 501 02f8 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 502              	.L35:
 503              		.align	2
 504              	.L34:
 505 02fc 00000000 		.word	dsp_api
 506 0300 34000000 		.word	.LC1
 507 0304 3C000000 		.word	.LC2
 508 0308 00000000 		.word	l1s
 509 030c 00000000 		.word	rxnb
 510 0310 C0500100 		.word	86208
 511 0314 20000000 		.word	rxnb+32
 512              	.LFE67:
 514              		.section	.rodata.str1.4
 515 004d 000000   		.align	2
 516              	.LC3:
 517 0050 6E625F63 		.ascii	"nb_cmd(0) and rxnb.msg != NULL\000"
 517      6D642830 
 517      2920616E 
 517      64207278 
 517      6E622E6D 
 518 006f 00       		.align	2
 519              	.LC4:
 520 0070 6E625F63 		.ascii	"nb_cmd(0): unable to allocate msgb\000"
 520      6D642830 
 520      293A2075 
 520      6E61626C 
 520      6520746F 
 521 0093 00       		.section	.text.l1s_nb_cmd,"ax",%progbits
 522              		.align	2
 524              	l1s_nb_cmd:
 525              	.LFB68:
 172:layer1/prim_rx_nb.c **** 
 173:layer1/prim_rx_nb.c **** static int l1s_nb_cmd(__unused uint8_t p1, uint8_t burst_id,
 174:layer1/prim_rx_nb.c **** 		      __unused uint16_t p3)
 175:layer1/prim_rx_nb.c **** {
 526              		.loc 2 175 0
 527              		@ args = 0, pretend = 0, frame = 4
 528              		@ frame_needed = 0, uses_anonymous_args = 0
 529              	.LVL32:
 530 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 531              	.LCFI3:
 532 0004 FF6001E2 		and	r6, r1, #255
 176:layer1/prim_rx_nb.c **** 	uint16_t arfcn;
 177:layer1/prim_rx_nb.c **** 	uint8_t tsc, tn;
 178:layer1/prim_rx_nb.c **** 
 179:layer1/prim_rx_nb.c **** 	putchart('N');
 180:layer1/prim_rx_nb.c **** 
 181:layer1/prim_rx_nb.c **** 	if (burst_id == 1) {
 533              		.loc 2 181 0
 534 0008 010056E3 		cmp	r6, #1
 535              		.loc 2 175 0
 536 000c 10D04DE2 		sub	sp, sp, #16
 537              	.LCFI4:
 538              	.LVL33:
 182:layer1/prim_rx_nb.c **** 		/* allocate message only at 2nd burst in case of
 183:layer1/prim_rx_nb.c **** 		 * consecutive/overlapping normal burst RX tasks */
 184:layer1/prim_rx_nb.c **** 		/* FIXME: we actually want all allocation out of L1S! */
 185:layer1/prim_rx_nb.c **** 		if (rxnb.msg) {
 186:layer1/prim_rx_nb.c **** 			/* Can happen when resetting ... */
 187:layer1/prim_rx_nb.c **** 			printf("nb_cmd(0) and rxnb.msg != NULL\n");
 188:layer1/prim_rx_nb.c **** 			msgb_free(rxnb.msg);
 189:layer1/prim_rx_nb.c **** 		}
 190:layer1/prim_rx_nb.c **** 		/* allocate msgb as needed. FIXME: from L1A ?? */
 191:layer1/prim_rx_nb.c **** 		rxnb.msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 192:layer1/prim_rx_nb.c **** 		if (!rxnb.msg)
 193:layer1/prim_rx_nb.c **** 			printf("nb_cmd(0): unable to allocate msgb\n");
 194:layer1/prim_rx_nb.c **** 		rxnb.dl = (struct l1ctl_info_dl *) msgb_put(rxnb.msg, sizeof(*rxnb.dl));
 195:layer1/prim_rx_nb.c **** 		rxnb.di = (struct l1ctl_data_ind *) msgb_put(rxnb.msg, sizeof(*rxnb.di));
 196:layer1/prim_rx_nb.c **** 	}
 197:layer1/prim_rx_nb.c **** 
 198:layer1/prim_rx_nb.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 199:layer1/prim_rx_nb.c **** 
 200:layer1/prim_rx_nb.c **** 	/* DDL_DSP_TASK, four normal bursts */
 201:layer1/prim_rx_nb.c **** 	dsp_load_tch_param(&l1s.next_time,
 539              		.loc 2 201 0
 540 0010 0050A0E3 		mov	r5, #0
 541              		.loc 2 185 0
 542 0014 D4409FE5 		ldr	r4, .L47
 543              		.loc 2 181 0
 544 0018 1B00001A 		bne	.L37
 545              	.LVL34:
 546              		.loc 2 185 0
 547 001c 203094E5 		ldr	r3, [r4, #32]
 548 0020 050053E1 		cmp	r3, r5
 549              		.loc 2 187 0
 550 0024 C8009FE5 		ldr	r0, .L47+4
 551              	.LVL35:
 552              		.loc 2 185 0
 553 0028 0C00000A 		beq	.L39
 554              		.loc 2 187 0
 555 002c FEFFFFEB 		bl	puts
 556              	.LVL36:
 557              		.loc 2 188 0
 558 0030 200094E5 		ldr	r0, [r4, #32]
 559 0034 FEFFFFEB 		bl	msgb_free
 560              	.LVL37:
 561              	.L39:
 562              		.loc 2 191 0
 563 0038 0300A0E3 		mov	r0, #3
 564 003c FEFFFFEB 		bl	l1ctl_msgb_alloc
 565              	.LVL38:
 566 0040 0030A0E1 		mov	r3, r0
 567              		.loc 2 192 0
 568 0044 000050E3 		cmp	r0, #0
 569              		.loc 2 191 0
 570 0048 203084E5 		str	r3, [r4, #32]
 571              		.loc 2 193 0
 572 004c A4009FE5 		ldr	r0, .L47+8
 573              		.loc 2 192 0
 574              		.loc 2 193 0
 575 0050 FEFFFF0B 		bleq	puts
 576              	.L41:
 577              		.loc 2 194 0
 578 0054 0C10A0E3 		mov	r1, #12
 579 0058 200094E5 		ldr	r0, [r4, #32]
 580 005c FEFFFFEB 		bl	msgb_put
 581              		.loc 2 195 0
 582 0060 1710A0E3 		mov	r1, #23
 583              		.loc 2 194 0
 584 0064 240084E5 		str	r0, [r4, #36]
 585              		.loc 2 195 0
 586 0068 200094E5 		ldr	r0, [r4, #32]
 587 006c FEFFFFEB 		bl	msgb_put
 588 0070 280084E5 		str	r0, [r4, #40]
 589              	.LVL39:
 590              	.L37:
 591              		.loc 2 198 0
 592 0074 0C108DE2 		add	r1, sp, #12
 593 0078 0F208DE2 		add	r2, sp, #15
 594              	.LVL40:
 595 007c 0E308DE2 		add	r3, sp, #14
 596 0080 74009FE5 		ldr	r0, .L47+12
 597              	.LVL41:
 598 0084 FEFFFFEB 		bl	rfch_get_params
 599              	.LVL42:
 600              		.loc 2 201 0
 601 0088 0EC0DDE5 		ldrb	ip, [sp, #14]	@ zero_extendqisi2
 602 008c 0530A0E1 		mov	r3, r5
 603 0090 0320A0E3 		mov	r2, #3
 604 0094 0510A0E1 		mov	r1, r5
 605 0098 5C009FE5 		ldr	r0, .L47+12
 606 009c 08C08DE5 		str	ip, [sp, #8]
 607 00a0 00508DE5 		str	r5, [sp, #0]
 608 00a4 04508DE5 		str	r5, [sp, #4]
 609 00a8 FEFFFFEB 		bl	dsp_load_tch_param
 610              	.LBB9:
 611              	.LBB10:
 612              		.file 5 "include/calypso/dsp.h"
   1:include/calypso/dsp.h **** #ifndef _CALYPSO_DSP_H
   2:include/calypso/dsp.h **** #define _CALYPSO_DSP_H
   3:include/calypso/dsp.h **** 
   4:include/calypso/dsp.h **** #include <calypso/dsp_api.h>
   5:include/calypso/dsp.h **** #include <rffe.h>
   6:include/calypso/dsp.h **** 
   7:include/calypso/dsp.h **** #define CAL_DSP_TGT_BB_LVL	80
   8:include/calypso/dsp.h **** 
   9:include/calypso/dsp.h **** struct gsm_time;
  10:include/calypso/dsp.h **** 
  11:include/calypso/dsp.h **** struct dsp_api {
  12:include/calypso/dsp.h **** 	T_NDB_MCU_DSP *ndb;
  13:include/calypso/dsp.h **** 	T_DB_DSP_TO_MCU *db_r;
  14:include/calypso/dsp.h **** 	T_DB_MCU_TO_DSP *db_w;
  15:include/calypso/dsp.h **** 	T_PARAM_MCU_DSP *param;
  16:include/calypso/dsp.h **** 	int r_page;
  17:include/calypso/dsp.h **** 	int w_page;
  18:include/calypso/dsp.h **** 	int r_page_used;
  19:include/calypso/dsp.h **** 	int frame_ctr;
  20:include/calypso/dsp.h **** };
  21:include/calypso/dsp.h **** 
  22:include/calypso/dsp.h **** extern struct dsp_api dsp_api;
  23:include/calypso/dsp.h **** 
  24:include/calypso/dsp.h **** void dsp_power_on(void);
  25:include/calypso/dsp.h **** void dsp_dump_version(void);
  26:include/calypso/dsp.h **** void dsp_dump(void);
  27:include/calypso/dsp.h **** void dsp_checksum_task(void);
  28:include/calypso/dsp.h **** void dsp_api_memset(uint16_t *ptr, int octets);
  29:include/calypso/dsp.h **** void dsp_memcpy_to_api(volatile uint16_t *dsp_buf, const uint8_t *mcu_buf, int n, int be);
  30:include/calypso/dsp.h **** void dsp_memcpy_from_api(uint8_t *mcu_buf, const volatile uint16_t *dsp_buf, int n, int be);
  31:include/calypso/dsp.h **** void dsp_load_afc_dac(uint16_t afc);
  32:include/calypso/dsp.h **** void dsp_load_apc_dac(uint16_t apc);
  33:include/calypso/dsp.h **** void dsp_load_tch_param(struct gsm_time *next_time,
  34:include/calypso/dsp.h ****                         uint8_t chan_mode, uint8_t chan_type, uint8_t chan_sub,
  35:include/calypso/dsp.h ****                         uint8_t tch_loop, uint8_t sync_tch, uint8_t tn);
  36:include/calypso/dsp.h **** void dsp_load_ciph_param(int mode, uint8_t *key);
  37:include/calypso/dsp.h **** void dsp_end_scenario(void);
  38:include/calypso/dsp.h **** 
  39:include/calypso/dsp.h **** void dsp_load_rx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  40:include/calypso/dsp.h **** void dsp_load_tx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  41:include/calypso/dsp.h **** 
  42:include/calypso/dsp.h **** static inline uint16_t
  43:include/calypso/dsp.h **** dsp_task_iq_swap(uint16_t dsp_task, uint16_t band_arfcn, int tx)
  44:include/calypso/dsp.h **** {
  45:include/calypso/dsp.h **** 	if (rffe_iq_swapped(band_arfcn, tx))
 613              		.loc 5 45 0
 614 00ac 0510A0E1 		mov	r1, r5
 615              	.LVL43:
 616 00b0 BC00DDE1 		ldrh	r0, [sp, #12]
 617 00b4 FEFFFFEB 		bl	rffe_iq_swapped
 618              	.LBE10:
 619              	.LBE9:
 202:layer1/prim_rx_nb.c **** 	                   SIG_ONLY_MODE, SDCCH_4, 0, 0, 0, tn);
 203:layer1/prim_rx_nb.c **** 
 204:layer1/prim_rx_nb.c **** 	dsp_load_rx_task(
 620              		.loc 2 204 0
 621 00b8 40309FE5 		ldr	r3, .L47+16
 622 00bc 000050E3 		cmp	r0, #0
 623 00c0 0300A011 		movne	r0, r3
 624 00c4 1800A003 		moveq	r0, #24
 625 00c8 0610A0E1 		mov	r1, r6
 626              	.LVL44:
 627 00cc 0F20DDE5 		ldrb	r2, [sp, #15]	@ zero_extendqisi2
 628 00d0 FEFFFFEB 		bl	dsp_load_rx_task
 205:layer1/prim_rx_nb.c **** 		dsp_task_iq_swap(ALLC_DSP_TASK, arfcn, 0),
 206:layer1/prim_rx_nb.c **** 		burst_id, tsc
 207:layer1/prim_rx_nb.c **** 	);
 208:layer1/prim_rx_nb.c **** 
 209:layer1/prim_rx_nb.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 629              		.loc 2 209 0
 630 00d4 BC00DDE1 		ldrh	r0, [sp, #12]
 631 00d8 0310A0E3 		mov	r1, #3
 632 00dc 0520A0E1 		mov	r2, r5
 633 00e0 FEFFFFEB 		bl	l1s_rx_win_ctrl
 210:layer1/prim_rx_nb.c **** 
 211:layer1/prim_rx_nb.c **** 	return 0;
 212:layer1/prim_rx_nb.c **** }
 634              		.loc 2 212 0
 635 00e4 0500A0E1 		mov	r0, r5
 636 00e8 10D08DE2 		add	sp, sp, #16
 637 00ec 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 638              	.L48:
 639              		.align	2
 640              	.L47:
 641 00f0 00000000 		.word	rxnb
 642 00f4 50000000 		.word	.LC3
 643 00f8 70000000 		.word	.LC4
 644 00fc 0C000000 		.word	l1s+12
 645 0100 18800000 		.word	32792
 646              	.LFE68:
 648              		.bss
 649              		.align	2
 650              	rxnb:
 651 0000 00000000 		.space	44
 651      00000000 
 651      00000000 
 651      00000000 
 651      00000000 
 761              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prim_rx_nb.c
     /tmp/ccZ6cmsQ.s:15     .rodata:0000000000000000 nb_sched_set
     /tmp/ccZ6cmsQ.s:16     .rodata:0000000000000000 $d
     /tmp/ccZ6cmsQ.s:524    .text.l1s_nb_cmd:0000000000000000 l1s_nb_cmd
     /tmp/ccZ6cmsQ.s:185    .text.l1s_nb_resp:0000000000000000 l1s_nb_resp
     /tmp/ccZ6cmsQ.s:95     .text.msgb_tailroom:0000000000000000 msgb_tailroom
     /tmp/ccZ6cmsQ.s:103    .text.msgb_tailroom:0000000000000000 $a
     /tmp/ccZ6cmsQ.s:124    .text.msgb_put:0000000000000000 msgb_put
     /tmp/ccZ6cmsQ.s:130    .text.msgb_put:0000000000000000 $a
     /tmp/ccZ6cmsQ.s:172    .text.msgb_put:000000000000004c $d
     /tmp/ccZ6cmsQ.s:192    .text.l1s_nb_resp:0000000000000000 $a
     /tmp/ccZ6cmsQ.s:505    .text.l1s_nb_resp:00000000000002fc $d
     /tmp/ccZ6cmsQ.s:650    .bss:0000000000000000 rxnb
     /tmp/ccZ6cmsQ.s:530    .text.l1s_nb_cmd:0000000000000000 $a
     /tmp/ccZ6cmsQ.s:641    .text.l1s_nb_cmd:00000000000000f0 $d

UNDEFINED SYMBOLS
tdma_end_set
osmo_panic
puts
printf
gsm_fn2gsmtime
rfch_get_params
agc_inp_dbm8_by_pm
afc_input
toa_input
rffe_compute_gain
mframe_task2chan_nr
dbm2rxlev
pu_update_rx_level
dsp_memcpy_from_api
l1_queue_for_l2
dsp_api
l1s
msgb_free
l1ctl_msgb_alloc
dsp_load_tch_param
rffe_iq_swapped
dsp_load_rx_task
l1s_rx_win_ctrl
